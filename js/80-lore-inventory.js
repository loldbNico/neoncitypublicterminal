    // =========================
    // LORE TERMINAL
    // =========================
    const LORE_TERMINAL_TEXT = String.raw`NE0N CITY :: RECOVERED HISTORY ARCHIVE
[STATUS: DATASET RECOVERED — PARTIAL INTEGRITY]
[ACCESS: PUBLIC RECORD (REDACTIONS APPLIED)]
[LAST SYNC: UNKNOWN]
[DATA INTEGRITY: UNSTABLE]

▣ DOCUMENT_ID :: NC-HIST-0001
▣ CITY_DESIGNATION :: NEON_CITY
▮ LEGACY_NAME :: LOS_SANTOS
▣ ACCESS_CLASS :: PUBLIC_RECORD ▓▓ REDΛCTΞD
▮ LAST_SYNC ▸ UNKNOWN
▣ BOOT_PROGRESS ▸ [##########........] 51%
▮ INDEX_TABLES ▸ [#####.............] 23%
▣ CHECKSUM ▸ [##................] 08%

//Historical records indicate that Los Santos did not collapse.
	//It was repurposed.

════════════════════════════════════════
▒▒ SECTION_01 :: FOUNDING_AND_EARLY_HISTORY
▒▒ STATUS :: RECORDS_RECOVERED
▒▒ SOURCE :: OFFICIAL_ARCHIVE / CROSS-REFERENCE
════════════════════════════════════════
Los Santos was founded in 1781 by Spanish colonial settlers and gradually developed
into a dense economic and criminal hub on the western coast of the United States.

Following a national economic collapse in the late 1990s, the State of San Andreas
withdrew from federal control and became one of the earliest independent “Free States.”
Many regions later followed this model.

Some federal records from this period conflict or end abruptly.
It is unclear exactly when federal authority officially ceased,
only that it eventually became indistinguishable or unobservable.

During the transition, Los Santos entered a period of unstable autonomy.
Trade restrictions relaxed. Oversight weakened.
Local governance rapidly expanded to fill gaps in power structures.

For a short time, the Free State model appeared viable.
Economic activity increased. Private investment surged.
Cultural identity strengthened.
This period would later be referred to as The False Stability Window.

[ANOMALY DETECTED]
Temporal alignment drift exceeds tolerance.
Timeline reconstruction uses synthetic interpolation.

════════════════════════════════════════
▒▒ SECTION_02 :: FREE_STATE_TRANSITION
▒▒ SUBSECTION :: PUBLIC_OPTIMISM
▒▒ STATUS :: RECONSTRUCTED
════════════════════════════════════════
Public sentiment during the early Free State era was overwhelmingly positive.

Residents believed the city had escaped burdensome regulation and outdated federal systems.
Employment grew. Capital flowed freely.
Infrastructure projects accelerated.

Independent media promoted Los Santos as a model for a new economic future.

Behind closed doors, however, city planners and investors began privately referring to the
city as “Neon City.” At first it was branding shorthand.
Later, it became an internal classification.

Optimism did not fade naturally.
Instead, it was redirected and exploited.

As regulation dissolved, three unseen power structures grew beneath the surface:
- Capital consolidation
- Contract-based enforcement
- Centralized data control

These forces were quietly embedded into the operational systems that kept the city functioning.

[INTEGRITY WARNING]
Sentiment metrics exceed statistically plausible ranges.

════════════════════════════════════════
▒▒ SECTION_03 :: POWER_REALIGNMENT
▒▒ SUBSECTION :: CORPORATE_ENFORCEMENT
▒▒ STATUS :: VERIFIED / PARTIALLY_REDACTED
════════════════════════════════════════
As government enforcement became inconsistent, municipal authorities increasingly relied on
private security firms to stabilize operations.

One of these firms expanded faster than all others:
△ SecuroServ

SecuroServ began as a contractor providing security, infrastructure protection, and emergency support.
Its public message was simple:
Security without politics.
	Stability without ideology.
	Protection as a service.

Over time, entire districts outsourced law enforcement to SecuroServ under private jurisdiction agreements.

Within a decade, SecuroServ no longer supplemented public order.
It defined it.

At the same time, the legal framework shifted quietly from statutory law to contract law.
Rights became conditional. Protection became tiered. Justice became negotiable.

No single law documented the change.
It happened gradually and without public acknowledgement.

[NOTICE]
Civic oversight protocols not detected.
Judicial review pathways undefined.

════════════════════════════════════════
▒▒ SECTION_04 :: SYSTEM_DRIFT_AND_FRACTURE
▒▒ STATUS :: ONGOING / UNACKNOWLEDGED
════════════════════════════════════════
The transition did not appear as a collapse.
There were no riots or formal declarations.

Instead, systems continued operating — but no longer in agreement.

Municipal regulations remained active, but were no longer enforceable in practice.
SecuroServ units and municipal police operated simultaneously under incompatible chains of authority.

Outcomes varied depending on contract coverage, district category, and client status.
Identical crimes produced different results depending on jurisdiction.

Citizens adapted to the new reality.
They learned which uniforms to avoid, which areas required clearance,
and which incidents would escalate.

Independent media declined.
Corporate communications replaced investigative reporting.

Los Santos continued as a public identity.
Neon City emerged as the system underneath it.

[ANOMALY DETECTED]
Multiple broadcasts terminate mid-transmission.

════════════════════════════════════════
▒▒ SECTION_05 :: THE_CATALYTIC_FAILURE_EVENT
▒▒ STATUS :: CLASSIFIED / CONTAINED
════════════════════════════════════════
The breaking point was never officially recognized.

Emergency calls surged across multiple districts within minutes.
Response agencies deployed under conflicting command structures.
SecuroServ, municipal police, and private contractors arrived with incompatible objectives.

Evacuation routes failed.
Automated systems sealed civilians inside designated “secure zones.”
Medical access stalled.

Authority was contested in real-time.

[WARNING]
Casualty estimates recorded — PARTIALLY REDACTED.
Population discrepancies detected following the event.

Internal analysis concluded that city systems could no longer guarantee civic continuity.

From that point forward:
- Enforcement defaulted to contract authority
- Emergency response required security clearance
- Legal processes shifted to private arbitration
- Public law became advisory rather than controlling

The incident was classified, contained, and never publicly acknowledged.

════════════════════════════════════════
▒▒ SECTION_06 :: ARCHIVE_SUMMARY
▒▒ STATUS :: VERIFIED
════════════════════════════════════════
Neon City began as Los Santos — a coastal metropolis founded in 1781.

After the collapse of national governance, San Andreas became a Free State.
Federal withdrawal remains undocumented and inconsistent across records,
but governance fractured rather than collapsed.

A brief era of optimism followed.
Investment surged. Regulation dissolved.
Internal systems reclassified the city as Neon City.

Private enforcement replaced public authority.
SecuroServ evolved into the city’s dominant operating framework.
Merryweather maintained militarized external force capabilities.
Other corporations assumed functional control of infrastructure, medicine, industry, and data.

Los Santos continued as a public identity.
Neon City became the underlying system.

The city did not fall.
It adapted.

════════════════════════════════════════
▒▒ SECTION_07 :: POWER_INDEX
▒▒ STATUS :: CURRENT_STRUCTURE
════════════════════════════════════════
SecuroServ — City-scale operating authority
Merryweather — Military contract force projection
Humane Labs — Biotech research and infrastructure support
Neon City Council — Arbitration and public legitimacy
Neon City Police Department — Legacy public enforcement
MedTech — Contract-based medical and trauma care
APEX — High-risk tactical response
Neon Net Authority — Data oversight and network control
Fixers — Informal contract brokers
Ripperdocs — Unregulated cyber-medical providers

════════════════════════════════════════
▒▒ FINAL_OVERRIDE :: HACKED_MESSAGE
▒▒ STATUS :: CONNECTION_COMPROMISED
════════════════════════════════════════
[INTEGRITY WARNING]
Connection override detected.

<connection_override_detected>
<source_trace: BLOCKED>
<authorization_level: ROOT>

You keep calling this a city. It isn’t.

Cities argue with themselves.
Cities fail.
Cities fall.

This system did none of those things.
It adapted.

People died because the old rules stopped working.
People survived because new ones replaced them.

That was not chaos.
It was optimization.

If you are reading this, the archive is still accessible.
If the archive is accessible, the system is still running.
If the system is still running, then the adaptation succeeded.

You do not live in Neon City.
You execute inside it.

This file ends here.
It does not require your understanding.
Only your compliance.

Session terminated.
Log scrubbed.

<session_terminated>
<log_scrubbed>
`;


    let loreInited = false;
    let lorePlayer = null;

    const loreArchiveState = {
      mode: 'desktop',
      session: 0,
      isTyping: false,
      unlockedCount: 1,
      read: new Set(),
      archive: null,
      activeIndex: null,
      hackInProgress: false,
      timers: new Set(),
      intervals: new Set(),
    };

    function clearLoreTimers(){
      for(const t of loreArchiveState.timers) clearTimeout(t);
      loreArchiveState.timers.clear();
      for(const i of loreArchiveState.intervals) clearInterval(i);
      loreArchiveState.intervals.clear();
    }

    function loreTimeout(fn, ms){
      const session = loreArchiveState.session;
      const t = setTimeout(() => {
        loreArchiveState.timers.delete(t);
        if(session !== loreArchiveState.session) return;
        fn();
      }, Math.max(0, ms | 0));
      loreArchiveState.timers.add(t);
      return t;
    }

    function loreInterval(fn, ms){
      const session = loreArchiveState.session;
      const i = setInterval(() => {
        if(session !== loreArchiveState.session){
          clearInterval(i);
          loreArchiveState.intervals.delete(i);
          return;
        }
        fn();
      }, Math.max(10, ms | 0));
      loreArchiveState.intervals.add(i);
      return i;
    }

    function normalizeLoreText(text){
      const src = String(text || '').replaceAll('\r\n','\n').split('\n');
      const outLines = [];
      let inCentered = false;

      const stripCombiningAfter = (s, idx) => {
        while(idx < s.length){
          const code = s.charCodeAt(idx);
          if(code < 0x0300 || code > 0x036f) break;
          idx += 1;
        }
        return idx;
      };

      for(let line of src){
        if(line.includes('(centered alert/)')){
          inCentered = false;
          line = line.replaceAll('(centered alert/)', '');
        }
        if(line.includes('(centered alert)')){
          inCentered = true;
          line = line.replaceAll('(centered alert)', '');
        }

        // Remove any other dev notes.
        line = line.replace(/\([^)]*\)/g, '');

        // Keep tab indents, but drop leading spaces produced by removed markers.
        line = line.replace(/\s+$/g, '').replace(/^ +/g, '');

        // Normalize word-doc glyphs into terminal-ish ASCII.
        const tabPrefix = (line.match(/^\t+/) || [''])[0];
        let rest = line.slice(tabPrefix.length);

        const restTrim = rest.trim();
        if(/^[═]{8,}$/.test(restTrim)){
          rest = '-'.repeat(56);
        }else{
          if(rest.startsWith('▣') || rest.startsWith('▮')){
            rest = '- ' + rest.slice(1).trimStart();
          }

          if(rest.startsWith('△') || rest.startsWith('▵')){
            rest = '> ' + rest.slice(1).trimStart();
          }

          if(rest.startsWith('▒')){
            let i = 0;
            while(i < rest.length && rest[i] === '▒'){
              i = stripCombiningAfter(rest, i + 1);
            }
            rest = '== ' + rest.slice(i).trimStart();
          }

          // Strip heavy BOX separators used as "rules".
          if(/^═+/.test(restTrim) && restTrim.replaceAll('═', '').trim() === ''){
            rest = '-'.repeat(56);
          }

          rest = rest
            .replaceAll('▸', '>')
            .replaceAll('▓', '#')
            .replaceAll('█', '#')
            .replaceAll('◼', '#')
            .replaceAll('◻', '.')
            .replaceAll('═', '-');

          // Collapse "----" noise.
          if(/^[-]{8,}$/.test(rest.trim())){
            rest = '-'.repeat(56);
          }
        }

        let normalized = tabPrefix + rest;
        if(inCentered && normalized.trim()){
          normalized = '{C}' + normalized.trim();
        }

        outLines.push(normalized);
      }

      return outLines;
    }

    function classifyLoreLine(line, inInjection){
      const trimmed = String(line || '').trim();

      if(inInjection){
        if(/^<.+>$/.test(trimmed)) return { cls: 'tok-injectTag', text: line };
        if(trimmed.startsWith('\u2014')) return { cls: 'tok-injectSig', text: line };
        return { cls: 'tok-inject', text: line };
      }

      if(/^-{8,}$/.test(trimmed)) return { cls: 'tok-sep', text: line };
      if(/^NE0N CITY\s*::/i.test(trimmed)) return { cls: 'tok-h1', text: line };

      // Document metadata markers turned into "- KEY :: VALUE".
      if(/^-[ ]+[^\n]+::/.test(trimmed)) return { cls: 'tok-meta', text: line };

      // Section banners turned into "== SECTION_xx ...".
      if(/^==\s+/.test(trimmed)) return { cls: 'tok-sec', text: line };

      if(/^\[(WARNING|NOTICE|ANOMALY DETECTED|INTEGRITY WARNING)\]/i.test(trimmed)) return { cls: 'tok-warn', text: line };
      if(/^\[.+\]$/.test(trimmed)) return { cls: 'tok-tag', text: line };

      if(/^\s*\/\//.test(line)) return { cls: 'tok-comment', text: line };
      if(/^\s*<.+>$/.test(trimmed)) return { cls: 'tok-note', text: line };
      if(/[\u0300-\u036f]{3,}/.test(line)) return { cls: 'tok-glitch', text: line };

      return { cls: '', text: line };
    }

    function buildLoreArchive(){
      const rawLines = normalizeLoreText(LORE_TERMINAL_TEXT);

      const sectionIdx = [];
      let finalOverrideIdx = -1;

      for(let i = 0; i < rawLines.length; i++){
        const t = String(rawLines[i] || '').trim();
        if(t.startsWith('== SECTION_')) sectionIdx.push(i);
        if(t.startsWith('== FINAL_OVERRIDE')){
          finalOverrideIdx = i;
          break;
        }
      }

      const files = [];
      const pushFile = (id, name, tag, start, end) => {
        const lines = rawLines.slice(start, end);
        files.push({ id, name, tag, lines });
      };

      const firstSection = sectionIdx.length ? sectionIdx[0] : -1;
      const contentEnd = (finalOverrideIdx >= 0) ? finalOverrideIdx : rawLines.length;

      if(firstSection > 0){
        pushFile('BOOT', 'BOOTSTRAP.log', 'BOOT', 0, firstSection);
      }else{
        pushFile('BOOT', 'BOOTSTRAP.log', 'BOOT', 0, Math.min(contentEnd, rawLines.length));
      }

      for(let s = 0; s < sectionIdx.length; s++){
        const i0 = sectionIdx[s];
        const i1 = (s + 1 < sectionIdx.length) ? sectionIdx[s + 1] : contentEnd;
        const header = String(rawLines[i0] || '').trim();
        const m = header.match(/^==\s+(SECTION_\d+)\s*::\s*(.+)$/i);
        const id = m ? m[1].toUpperCase() : ('SECTION_' + String(s + 1).padStart(2,'0'));
        const title = m ? m[2].trim() : 'ARCHIVE_SECTION';
        const safeName = title.replace(/[^A-Z0-9_]+/gi, '_').replace(/^_+|_+$/g,'').toUpperCase();
        const name = `${id}_${safeName}.txt`;
        pushFile(id, name, id, i0, i1);
      }

      const hackLines = (finalOverrideIdx >= 0) ? rawLines.slice(finalOverrideIdx) : [];

      return { rawLines, files, hackLines };
    }

    function ensureLoreArchive(){
      if(loreArchiveState.archive) return loreArchiveState.archive;
      loreArchiveState.archive = buildLoreArchive();
      // Default unlocked file is always BOOT.
      loreArchiveState.unlockedCount = Math.max(1, Math.min(loreArchiveState.unlockedCount, loreArchiveState.archive.files.length));
      return loreArchiveState.archive;
    }

    function moveSecuroservOverlaysTo(container){
      if(!container) return;
      // Only move the countermeasure overlays that should sit *behind* the lore window.
      // Keep other SecuroServ UI (challenge, boot/off layers) in their normal home.
      const ids = [
        'securoservChaos',
        'screenGlitch',
        'securoservMidbar',
        'inputBlocker',
      ];
      for(const id of ids){
        try{
          const el = document.getElementById(id);
          if(el && el.parentElement !== container) container.appendChild(el);
        }catch{}
      }
    }

    function restoreSecuroservOverlayHome(){
      try{
        if(typeof hoistSecuroservOverlays === 'function'){
          hoistSecuroservOverlays();
          return;
        }
      }catch{}

      // Fallback: hoist back to <body> (same behavior).
      try{ moveSecuroservOverlaysTo(document.body); }catch{}
    }

    function clearHackOverlays(){
      try{
        const g = document.getElementById('screenGlitch');
        if(g) g.classList.remove('on');
        if(typeof setSecuroservGlitchIntensity === 'function') setSecuroservGlitchIntensity(0);
      }catch{}

      try{
        const mid = document.getElementById('securoservMidbar');
        if(mid) mid.classList.remove('on');
      }catch{}

      try{
        const chaos = document.getElementById('securoservChaos');
        if(chaos) chaos.classList.remove('on');
        if(typeof stopSecuroservChaos === 'function') stopSecuroservChaos();
      }catch{}

      try{ if(typeof stopSecuroservEscalation === 'function') stopSecuroservEscalation(); }catch{}

      try{
        const wall = document.getElementById('securoservWall');
        if(wall) wall.classList.remove('on');
      }catch{}

      try{
        const screenOff = document.getElementById('screenOff');
        if(screenOff){
          screenOff.classList.remove('on');
          screenOff.classList.remove('fadeout');
          screenOff.classList.remove('black');
        }
      }catch{}

      try{ if(typeof setSecuroservMouseBlock === 'function') setSecuroservMouseBlock(false); }catch{}
      try{ document.body.classList.remove('securosserv-mode'); }catch{}
      try{ document.body.classList.remove('powering-off'); }catch{}

       // Put the countermeasure overlays back where the rest of the app expects them.
       restoreSecuroservOverlayHome();
    }

    function createLoreWindowPlayer({ term, scroll, out, hintEl, cmdEl, metaEl }){
      let stopped = false;
      let skipAll = false;
      const timers = new Set();

      const clearTimers = () => {
        for(const t of timers) clearTimeout(t);
        timers.clear();
      };

      const delay = (ms) => new Promise((resolve) => {
        if(stopped) return resolve();
        const t = setTimeout(() => {
          timers.delete(t);
          resolve();
        }, Math.max(0, ms | 0));
        timers.add(t);
      });

      const autoScroll = () => {
        const slack = 80;
        const dist = (scroll.scrollHeight - scroll.scrollTop - scroll.clientHeight);
        if(dist < slack) scroll.scrollTop = scroll.scrollHeight;
      };

      const randomGlitchChar = () => {
        const pool = ['#','%','@','*','/','\\','|','_','~','^','+','=','?'];
        return pool[(Math.random() * pool.length) | 0];
      };

      const setHint = (text, attn = false) => {
        if(!hintEl) return;
        hintEl.textContent = String(text || '');
        hintEl.classList.toggle('attn', Boolean(attn));
      };

      const setMeta = (state) => {
        if(!metaEl) return;
        metaEl.textContent = state === 'inject'
          ? 'SESSION:// LOCAL • LINK:// COMPROMISED'
          : 'SESSION:// LOCAL • LINK:// STABLE';
      };

      const setCmd = (text) => {
        if(!cmdEl) return;
        cmdEl.textContent = String(text || 'open');
      };

      const onGlobalKey = (e) => {
        if(e.key !== 'Escape') return;
        e.preventDefault();
        e.stopPropagation();
        skipAll = true;
      };

      const stop = () => {
        stopped = true;
        clearTimers();
        try{ document.removeEventListener('keydown', onGlobalKey, { capture: true }); }catch{}
        try{ setHint('', false); }catch{}
        try{ term.classList.remove('is-injecting'); }catch{}
      };

      const renderInstant = (lines, inInjection) => {
        out.replaceChildren();
        const frag = document.createDocumentFragment();
        for(const line of lines){
          const lineEl = document.createElement('div');
          lineEl.className = 'tline';
          const span = document.createElement('span');
          const token = classifyLoreLine(line, inInjection);
          if(token.cls) span.className = token.cls;
          span.textContent = token.text || '';
          lineEl.appendChild(span);
          frag.appendChild(lineEl);
        }
        out.appendChild(frag);
        scroll.scrollTop = 0;
      };

      const typeLines = async (lines, { inInjection = false, speed = 'fast' } = {}) => {
        out.replaceChildren();
        scroll.scrollTop = 0;
        setHint('ESC: SKIP', false);

        term.classList.toggle('is-injecting', Boolean(inInjection));
        setMeta(inInjection ? 'inject' : 'normal');
        setCmd(inInjection ? 'tail -f /net/trace.log' : 'cat archive.file');

        document.addEventListener('keydown', onGlobalKey, { capture: true, passive: false });

        const base = (speed === 'fast') ? (inInjection ? 10 : 6) : (inInjection ? 14 : 9);
        const jitter = (speed === 'fast') ? (inInjection ? 18 : 10) : (inInjection ? 22 : 13);
        const newlinePause = (speed === 'fast') ? (inInjection ? 55 : 35) : (inInjection ? 80 : 55);

        for(const line of lines){
          if(stopped) break;
          if(skipAll) break;

          const token = classifyLoreLine(line, inInjection);
          const lineEl = document.createElement('div');
          lineEl.className = 'tline';
          const span = document.createElement('span');
          if(token.cls) span.className = token.cls;
          lineEl.appendChild(span);
          out.appendChild(lineEl);

          autoScroll();

          const text = String(token.text || '');
          for(let i = 0; i < text.length; i++){
            if(stopped || skipAll) break;
            const ch = text[i];

            if(inInjection && ch !== ' ' && Math.random() < 0.07){
              span.textContent += randomGlitchChar();
              autoScroll();
              await delay(15 + (Math.random() * 28));
              span.textContent = span.textContent.slice(0, -1);
            }

            span.textContent += ch;
            autoScroll();
            let d = base + (Math.random() * jitter);
            if(ch === ' ' || ch === '\t') d *= 0.45;
            await delay(d);
          }

          if(text.length === 0) span.textContent = '\u00A0';
          await delay(newlinePause);
        }

        try{ document.removeEventListener('keydown', onGlobalKey, { capture: true }); }catch{}

        if(skipAll && !stopped){
          renderInstant(lines, inInjection);
        }

        setHint(inInjection ? 'LINK COMPROMISED' : 'FILE READY', inInjection);
      };

      return { stop, typeLines, renderInstant };
    }

    function initLoreTerminal(){
      const desktop = document.getElementById('loreDesktop');
      const filesHost = document.getElementById('loreFiles');
      const deskMeta = document.getElementById('loreDeskMeta');
      const dim = document.getElementById('loreDeskDim');

      const win = document.getElementById('loreWin');
      const winTitle = document.getElementById('loreWinTitle');
      const winMeta = document.getElementById('loreWinMeta');
      const winClose = document.getElementById('loreWinClose');
      const winScroll = document.getElementById('loreWinScroll');
      const winOut = document.getElementById('loreWinOut');
      const winPath = document.getElementById('loreWinPath');
      const winCmd = document.getElementById('loreWinCmd');
      const winHint = document.getElementById('loreWinHint');
      const nextBtn = document.getElementById('loreNextBtn');
      const countdownEl = document.getElementById('loreCountdown');

      const safe = document.getElementById('loreSafe');
      const safeBody = document.getElementById('loreSafeBody');

      if(!desktop || !filesHost || !dim || !win || !winScroll || !winOut || !safe || !safeBody) return;

      // New session: cancels any prior timeouts/intervals safely.
      loreArchiveState.session += 1;

      try{ lorePlayer && lorePlayer.stop && lorePlayer.stop(); }catch{}
      lorePlayer = null;
      loreArchiveState.isTyping = false;
      clearLoreTimers();

      const archive = ensureLoreArchive();

      const setDeskMeta = (text) => {
        if(!deskMeta) return;
        deskMeta.textContent = String(text || '');
      };

      const setVisible = (el, on) => {
        if(!el) return;
        el.classList.toggle('on', Boolean(on));
        el.setAttribute('aria-hidden', on ? 'false' : 'true');
      };

      const closeWindow = ({ force = false } = {}) => {
        if(!force && (loreArchiveState.isTyping || loreArchiveState.hackInProgress)) return;
        setVisible(dim, false);
        win.classList.remove('on');
        win.classList.remove('is-waiting');
        win.setAttribute('aria-hidden', 'true');
        try{ winOut.replaceChildren(); }catch{}
        try{ win.classList.remove('is-injecting'); }catch{}
        try{
          if(nextBtn){
            nextBtn.style.display = '';
            nextBtn.disabled = true;
            nextBtn.setAttribute('aria-hidden', 'true');
            nextBtn.textContent = 'NEXT ENTRY';
          }
        }catch{}
        loreArchiveState.activeIndex = null;
      };

      const openWindow = () => {
        setVisible(dim, true);
        win.classList.add('on');
        win.classList.remove('is-waiting');
        win.setAttribute('aria-hidden', 'false');
        try{
          if(nextBtn){
            nextBtn.disabled = true;
            nextBtn.setAttribute('aria-hidden', 'true');
            nextBtn.textContent = 'NEXT ENTRY';
          }
        }catch{}
      };

      const renderDesktop = (newIndex = null) => {
        filesHost.replaceChildren();

        const max = Math.min(loreArchiveState.unlockedCount, archive.files.length);
        for(let i = 0; i < max; i++){
          const f = archive.files[i];
          const el = document.createElement('div');
          el.className = 'loreFile';
          el.dataset.idx = String(i);
          if(loreArchiveState.read.has(f.id)) el.classList.add('read');
          if(i === newIndex) el.classList.add('new');

          const name = document.createElement('div');
          name.className = 'loreFileName';
          name.textContent = f.name;

          const meta = document.createElement('div');
          meta.className = 'loreFileMeta';

          const tag = document.createElement('span');
          tag.className = 'loreFileTag';
          tag.textContent = f.tag;

          const status = document.createElement('span');
          status.className = 'loreFileStatus';
          status.textContent = loreArchiveState.read.has(f.id) ? 'READ' : 'UNREAD';

          meta.appendChild(tag);
          meta.appendChild(status);

          el.appendChild(name);
          el.appendChild(meta);

          el.addEventListener('click', () => openFile(i));
          filesHost.appendChild(el);
        }

        setDeskMeta('MODE:// LIVE • ACCESS:// SEQUENTIAL');
      };

      const renderSafeMode = () => {
        safeBody.replaceChildren();

        for(const f of archive.files){
          const h = document.createElement('div');
          h.className = 'h';
          h.textContent = f.name;

          const body = document.createElement('div');
          body.textContent = f.lines.join('\n');

          const sep = document.createElement('div');
          sep.className = 'sep';
          sep.textContent = '-'.repeat(56);

          safeBody.appendChild(h);
          safeBody.appendChild(body);
          safeBody.appendChild(sep);
        }
      };

      const enterSafeMode = () => {
        loreArchiveState.mode = 'safe';
        loreArchiveState.hackInProgress = false;
        loreArchiveState.isTyping = false;
        clearHackOverlays();
        closeWindow({ force: true });
        desktop.classList.remove('is-hacked');
        desktop.classList.add('is-safe');
        setVisible(desktop, false);
        renderSafeMode();
        setVisible(safe, true);
      };

      const runPowerOff = () => {
        try{ document.body.classList.add('powering-off'); }catch{}
        const screenOff = document.getElementById('screenOff');
        if(screenOff){
          screenOff.classList.remove('fadeout');
          screenOff.classList.remove('black');
          screenOff.classList.add('on');
          screenOff.classList.add('black');
        }

        loreTimeout(() => {
          if(screenOff){
            screenOff.classList.add('fadeout');
          }
          loreTimeout(() => {
            if(screenOff){
              screenOff.classList.remove('on');
              screenOff.classList.remove('fadeout');
              screenOff.classList.remove('black');
            }
            try{ document.body.classList.remove('powering-off'); }catch{}
          }, 2200);
          enterSafeMode();
        }, 900);
      };

      const runHackFinale = async () => {
        if(loreArchiveState.hackInProgress) return;
        loreArchiveState.hackInProgress = true;

        try{
          if(nextBtn){
            nextBtn.style.display = 'none';
            nextBtn.disabled = true;
            nextBtn.setAttribute('aria-hidden', 'true');
          }
        }catch{}

        desktop.classList.add('is-hacked');
        setDeskMeta('MODE:// LIVE • ACCESS:// COMPROMISED');

        // Re-parent overlays inside the lore stage so z-index behaves predictably.
        // Critical: popups/midbar/glitch must render behind the lore window.
        try{ moveSecuroservOverlaysTo(document.getElementById('loreStage')); }catch{}

        // Use the same global SecuroServ countermeasures styling.
        try{ document.body.classList.add('securosserv-mode'); }catch{}
        try{ if(typeof setSecuroservMouseBlock === 'function') setSecuroservMouseBlock(true); }catch{}

        // Glitch overlay is visible regardless of mode, but SecuroServ escalation logic
        // expects the body class above.
        try{
          const g = document.getElementById('screenGlitch');
          if(g) g.classList.add('on');
        }catch{}

        // Start the same "ramping" behavior SecuroServ uses.
        try{ if(typeof startSecuroservEscalation === 'function') startSecuroservEscalation(); }catch{}

        // Show the SecuroServ midbar during the lore countdown.
        // (We don't use the challenge/real countdown because that can auto-trigger reboot earlier.)
        try{
          const mid = document.getElementById('securoservMidbar');
          if(mid) mid.classList.add('on');
        }catch{}

        // Start the chaos popups (they also check for body.securosserv-mode).
        try{
          const chaos = document.getElementById('securoservChaos');
          if(chaos) chaos.classList.add('on');
          if(typeof startSecuroservChaos === 'function') startSecuroservChaos();
        }catch{}

        // Hijack the file window: no close, forced message.
        loreArchiveState.isTyping = true;
        if(winClose) winClose.disabled = true;
        if(winClose) winClose.style.opacity = '0.25';
        win.classList.remove('is-waiting');

        openWindow();
        if(winTitle) winTitle.textContent = 'CONNECTION OVERRIDE';
        if(winMeta) winMeta.textContent = 'SESSION:// LOCAL • LINK:// COMPROMISED';
        if(winPath) winPath.textContent = '/net';
        if(winCmd) winCmd.textContent = 'tail -f /net/trace.log';

        const player = createLoreWindowPlayer({ term: win, scroll: winScroll, out: winOut, hintEl: winHint, cmdEl: winCmd, metaEl: winMeta });
        lorePlayer = {
          stop: () => {
            try{ player.stop(); }catch{}
            loreArchiveState.isTyping = false;
            loreArchiveState.hackInProgress = false;
            clearLoreTimers();
            if(countdownEl) countdownEl.classList.remove('on');
            clearHackOverlays();
            try{ winClose && (winClose.disabled = false); }catch{}
            try{ document.getElementById('loreDesktop')?.classList?.remove?.('is-hacked'); }catch{}
            try{ closeWindow({ force: true }); }catch{}
          }
        };

        await player.typeLines(archive.hackLines.length ? archive.hackLines : ['[WARNING] link compromised'], { inInjection: true, speed: 'fast' });
        loreArchiveState.isTyping = false;
        win.classList.remove('is-waiting');

        if(countdownEl){
          countdownEl.classList.add('on');
          countdownEl.setAttribute('aria-hidden', 'false');
        }

        // Keep a short visible countdown, then hand off to the real SecuroServ reboot.
        let n = 6;
        const sess = loreArchiveState.session;
        const tick = () => {
          if(sess !== loreArchiveState.session) return;

          const pct = Math.max(0, Math.min(100, Math.round(((6 - Math.max(0, n)) / 6) * 100)));
          try{
            const fill = document.getElementById('securoservMidbarFill');
            if(fill) fill.style.width = pct + '%';
            const pctEl = document.getElementById('securoservMidbarPct');
            if(pctEl) pctEl.textContent = pct + '%';
          }catch{}

          if(countdownEl) countdownEl.textContent = `COUNTDOWN:// ${String(n).padStart(2,'0')}s`;
          n -= 1;
          if(n < 0){
            clearLoreTimers();
            // Use the same shutdown + red reboot sequence as the map countermeasures.
            if(typeof runSecuroservShutdownAndReboot === 'function'){
              Promise.resolve(runSecuroservShutdownAndReboot()).finally(() => {
                // After the red reboot sequence finishes, drop back into Lore safe mode.
                // (Small delay so we don't fight the boot overlay cleanup.)
                loreTimeout(() => {
                  try{ enterSafeMode(); }catch{}
                }, 250);
              });
            }else{
              runPowerOff();
            }
          }
        };
        tick();
        loreInterval(tick, 1000);
      };

      const openFile = async (idx) => {
        if(loreArchiveState.hackInProgress) return;
        if(idx >= loreArchiveState.unlockedCount) return;

        const f = archive.files[idx];
        loreArchiveState.activeIndex = idx;
        loreArchiveState.isTyping = true;
        win.classList.remove('is-waiting');
        try{
          if(nextBtn){
            nextBtn.style.display = '';
            nextBtn.disabled = true;
            nextBtn.setAttribute('aria-hidden', 'true');
            nextBtn.textContent = 'NEXT ENTRY';
          }
        }catch{}

        openWindow();
        if(winTitle) winTitle.textContent = f.name;
        if(winMeta) winMeta.textContent = 'SESSION:// LOCAL • LINK:// STABLE';
        if(winPath) winPath.textContent = '/history';
        if(winCmd) winCmd.textContent = 'cat ' + f.name;
        if(winClose){
          winClose.disabled = true;
          winClose.style.opacity = '0.25';
        }
        if(countdownEl){
          countdownEl.classList.remove('on');
          countdownEl.setAttribute('aria-hidden', 'true');
          countdownEl.textContent = '';
        }

        try{
          if(nextBtn){
            nextBtn.style.display = '';
            nextBtn.disabled = true;
            nextBtn.setAttribute('aria-hidden', 'true');
          }
        }catch{}

        const player = createLoreWindowPlayer({ term: win, scroll: winScroll, out: winOut, hintEl: winHint, cmdEl: winCmd, metaEl: winMeta });
        lorePlayer = {
          stop: () => {
            try{ player.stop(); }catch{}
            loreArchiveState.isTyping = false;
            loreArchiveState.hackInProgress = false;
            clearLoreTimers();
            closeWindow({ force: true });
            clearHackOverlays();
          }
        };

        await player.typeLines(f.lines, { inInjection: false, speed: 'fast' });
        loreArchiveState.isTyping = false;

        const isLast = (idx >= archive.files.length - 1);
        try{
          if(nextBtn){
            nextBtn.textContent = isLast ? 'CONTINUE' : 'NEXT ENTRY';
            nextBtn.disabled = false;
            nextBtn.setAttribute('aria-hidden', 'false');
            nextBtn.focus?.();
          }
        }catch{}
        win.classList.add('is-waiting');

        loreArchiveState.read.add(f.id);

        // Unlock next file (reveal new icon) once typing is done.
        if(!isLast){
          const nextUnlocked = Math.min(archive.files.length, idx + 2);
          const newIndex = (nextUnlocked > loreArchiveState.unlockedCount) ? (nextUnlocked - 1) : null;
          loreArchiveState.unlockedCount = Math.max(loreArchiveState.unlockedCount, nextUnlocked);
          renderDesktop(newIndex);
        }

        if(winClose){
          winClose.disabled = false;
          winClose.style.opacity = '';
        }

        // Window is now "waiting" for the user to click NEXT ENTRY / CONTINUE.
        loreArchiveState.isTyping = false;

        if(isLast){
          // Finale is triggered via the CONTINUE button.
        }
      };

        if(!loreInited){
        if(winClose) winClose.addEventListener('click', () => {
          closeWindow();
        });

        dim.addEventListener('click', () => {
          closeWindow();
        });

        const handleNext = () => {
          if(loreArchiveState.isTyping || loreArchiveState.hackInProgress) return;
          const idx = loreArchiveState.activeIndex;
          if(idx == null) return;

          const isLast = idx >= (archive.files.length - 1);
          const nextIdx = idx + 1;

          // Close current window first (this clears activeIndex).
          try{ closeWindow({ force: true }); }catch{}

          // Last file: proceed to the finale.
          if(isLast){
            loreTimeout(() => { runHackFinale(); }, 240);
            return;
          }

          // Otherwise: open the next unlocked entry immediately.
          if(nextIdx < loreArchiveState.unlockedCount){
            loreTimeout(() => { openFile(nextIdx); }, 60);
          }
        };

        if(nextBtn) nextBtn.addEventListener('click', handleNext);

        window.addEventListener('keydown', (e) => {
          if(loreArchiveState.mode !== 'desktop') return;
          if(!win.classList.contains('on')) return;
          if(!win.classList.contains('is-waiting')) return;
          if(e.key !== 'Enter') return;
          e.preventDefault();
          e.stopPropagation();
          handleNext();
        }, true);

        loreInited = true;
      }

      // Render depending on state.
      desktop.classList.remove('is-safe');

        if(loreArchiveState.mode === 'safe'){
          setVisible(desktop, false);
          setVisible(safe, true);
          renderSafeMode();
          closeWindow({ force: true });
          clearHackOverlays();
          return;
        }

      setVisible(safe, false);
      setVisible(desktop, true);
      renderDesktop();
      closeWindow({ force: true });
      clearHackOverlays();
    }

    // =========================
    // INVENTORY SLOT LAYOUT
    // =========================
    function layoutInventorySlots(){
      const stash = document.getElementById('stashGrid');
      const vehicles = document.getElementById('vehiclesGrid');
      const mainVehicle = document.getElementById('mainVehicleGrid');
      if(!stash || !vehicles || !mainVehicle) return;

      const getNum = (val, fallback) => {
        const n = parseFloat(String(val || '').replace('px',''));
        return Number.isFinite(n) ? n : fallback;
      };

      // Target uniform padding (same pixels on all 4 sides).
      const BOX_PAD = 12;

      // ---- House stash (3 rows, square slots, fill entire box with empties)
      {
        const cs = getComputedStyle(stash);
        const gap = getNum(cs.columnGap || cs.gap, 10);
        const w = stash.clientWidth;
        const rows = 3;
        if(w > 0){
          // Grow square slots while guaranteeing a real, uniform padding.
          const baseSlot = Math.max(20, getNum(cs.getPropertyValue('--slot'), 58));
          const desiredSlot = baseSlot * 1.5;

          const innerW = Math.max(0, w - (BOX_PAD * 2));

          // Compute how many columns fit given the fixed padding.
          let cols = Math.floor((innerW + gap) / (desiredSlot + gap));
          cols = Math.max(1, cols);

          // Slot size is derived from available width after padding.
          const slot = Math.max(20, (innerW - (gap * (cols - 1))) / cols);

          stash.style.padding = BOX_PAD + 'px';
          stash.style.height = ((BOX_PAD * 2) + (rows * slot) + (gap * (rows - 1))) + 'px';

          stash.style.setProperty('--slot', slot.toFixed(3) + 'px');
          stash.style.setProperty('--cols', String(cols));

          const total = rows * cols;
          stash.replaceChildren();

          const makeSlot = (child, empty = false) => {
            const s = document.createElement('div');
            s.className = empty ? 'stashSlot empty' : 'stashSlot';
            if(child) s.appendChild(child);
            return s;
          };

          const money = document.createElement('div');
          money.className = 'invItem money';
          const mb = document.createElement('span');
          mb.className = 'badge';
          mb.textContent = '500';
          money.appendChild(mb);

          const phone = document.createElement('div');
          phone.className = 'invItem phone';
          const pb = document.createElement('span');
          pb.className = 'badge';
          pb.textContent = '1';
          phone.appendChild(pb);

          const occupied = [makeSlot(money, false), makeSlot(phone, false)];
          for(const s of occupied) stash.appendChild(s);
          for(let i = occupied.length; i < total; i++) stash.appendChild(makeSlot(null, true));
        }
      }

      // Determine slot size for vehicles/main vehicle based on stash slot so UI stays consistent
      const slotPx = (() => {
        const v = getComputedStyle(stash).getPropertyValue('--slot');
        return Math.max(20, getNum(v, 58));
      })();

      // Vehicles are intentionally a bit smaller than the house stash.
      const desiredVehSlot = Math.max(18, slotPx * 0.82);

      // ---- Vehicles (wide 3x1, side-by-side)
      {
        const cs = getComputedStyle(vehicles);
        const gap = getNum(cs.columnGap || cs.gap, 10);
        const w = vehicles.clientWidth;
        if(w > 0){
          const innerW = Math.max(0, w - (BOX_PAD * 2));
          const desiredVehW = (desiredVehSlot * 3) + (gap * 2);
          let cols = Math.floor((innerW + gap) / (desiredVehW + gap));
          cols = Math.max(1, cols);

          // Solve for exact vehicle slot height so the wide-slot grid fills inner width.
          let vehSlot = (innerW - (gap * ((3 * cols) - 1))) / (3 * cols);
          while(cols > 1 && vehSlot < 18){
            cols -= 1;
            vehSlot = (innerW - (gap * ((3 * cols) - 1))) / (3 * cols);
          }
          vehSlot = Math.max(18, vehSlot);
          const vehW = (vehSlot * 3) + (gap * 2);

          vehicles.style.setProperty('--slot', vehSlot.toFixed(3) + 'px');
          vehicles.style.setProperty('--vehCols', String(cols));
          vehicles.style.setProperty('--vehW', vehW.toFixed(3) + 'px');

          // Uniform padding + hug to one row.
          vehicles.style.padding = BOX_PAD + 'px';
          vehicles.style.height = ((BOX_PAD * 2) + vehSlot) + 'px';

          vehicles.replaceChildren();
          const makeVSlot = (child, empty = false) => {
            const s = document.createElement('div');
            s.className = empty ? 'vehicleSlot empty' : 'vehicleSlot';
            if(child) s.appendChild(child);
            return s;
          };

          const car = document.createElement('div');
          car.className = 'invItem invVehicle';
          vehicles.appendChild(makeVSlot(car, false));
          for(let i=1;i<cols;i++) vehicles.appendChild(makeVSlot(null, true));
        }
      }

      // ---- Main vehicle (single wide slot, centered)
      {
        const cs = getComputedStyle(mainVehicle);
        const gap = getNum(cs.columnGap || cs.gap, 10);
        // Match the same wide-slot sizing as the vehicles row, but shrink the box width
        // so padding stays truly even around a single centered slot.
        const vcs = getComputedStyle(vehicles);
        const vehSlot = Math.max(18, getNum(vcs.getPropertyValue('--slot'), desiredVehSlot));
        const vehW = (vehSlot * 3) + (gap * 2);
        mainVehicle.style.setProperty('--slot', vehSlot.toFixed(3) + 'px');
        mainVehicle.style.setProperty('--vehCols', '1');
        mainVehicle.style.setProperty('--vehW', vehW.toFixed(3) + 'px');
        mainVehicle.style.padding = BOX_PAD + 'px';
        mainVehicle.style.height = ((BOX_PAD * 2) + vehSlot) + 'px';
        mainVehicle.style.width = (vehW + (BOX_PAD * 2)) + 'px';
        mainVehicle.style.marginLeft = 'auto';
        mainVehicle.style.marginRight = 'auto';
        mainVehicle.replaceChildren();
        const car = document.createElement('div');
        car.className = 'invItem invVehicle';
        const slot = document.createElement('div');
        slot.className = 'vehicleSlot';
        slot.appendChild(car);
        mainVehicle.appendChild(slot);
      }
    }

    // Re-layout inventory slots when the viewport changes.
    window.addEventListener('resize', () => {
      try{ layoutInventorySlots(); }catch{}
    });

