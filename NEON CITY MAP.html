<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GTA V Cyberpunk Map Viewer</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;400;500;600;700&display=swap');

    :root{
      --bg0:#01061b;
      --bg1:#07112a;
      --ui:#608fff;    /* buildings + UI */
      /* Global yellow accent (aligned to Merryweather WARNING:// text) */
      --ylRGB: 255, 238, 152;
      --yl: rgb(var(--ylRGB));
      /* SecuroServ base reds (matches the SecuroServ restricted outline tone) */
      --ss: 207, 0, 0;
      --ssHot: 255, 65, 65;
      /* UI text uses only the two palette colors (via mixing) */
      --text: color-mix(in srgb, var(--ui) 82%, var(--yl) 18%);
      --muted: color-mix(in srgb, var(--ui) 62%, transparent);

      --panel: rgba(6,10,22,.72);
      --line: rgba(96,143,255,.55);
      --line2: rgba(96,143,255,.25);

      --glowB: 0 0 14px rgba(96,143,255,.20), 0 0 32px rgba(96,143,255,.10);
      --glowY: 0 0 10px rgba(var(--ylRGB), .22), 0 0 26px rgba(var(--ylRGB), .10);

      --sw-region: 0.1px;
      --sw-road: 0.15px;
      --sw-building: 0.1px;
      --sw-wall: 0.2px;      /* walls slightly stronger than roads */

      --topbar-h: 48px;
      --term-h: 240px;
    }

    *{ box-sizing:border-box; }
    /* Ensure controls inherit the global UI font (buttons often default otherwise). */
    button, input, textarea, select{ font-family: inherit; font-size: inherit; }
    html, body{ height:100%; margin:0; color:var(--text); overflow:hidden; }
    body{
      font-family: "Rajdhani", ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      background: var(--bg0);
      position: relative;
    }

    /* Top tabs (game-like) */
    .topnav{
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: var(--topbar-h);
      display:grid;
      grid-template-columns: 1fr auto 1fr;
      align-items:flex-end;
      justify-items: center;
      padding: 0 14px;
      text-transform: uppercase;
      letter-spacing: 1.2px;
      font-size: 13px;
      user-select:none;
      z-index: 30;
      /* Dark translucent backdrop so tabs stay readable over bright map areas */
      background: rgba(1,6,27,.70);
    }
    .topnav .topmeta{
      height: 100%;
      width: 100%;
      display:flex;
      align-items:flex-end;
      padding-bottom: 10px;
      gap: 14px;
      justify-content: flex-start;
      opacity: 0;
      pointer-events: none;
    }
    .topnav .topmeta.right{ justify-content: flex-end; }
    body.view-inventory .topnav .topmeta{ opacity: 1; }
    .topnav .metaGroup{ display:flex; align-items:center; gap: 8px; }
    .topnav .metaDot{
      width: 10px;
      height: 10px;
      border-radius: 99px;
      border: 1px solid rgba(215,230,255,.20);
      background: rgba(96,143,255,.30);
      box-shadow: 0 0 14px rgba(96,143,255,.10);
    }
    .topnav .metaDot.red{
      background: rgba(96,143,255,.30);
      box-shadow: 0 0 14px rgba(96,143,255,.10);
    }
    .topnav .metaText{ color: rgba(96,143,255,.92); }
    .topnav .metaText.red{ color: rgba(96,143,255,.92); }
    .topnav .metaStat{ display:flex; align-items:center; gap: 8px; color: rgba(96,143,255,.92); }
    .topnav .metaStat.yl{ color: rgba(var(--ylRGB), .92); }
    .topnav .metaIcon{
      width: 10px;
      height: 10px;
      display:inline-block;
      border-radius: 2px;
      background: rgba(96,143,255,.70);
      box-shadow: 0 0 14px rgba(96,143,255,.10);
    }
    .topnav .metaStat.yl .metaIcon{ background: rgba(var(--ylRGB), .70); box-shadow: 0 0 14px rgba(var(--ylRGB), .10); }
    .topnav .tabs{
      display:flex;
      gap: 24px;
      align-items:flex-end;
      /* Keep underline baseline at the very bottom of the header */
      padding-bottom: 0;
      position: relative;
      z-index: 1;
    }

    /* Left-side district menu (tab-like) */
    .sidemenu{
      position: fixed;
      left: 14px;
      top: calc(var(--topbar-h) + 10px);
      display:flex;
      flex-direction: column;
      align-items:flex-start;
      justify-content:flex-start;
      padding: 10px 12px 0;
      background: rgba(1,6,27,.70);
      border: 1px solid rgba(96,143,255,.18);
      box-shadow: var(--glowB);
      z-index: 35;
      user-select:none;
    }
    /* Small title tab for the filter group (does not change layout height). */
    .sidemenu::before{
      content: "FILTER";
      position: absolute;
      top: 6px;
      left: 50%;
      transform: translateX(-50%);
      height: 20px;
      display: flex;
      align-items: center;
      padding: 0 12px;
      background: rgba(1,6,27,.70);
      border: 1px solid rgba(96,143,255,.18);
      box-shadow: var(--glowB);
      color: rgba(96,143,255,.78);
      font-size: 12px;
      letter-spacing: 1.4px;
      text-transform: uppercase;
      pointer-events: none;
      white-space: nowrap;
    }
    .sidemenu-row{
      display:flex;
      align-items:flex-end;
      justify-content:flex-start;
    }
    .sidemenu .arrow{
      appearance:none;
      background: transparent;
      border: none;
      padding: 0;
      margin: 0;
      color: rgba(96,143,255,.82);
      cursor: default;
      line-height: 1;
      text-transform: uppercase;
      letter-spacing: 1.2px;
      font-size: 44px;
      font-weight: 700;
    }
    .sidemenu .arrow span{
      display:inline-block;
      padding: 0 10px 8px 10px;
      /* Tall, thick, not wide */
      transform: scaleX(.80) scaleY(1.28);
    }
    .sidemenu .tabs{
      display:flex;
      gap: 24px;
      align-items:flex-end;
      padding-bottom: 0;
      position: relative;
    }

    /* Layer toggles under the district filter tabs */
    .layerToggles{
      position: fixed;
      left: 14px;
      top: calc(var(--topbar-h) + 10px + 72px);
      z-index: 34;
      display:flex;
      flex-direction: column;
      gap: 8px;
      padding: 10px 0 0;
      background: transparent;
      border: none;
      box-shadow: none;
    }
    .layerToggle{
      appearance:none;
      background: transparent;
      border: none;
      padding: 0;
      margin: 0;
      display:flex;
      align-items:center;
      gap: 10px;
      color: rgba(96,143,255,.78);
      cursor: pointer;
      line-height: 1;
      text-transform: uppercase;
      letter-spacing: 1.2px;
      font-size: 12px;
    }
    .layerToggle:hover{ color: rgba(96,143,255,.98); }
    .layerToggle-icon{
      width: 30px;
      height: 14px;
      position: relative;
      flex: 0 0 auto;
    }
    .layerToggle-icon::before{
      content:"";
      position:absolute;
      inset: 2px 0;
      background: rgba(96,143,255,.22);
      box-shadow: 0 0 14px rgba(96,143,255,.12);
    }
    .layerToggle-icon::after{
      content:"";
      position:absolute;
      top: 1px;
      left: 1px;
      width: 12px;
      height: 12px;
      background: rgba(96,143,255,.75);
      box-shadow: 0 0 12px rgba(96,143,255,.18);
      transition: transform .14s ease, background .14s ease;
    }
    .layerToggle.on{ color: var(--yl); }
    .layerToggle.on .layerToggle-icon::before{ background: rgba(var(--ylRGB), .22); box-shadow: 0 0 14px rgba(var(--ylRGB), .10); }
    .layerToggle.on .layerToggle-icon::after{ transform: translate3d(16px,0,0); background: rgba(var(--ylRGB), .92); box-shadow: 0 0 14px rgba(var(--ylRGB), .16); }

    /* In SecuroServ mode, toggles inherit the red theme */
    body.securosserv-mode .layerToggle{ color: rgba(var(--ssHot), .78); }
    body.securosserv-mode .layerToggle:hover{ color: rgba(var(--ssHot), .98); }
    body.securosserv-mode .layerToggle-icon::before{ background: rgba(var(--ssHot), .14); box-shadow: 0 0 14px rgba(var(--ssHot), .10); }
    body.securosserv-mode .layerToggle-icon::after{ background: rgba(var(--ssHot), .70); box-shadow: 0 0 14px rgba(var(--ssHot), .12); }
    body.securosserv-mode .layerToggle.on{ color: rgba(var(--ssHot), .95); }

    /* Actual visibility control */
    #layerBuildings,
    #layerRoads,
    #markersLayer{
      transition: opacity .16s ease;
    }
    #layerBuildings{ opacity: .75; }
    #layerRoads{ opacity: .50; }
    body.hide-buildings #layerBuildings{ opacity: 0; }
    body.hide-roads #layerRoads{ opacity: 0; }
    body.hide-markers #markersLayer{ opacity: 0; }
    .sidemenu .tab{
      appearance:none;
      background: transparent;
      border: none;
      padding: 0;
      color: rgba(96,143,255,.82);
      cursor: default;
      line-height: 1;
      text-transform: uppercase;
      letter-spacing: 1.2px;
      font-size: 13px;
      position: relative;
      z-index: 1;
    }
    .sidemenu .tab.on{ color: var(--yl); font-weight: 700; z-index: 3; }
    .sidemenu .tab span{
      display:inline-block;
      padding: 0 0 8px 0;
      border-bottom: 2px solid rgba(96,143,255,.28);
    }
    .sidemenu .tab.on span{
      border-bottom: 2px solid rgba(var(--ylRGB), .85);
      filter:
        drop-shadow(0 0 10px rgba(var(--ylRGB), .16))
        drop-shadow(0 0 18px rgba(var(--ylRGB), .10));
    }

    /* Interactivity: blue glow on hover; yellow only when selected */
    .sidemenu .tab:hover:not(.on),
    .sidemenu .arrow:hover{
      color: rgba(96,143,255,.98);
    }
    .sidemenu .tab:hover:not(.on) span,
    .sidemenu .arrow:hover span{
      filter:
        drop-shadow(0 0 10px rgba(96,143,255,.22))
        drop-shadow(0 0 18px rgba(96,143,255,.12));
    }
    .sidemenu .tab:hover:not(.on) span{
      border-bottom-color: rgba(96,143,255,.65);
    }

    /* Bottom-right pan readout */
    .cornerReadout{
      position: fixed;
      right: 14px;
      bottom: 14px;
      z-index: 24;
      pointer-events:none;
      display:flex;
      flex-direction:column;
      gap: 10px;
      align-items:flex-end;
    }

    .securserve-badge{
      position: fixed;
      top: calc(var(--topbar-h) + 14px);
      right: 14px;
      width: 76px;
      height: 76px;
      border-radius: 50%;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none;
      z-index: 18;
    }
    .securserve-badge img{
      width: 70px;
      height: 70px;
      object-fit: contain;
      animation: securserveSpin 16s linear infinite;
    }
    @keyframes securserveSpin{
      from{ transform: rotate(0deg); }
      to{ transform: rotate(360deg); }
    }
    /* Side underline segments: start at the sides with a gap = tab spacing */
    .topnav .tabs::before,
    .topnav .tabs::after{
      content:"";
      position:absolute;
      bottom: 0;
      border-bottom: 2px solid rgba(96,143,255,.18); /* slightly dimmer than inactive tab underline */
      pointer-events:none;
    }
    .topnav .tabs::before{
      left: -100vw;
      right: calc(100% + 24px);
    }
    .topnav .tabs::after{
      left: calc(100% + 24px);
      right: -100vw;
    }
    .topnav .tab{
      appearance:none;
      background: transparent;
      border: none;
      padding: 0;
      color: rgba(96,143,255,.82);
      cursor: pointer;
      line-height: 1;
    }
    .topnav .tab:hover{ color: var(--yl); }
    .topnav .tab.on{ color: var(--yl); }

    /* Disabled tabs (placeholders until pages exist)
       - Hover should still work
       - Clicks are blocked in JS (see DISABLED_VIEWS)
    */
    .topnav .tab.disabled{
      opacity: .65;
      cursor: pointer;
      filter: none;
    }
    .topnav .tab.disabled span{
      border-bottom-color: rgba(96,143,255,.18);
      filter: none !important;
    }
    .topnav .tab.disabled:hover{
      color: rgba(var(--ssHot), .95);
    }
    .topnav .tab.disabled:hover span{
      border-bottom-color: rgba(var(--ssHot), .75);
    }

    /* If Lore Terminal is disabled, don't run the glitch animation */
    .topnav .tab.tab-lore.disabled span{
      animation: none !important;
      text-shadow: none;
    }
    .topnav .tab.tab-lore.disabled span::before,
    .topnav .tab.tab-lore.disabled span::after{
      display: none;
    }
    .topnav .tab span{
      display:inline-block;
      padding: 0 0 8px 0;
      border-bottom: 2px solid rgba(96,143,255,.28);
    }
    .topnav .tab:hover span{
      border-bottom-color: rgba(var(--ylRGB), .65);
    }
    .topnav .tab.on span{
      border-bottom: 2px solid rgba(var(--ylRGB), .85);
    }
    .topnav .tab.on{ font-weight: 700; }

    /* Slightly glitchy (inviting) LORE TERMINAL tab */
    .topnav .tab.tab-lore span{
      position: relative;
      text-shadow:
        0 0 16px rgba(var(--ylRGB), .22),
        0 0 28px rgba(var(--ylRGB), .12);
      animation: loreTabGlitch .72s steps(2, end) infinite;
    }
    .topnav .tab.tab-lore span::after{
      content: "LORE TERMINAL";
      position: absolute;
      inset: 0;
      opacity: .22;
      color: rgba(var(--ylRGB), .92);
      mix-blend-mode: screen;
      text-shadow:
        2px 0 0 rgba(255,0,0,.22),
        -2px 0 0 rgba(0,220,255,.18);
      transform: translate3d(0,0,0);
      pointer-events: none;
      animation: loreTabGlitchGhost .72s steps(2, end) infinite;
    }
    .topnav .tab.tab-lore span::before{
      content: "LORE TERMINAL";
      position: absolute;
      inset: 0;
      opacity: .10;
      color: rgba(96,143,255,.95);
      mix-blend-mode: screen;
      transform: translate3d(0,0,0);
      filter: blur(.3px);
      pointer-events: none;
      animation: loreTabGlitchGhost2 .72s steps(2, end) infinite;
    }
    @keyframes loreTabGlitch{
      /* IMPORTANT: no transform/letter-spacing here, so the tab doesn't shift layout */
      0%{ filter:none; }
      20%{ filter: contrast(1.18) saturate(1.08) brightness(1.02); }
      40%{ filter: contrast(1.06); }
      60%{ filter: contrast(1.22) saturate(1.10) brightness(1.03); }
      80%{ filter: contrast(1.10); }
      100%{ filter:none; }
    }
    @keyframes loreTabGlitchGhost{
      0%{ opacity: .18; transform: translate3d(0,0,0); clip-path: inset(0 0 0 0); }
      25%{ opacity: .44; transform: translate3d(2px,0,0); clip-path: inset(0 0 58% 0); }
      50%{ opacity: .22; transform: translate3d(-2px,0,0); clip-path: inset(42% 0 0 0); }
      75%{ opacity: .38; transform: translate3d(1px,0,0); clip-path: inset(14% 0 36% 0); }
      100%{ opacity: .18; transform: translate3d(0,0,0); clip-path: inset(0 0 0 0); }
    }
    @keyframes loreTabGlitchGhost2{
      0%{ opacity: .08; transform: translate3d(-1px,0,0); clip-path: inset(8% 0 48% 0); }
      33%{ opacity: .14; transform: translate3d(1px,0,0); clip-path: inset(0 0 62% 0); }
      66%{ opacity: .10; transform: translate3d(-2px,0,0); clip-path: inset(52% 0 0 0); }
      100%{ opacity: .08; transform: translate3d(0,0,0); clip-path: inset(8% 0 48% 0); }
    }

    /* Layout */
    .stage{
      position: fixed;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      padding: 0;
    }

    /* View switching (Top Tabs) */
    .mapstage,
    #inventoryStage,
    #loreStage{
      transition: opacity .22s ease, filter .28s ease;
      will-change: opacity, filter;
    }
    /* Default: map visible, inventory hidden (but kept mounted for smoother switching) */
    #inventoryStage{
      opacity: 0;
      pointer-events: none;
      filter: blur(8px);
    }
    #loreStage{
      opacity: 0;
      pointer-events: none;
      filter: blur(8px);
    }
    body.view-inventory .mapstage{
      opacity: 0;
      pointer-events: none;
      filter: blur(8px);
    }
    body.view-inventory #inventoryStage{
      opacity: 1;
      pointer-events: auto;
      filter: blur(0px);
    }

    body.view-lore .mapstage{
      opacity: 0;
      pointer-events: none;
      filter: blur(8px);
    }
    body.view-lore #loreStage{
      opacity: 1;
      pointer-events: auto;
      filter: blur(0px);
    }
    body.view-inventory .sidemenu,
    body.view-inventory .layerToggles,
    body.view-inventory #popupDetails,
    body.view-inventory #hackPrompt,
    body.view-inventory #cmdFeed,
    body.view-inventory #restrictedOverlay,
    body.view-inventory #securoservWall,
    body.view-inventory #securoservChaos,
    body.view-inventory #securoservMidbar,
    body.view-inventory #securoservChallenge,
    body.view-inventory #counterhackFx,
    body.view-inventory #screenGlitch,
    body.view-inventory #screenOff,
    body.view-inventory #inputBlocker{
      display:none !important;
    }

    body.view-lore .sidemenu,
    body.view-lore .layerToggles,
    body.view-lore #popupDetails,
    body.view-lore #hackPrompt,
    body.view-lore #cmdFeed,
    body.view-lore #restrictedOverlay,
    body.view-lore #securoservWall,
    body.view-lore #securoservChaos,
    body.view-lore #securoservMidbar,
    body.view-lore #securoservChallenge,
    body.view-lore #counterhackFx,
    body.view-lore #screenGlitch,
    body.view-lore #screenOff,
    body.view-lore #inputBlocker{
      display:none !important;
    }

    body.view-inventory .topnav .tabs::before,
    body.view-inventory .topnav .tabs::after{
      border-bottom-color: rgba(96,143,255,.40);
    }
    /* In inventory view, keep inactive tabs blue, but let the active one stay yellow */
    body.view-inventory .topnav .tab:not(.on) span{ border-bottom-color: rgba(96,143,255,.28); }
    body.view-inventory .topnav .tab.on span{ border-bottom-color: rgba(var(--ylRGB), .85); }
    body.view-inventory .topnav{ background: rgba(1,6,27,.70); box-shadow: 0 0 30px rgba(96,143,255,.12) inset; }

    /* Inventory page (static UI, match reference layout) */
    .inventorystage{
      position: absolute;
      left: 0;
      right: 0;
      top: var(--topbar-h);
      bottom: 0;
      overflow: hidden;
      background:
        radial-gradient(900px 520px at 26% 0%, rgba(96,143,255,.18), rgba(0,0,0,0) 62%),
        radial-gradient(820px 520px at 70% 0%, rgba(96,143,255,.10), rgba(0,0,0,0) 60%),
        linear-gradient(180deg, rgba(10,6,16,.80) 0%, rgba(1,6,27,.62) 42%, rgba(0,0,0,.92) 100%);
    }

    /* Lore Terminal */
    .lorestage{
      position: absolute;
      left: 0;
      right: 0;
      top: var(--topbar-h);
      bottom: 0;
      overflow: hidden;
      background:
        radial-gradient(900px 520px at 26% 0%, rgba(96,143,255,.18), rgba(0,0,0,0) 62%),
        radial-gradient(820px 520px at 70% 0%, rgba(96,143,255,.10), rgba(0,0,0,0) 60%),
        linear-gradient(180deg, rgba(10,6,16,.82) 0%, rgba(1,6,27,.66) 42%, rgba(0,0,0,.92) 100%);
    }
    .loreInner{
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      width: min(980px, calc(100vw - 28px));
      top: 12px;
      bottom: 14px;
      border: 1px solid rgba(var(--ylRGB), .18);
      background: rgba(0,0,0,.86);
      box-shadow:
        0 0 0 1px rgba(0,0,0,.72) inset,
        0 0 34px rgba(var(--ylRGB), .06);
      overflow: hidden;
      display: grid;
      grid-template-rows: auto 1fr;
    }
    .loreHead{
      padding: 12px 14px 10px;
      border-bottom: 1px solid rgba(var(--ylRGB), .12);
      background: rgba(0,0,0,.55);
    }
    .loreTitle{
      font-weight: 500;
      letter-spacing: 2px;
      color: rgba(var(--ylRGB), .92);
      text-transform: uppercase;
      font-size: 13px;
    }
    .loreSub{
      margin-top: 2px;
      font-size: 11px;
      letter-spacing: 1.2px;
      color: rgba(var(--ylRGB), .62);
      text-transform: uppercase;
    }
    .loreScroll{
      overflow: auto;
      padding: 12px 14px 40px;
      scrollbar-color: rgba(96,143,255,.35) rgba(0,0,0,.35);
    }
    .loreCode{
      margin: 0;
      white-space: pre-wrap;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12.5px;
      line-height: 1.28;
      letter-spacing: .15px;
      font-weight: 400;
      color: rgba(var(--ylRGB), .76);
      text-shadow: 0 0 16px rgba(var(--ylRGB), .06);
    }
    .loreScroll{
      position: relative;
    }
    .loreScroll::before{
      content:"";
      position:absolute;
      inset: 0;
      background:
        repeating-linear-gradient(0deg, rgba(var(--ylRGB), .06) 0px, rgba(var(--ylRGB), .06) 1px, rgba(0,0,0,0) 1px, rgba(0,0,0,0) 26px),
        radial-gradient(900px 520px at 16% 0%, rgba(var(--ylRGB), .08), rgba(0,0,0,0) 62%);
      opacity: .26;
      pointer-events: none;
    }
    .loreCode{ position: relative; }

    /* Lore terminal tokens (use the text's own formatting as cues) */
    .loreCode .tok-h1{ color: rgba(var(--ylRGB), .92); font-weight: 600; }
    .loreCode .tok-meta{ color: rgba(var(--ylRGB), .82); }
    .loreCode .tok-sec{ color: rgba(96,143,255,.82); }
    .loreCode .tok-tag{ color: rgba(var(--ylRGB), .92); font-weight: 600; }
    .loreCode .tok-warn{ color: rgba(var(--ylRGB), .94); text-shadow: 0 0 18px rgba(var(--ylRGB), .12); }
    .loreCode .tok-note{ color: rgba(96,143,255,.78); }
    .loreCode .tok-comment{ color: rgba(var(--ylRGB), .52); }
    .loreCode .tok-sep{ color: rgba(96,143,255,.40); }
    .loreCode .tok-glitch{ color: rgba(var(--ylRGB), .78); filter: contrast(1.12) saturate(1.08); }

    /* Quick transition overlay (used when switching INVENTORY -> MAP) */
    .quickload{
      position: fixed;
      inset: 0;
      z-index: 120;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      background: rgba(1,6,27,.35);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      opacity: 0;
      transition: opacity .14s ease;
    }
    .quickload.on{
      opacity: 1;
    }
    .quickload .inner{
      width: min(360px, calc(100vw - 48px));
      border: 1px solid rgba(96,143,255,.22);
      background: rgba(0,0,0,.48);
      box-shadow: 0 0 22px rgba(96,143,255,.10);
      padding: 12px;
    }
    .quickload .label{
      font-size: 11px;
      letter-spacing: 2px;
      text-transform: uppercase;
      color: rgba(96,143,255,.92);
      margin-bottom: 10px;
    }
    .quickload .bar{
      height: 6px;
      border: 1px solid rgba(96,143,255,.24);
      background: rgba(0,0,0,.28);
      overflow: hidden;
    }
    .quickload .fill{
      height: 100%;
      width: 0%;
      background: rgba(var(--ylRGB), .92);
      box-shadow: 0 0 18px rgba(var(--ylRGB), .18);
      transition: width .22s ease;
    }
    .invInner{
      height: 100%;
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: 44px;
      padding: 58px 62px 34px;
    }
    .invH{
      color: rgba(96,143,255,.88);
      font-size: 12px;
      letter-spacing: 1.5px;
      text-transform: uppercase;
      font-weight: 800;
      margin-bottom: 12px;
    }
    .invBlock{ margin-bottom: 52px; }
    .invCard{
      border: 1px solid rgba(96,143,255,.26);
      background:
        linear-gradient(180deg, rgba(10,6,16,.74), rgba(0,0,0,.68)),
        repeating-linear-gradient(90deg, rgba(96,143,255,.06) 0px, rgba(96,143,255,.06) 1px, rgba(0,0,0,0) 1px, rgba(0,0,0,0) 10px);
      box-shadow: 0 0 34px rgba(96,143,255,.08);
      position: relative;
      overflow: hidden;
    }
    .invCard::after{
      content:"";
      position:absolute;
      inset: 0;
      background:
        radial-gradient(60px 36px at 22px 18px, rgba(96,143,255,.18), rgba(0,0,0,0) 62%),
        radial-gradient(90px 70px at 88% 78%, rgba(96,143,255,.10), rgba(0,0,0,0) 70%);
      opacity: .75;
      pointer-events:none;
    }
    .invStack{ display:flex; flex-direction:column; gap: 14px; }
    .invCard.tall{ height: 78px; }
    .invRow{ display:flex; gap: 14px; }
    .invCard.small{ width: 78px; height: 56px; }

    .invRightTop{ display:flex; align-items:flex-start; justify-content: space-between; margin-bottom: 12px; }
    .invSortBtns{ display:flex; gap: 10px; margin-top: 8px; }
    .invSortBtn{
      width: 30px;
      height: 22px;
      border: 1px solid rgba(96,143,255,.26);
      background: rgba(0,0,0,.40);
      color: rgba(96,143,255,.85);
      font-family: inherit;
      font-size: 12px;
      letter-spacing: 1px;
      text-transform: uppercase;
      padding: 0;
    }
    .invSortBtn:hover{ color: rgba(var(--ylRGB), .95); border-color: rgba(var(--ylRGB), .35); }

    .invAmountBox{
      display:flex;
      align-items:center;
      gap: 10px;
      height: 22px;
      padding: 0 8px;
      border: 1px solid rgba(96,143,255,.26);
      background: rgba(0,0,0,.40);
    }
    .invAmountBtn{
      width: 16px;
      height: 16px;
      border: none;
      background: transparent;
      color: rgba(96,143,255,.85);
      padding: 0;
      cursor: pointer;
      line-height: 1;
    }
    .invAmountBtn:hover{ color: rgba(var(--ylRGB), .95); }
    .invAmountVal{ min-width: 36px; text-align:center; color: rgba(96,143,255,.75); font-size: 12px; }
    .invAmountDots{ width: 14px; height: 14px; border-radius: 99px; border: 1px solid rgba(96,143,255,.22); opacity: .55; }

    .invGridBlock{ margin-top: 12px; }
    .invGrid{
      height: 220px;
      border: 1px solid rgba(96,143,255,.16);
      background:
        radial-gradient(540px 220px at 0% 0%, rgba(96,143,255,.08), rgba(0,0,0,0) 62%),
        repeating-linear-gradient(0deg, rgba(96,143,255,.08) 0px, rgba(96,143,255,.08) 1px, rgba(0,0,0,0) 1px, rgba(0,0,0,0) 40px),
        repeating-linear-gradient(90deg, rgba(96,143,255,.06) 0px, rgba(96,143,255,.06) 1px, rgba(0,0,0,0) 1px, rgba(0,0,0,0) 40px),
        rgba(0,0,0,.46);
      box-shadow: 0 0 34px rgba(96,143,255,.06);
      position: relative;
      overflow: hidden;
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      grid-template-rows: repeat(3, 1fr);
    }

     /* House Stash: game-like slots (empty or occupied)
       3 fixed rows; JS sets --slot and --cols so the box is fully filled with empty slots. */
     .stashGrid{
      --stashH: 220px;
      --stashPad: 12px;
      --stashGap: 10px;
      --slot: 58px;
      --cols: 6;

      height: var(--stashH);
      border: 1px solid rgba(96,143,255,.16);
      background:
        radial-gradient(540px 220px at 0% 0%, rgba(96,143,255,.08), rgba(0,0,0,0) 62%),
        repeating-linear-gradient(0deg, rgba(96,143,255,.08) 0px, rgba(96,143,255,.08) 1px, rgba(0,0,0,0) 1px, rgba(0,0,0,0) 40px),
        repeating-linear-gradient(90deg, rgba(96,143,255,.06) 0px, rgba(96,143,255,.06) 1px, rgba(0,0,0,0) 1px, rgba(0,0,0,0) 40px),
        rgba(0,0,0,.46);
      box-shadow: 0 0 34px rgba(96,143,255,.06);
      position: relative;
      overflow: hidden;

      display: grid;
      grid-template-rows: repeat(3, var(--slot));
      grid-template-columns: repeat(var(--cols), var(--slot));
      row-gap: var(--stashGap);
      column-gap: var(--stashGap);
      padding: var(--stashPad);
      justify-content: center;
      align-content: start;
    }
    .stashGrid::after{
      content:"";
      position:absolute;
      inset: 0;
      background:
        radial-gradient(1px 1px at 14px 18px, rgba(96,143,255,.32), rgba(0,0,0,0) 2px),
        radial-gradient(1px 1px at 70px 52px, rgba(96,143,255,.22), rgba(0,0,0,0) 2px),
        radial-gradient(1px 1px at 120px 98px, rgba(96,143,255,.22), rgba(0,0,0,0) 2px),
        radial-gradient(1px 1px at 310px 60px, rgba(96,143,255,.18), rgba(0,0,0,0) 2px);
      opacity: .65;
      pointer-events:none;
    }

    .stashSlot{
      position: relative;
      width: var(--slot);
      height: var(--slot);
      aspect-ratio: 1 / 1;
      border: 1px solid rgba(96,143,255,.22);
      background:
        linear-gradient(180deg, rgba(0,0,0,.46), rgba(0,0,0,.26)),
        repeating-linear-gradient(90deg, rgba(96,143,255,.06) 0px, rgba(96,143,255,.06) 1px, rgba(0,0,0,0) 1px, rgba(0,0,0,0) 10px);
      box-shadow:
        0 0 18px rgba(96,143,255,.06),
        0 0 0 1px rgba(0,0,0,.55) inset;
      overflow: hidden;
      display:flex;
      align-items: center;
      justify-content: center;
      z-index: 1;
    }
    .stashSlot.empty{
      opacity: .65;
    }
    .stashSlot.empty::after{
      content:"";
      position:absolute;
      inset: 0;
      background:
        linear-gradient(135deg, transparent 0 44%, rgba(96,143,255,.12) 44% 46%, transparent 46% 100%);
      opacity: .35;
      pointer-events:none;
    }

    .stashSlot .invItem{
      position: static;
      width: 100%;
      height: 100%;
      border: none;
      background: transparent;
      box-shadow: none;
      padding: 8px;
    }

    /* Vehicles: wide slots (3x1) laid out side-by-side; JS sets --slot and --vehCols */
    .vehicleGrid{
      --vehH: 180px;
      --slot: 58px;
      --vehCols: 3;
      --vehW: calc((var(--slot) * 3) + (var(--stashGap, 10px) * 2));

      height: var(--vehH);
      border: 1px solid rgba(96,143,255,.16);
      background:
        radial-gradient(540px 220px at 0% 0%, rgba(96,143,255,.08), rgba(0,0,0,0) 62%),
        repeating-linear-gradient(0deg, rgba(96,143,255,.08) 0px, rgba(96,143,255,.08) 1px, rgba(0,0,0,0) 1px, rgba(0,0,0,0) 40px),
        repeating-linear-gradient(90deg, rgba(96,143,255,.06) 0px, rgba(96,143,255,.06) 1px, rgba(0,0,0,0) 1px, rgba(0,0,0,0) 40px),
        rgba(0,0,0,.46);
      box-shadow: 0 0 34px rgba(96,143,255,.06);
      position: relative;
      overflow: hidden;

      display: grid;
      grid-template-rows: var(--slot);
      grid-template-columns: repeat(var(--vehCols), var(--vehW));
      row-gap: 10px;
      column-gap: 10px;
      padding: 12px;
      justify-content: center;
      align-content: start;
    }

    .vehicleSlot{
      position: relative;
      height: var(--slot);
      width: var(--vehW);
      border: 1px solid rgba(96,143,255,.22);
      background:
        linear-gradient(180deg, rgba(0,0,0,.46), rgba(0,0,0,.26)),
        repeating-linear-gradient(90deg, rgba(96,143,255,.06) 0px, rgba(96,143,255,.06) 1px, rgba(0,0,0,0) 1px, rgba(0,0,0,0) 10px);
      box-shadow:
        0 0 18px rgba(96,143,255,.06),
        0 0 0 1px rgba(0,0,0,.55) inset;
      overflow: hidden;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .vehicleSlot.empty{ opacity: .65; }
    .vehicleSlot.empty::after{
      content:"";
      position:absolute;
      inset: 0;
      background: linear-gradient(135deg, transparent 0 44%, rgba(96,143,255,.12) 44% 46%, transparent 46% 100%);
      opacity: .35;
      pointer-events:none;
    }

    .vehicleSlot .invItem{
      position: static;
      width: 100%;
      height: 100%;
      border: none;
      background: transparent;
      box-shadow: none;
      padding: 10px;
    }

    /* Main vehicle: same slot treatment, single slot centered */
    .vehicleGrid.mainVehicle{
      height: calc(var(--slot) + 24px);
      grid-template-columns: var(--vehW);
      justify-content: center;
    }
    .invGrid::after{
      content:"";
      position:absolute;
      inset: 0;
      background:
        radial-gradient(1px 1px at 14px 18px, rgba(96,143,255,.32), rgba(0,0,0,0) 2px),
        radial-gradient(1px 1px at 70px 52px, rgba(96,143,255,.22), rgba(0,0,0,0) 2px),
        radial-gradient(1px 1px at 120px 98px, rgba(96,143,255,.22), rgba(0,0,0,0) 2px),
        radial-gradient(1px 1px at 310px 60px, rgba(96,143,255,.18), rgba(0,0,0,0) 2px);
      opacity: .75;
      pointer-events:none;
    }
    .invItem{
      position: absolute;
      width: 72px;
      height: 72px;
      border: 1px solid rgba(96,143,255,.26);
      background: rgba(0,0,0,.55);
      box-shadow: 0 0 18px rgba(96,143,255,.10);
      display:flex;
      align-items:flex-end;
      justify-content:flex-start;
      padding: 6px;
      color: rgba(var(--ylRGB), .92);
      font-size: 12px;
      letter-spacing: 1px;
    }

    /* Inventory uses grid slots; items should flow leftâ†’right (not absolute). */
    .inventorystage .invGrid .invItem{
      position: relative;
      left: auto;
      top: auto;
      transform: none;
      justify-self: start;
      align-self: start;
    }

    .inventorystage .invGridVehicles{
      height: 110px;
      grid-template-rows: 1fr;
    }

    .inventorystage .invGridVehicles .invVehicle{
      width: 148px;
      height: 78px;
    }
    .invItem.money{ border-color: rgba(70,255,180,.0); }
    .invItem .badge{
      position:absolute;
      left: 6px;
      bottom: 6px;
      font-weight: 700;
      color: rgba(var(--ylRGB), .92);
    }
    .invItem.money{ outline: 2px solid rgba(80,255,180,.0); }
    .invItem.money::before{
      content:"";
      position:absolute;
      inset: 0;
      border-left: 4px solid rgba(120,255,190,.0);
    }
    .invItem.phone{ border-color: rgba(96,143,255,.22); }
    .invGround{ margin-top: 34px; }
    .hudcol{ display:flex; flex-direction:column; gap: 14px; min-width:0; }

    /* Old HUD filter buttons are deprecated (replaced by left-side menu) */
    #hudFilters{ display:none !important; }

    .termDock{ display:none !important; }

     /* Prevent accidental text highlighting/selection while dragging/panning.
       Keep Area Details selectable (copy/paste). */
    body,
    .stage,
    .mapstage,
    .mapwrap,
    #mapStack,
    #svgHost,
    #logosLayer,
    #markersLayer,
    #labelsLayer,
    .topnav,
    .sidemenu,
    .layerToggles{
      user-select: none;
      -webkit-user-select: none;
    }
    #popupDetails,
    #popupDetails *{
      user-select: text;
      -webkit-user-select: text;
    }

    /* Panels */
    .hudpanel, .hudpopup, .dockpanel{
      background:
        radial-gradient(120% 120% at 30% 18%, rgba(96,143,255,.08), transparent 55%),
        linear-gradient(180deg, rgba(6,10,22,.86), rgba(2,6,18,.74));
      border: 1px solid rgba(96,143,255,.38);
      box-shadow:
        0 0 0 1px rgba(0,0,0,.55) inset,
        0 0 22px rgba(96,143,255,.10);
      position: relative;
    }
    .hudpanel::before, .hudpopup::before, .dockpanel::before{
      content:"";
      position:absolute; inset:-1px;
      border: 1px solid rgba(96,143,255,.16);
      pointer-events:none;
    }
    .hudpanel::after, .hudpopup::after, .dockpanel::after{
      content:"";
      position:absolute;
      left:-1px; top:-1px;
      width: 18px; height: 18px;
      border-left: 2px solid var(--yl);
      border-top: 2px solid var(--yl);
      opacity:.55;
      pointer-events:none;
    }

    /* =========================
       CUT-CORNER PANELS (ONLY)
       ========================= */
    #popupDetails{
      --cut: 16px;
      --pdStroke: 96, 143, 255;
      /* Let the base .hudpopup rules control size/position; ensure popup receives events and is on top */
      pointer-events: auto;
      z-index: 8;
      /* Remove the default square panel paint (the SVG provides the real cut-corner shape). */
      background: transparent;
      border: 0;
      box-shadow: none;

      /* Clip all panel contents (header/body/footer) to the cut-corner shape. */
      -webkit-clip-path: polygon(
        var(--cut) 0,
        calc(100% - var(--cut)) 0,
        100% var(--cut),
        100% calc(100% - var(--cut)),
        calc(100% - var(--cut)) 100%,
        0 100%,
        0 var(--cut)
      );
      clip-path: polygon(
        var(--cut) 0,
        calc(100% - var(--cut)) 0,
        100% var(--cut),
        100% calc(100% - var(--cut)),
        calc(100% - var(--cut)) 100%,
        0 100%,
        0 var(--cut)
      );

      /* Auto-size height to content; still cap to viewport and allow scroll when needed. */
      bottom: auto;
      height: auto;
      max-height: calc(
        100vh
        - var(--detailsTop, calc(var(--topbar-h) + 10px + 170px))
        - (14px + var(--dockH, 0px) + 14px)
      );
    }

    /* The polygon frame SVG is decorative; it should behave like a background layer,
       not a separate (empty) box that pushes the content down. */
    #popupDetails .pdSvg{
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      pointer-events: none;
      z-index: 1;
    }
    #popupDetails .pdOutline{
      fill: none;
      stroke: rgba(var(--pdStroke), .92);
      stroke-width: 3;
      filter: drop-shadow(0 0 10px rgba(var(--pdStroke), .12));
    }
    #popupDetails .pdFill{ fill: rgba(6,10,22,.88); }
    #popupDetails .pdScan{ fill: rgba(255,255,255,.22); }
    #popupDetails .pdLines{ fill: url(#pdScanlines); opacity: .07; }

    #popupDetails::before{
      display:none;
    }

    /* Disable the global corner mark on this one */
    #popupDetails::after{ display:none; }

    /* Keep restricted state from reintroducing an extra boxed overlay layer. */
    #popupDetails.restricted::before,
    #popupDetails.restricted::after{
      display: none !important;
    }

    #popupDetails > .hudhead,
    #popupDetails > .hudbody,
    #popupDetails > .hudfoot{
      position: relative;
      z-index: 2;
    }

    /* Small side tab protrusion */
    #popupDetails .hudhead{
      position: relative;
    }
    #popupDetails .hudhead::before{
      content:"";
      position:absolute;
      left: -14px;
      top: 10px;
      width: 18px;
      height: 22px;
      background: rgba(6,10,22,.55);
      border: 1px solid var(--line2);
      border-right: none;
      clip-path: polygon(0 0, 100% 6px, 100% 100%, 0 100%);
      pointer-events:none;
    }

    /* Little top tab */
    #popupDetails .hudhead::after{
      content:"";
      position:absolute;
      left: 22px;
      top: -10px;
      width: 76px;
      height: 12px;
      background: rgba(6,10,22,.55);
      border: 1px solid var(--line2);
      border-bottom: none;
      clip-path: polygon(0 100%, 12px 0, 100% 0, 100% 100%);
      pointer-events:none;
    }

    /* Headers/Footers */
    .hudhead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(96,143,255,.32);
      background:
        linear-gradient(90deg, rgba(96,143,255,.28), rgba(6,10,22,.55) 58%);
      text-transform: uppercase;
      letter-spacing: 1.2px;
      font-size: 12px;
    }
    .hudtitle{ color: rgba(96,143,255,.96); text-shadow: 0 0 10px rgba(96,143,255,.12); }
    .hudmeta{ color: var(--yl); text-shadow: 0 0 10px rgba(var(--ylRGB), .10); }
    .hudbody{ padding: 12px; }
    .hudfoot{
      display:flex; justify-content:space-between;
      padding: 8px 12px;
      border-top: 1px solid rgba(96,143,255,.22);
      color: rgba(215,230,255,.52);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    /* MAP/INTEL footer content */
    #popupDetails .hudfoot{
      flex-direction: column;
      justify-content: flex-start;
      align-items: flex-start;
      gap: 6px;
      /* Match bottom padding thickness to side padding */
      padding: 12px;
    }
    #popupDetails .hudfoot > :first-child{
      padding-top: 0;
      color: rgba(96,143,255,.95);
      font-weight: 800;
      letter-spacing: 2px;
    }

    /* When the details panel is restricted-themed, MAP/INTEL should follow that palette */
    #popupDetails.restricted .hudfoot > :first-child{
      color: rgba(var(--restrictedTextRGB), .95);
      text-shadow: 0 0 10px rgba(var(--restrictedRGBHot), .22);
    }
    #popupDetails #detailFoot{
      width: 100%;
      display:flex;
      flex-direction:column;
      gap: 6px;
      text-transform: none;
      letter-spacing: .4px;
      font-size: 12px;
      color: rgba(215,230,255,.72);
    }
    #popupDetails .intelLabel{
      font-size: 12px;
      letter-spacing: 1.2px;
      text-transform: uppercase;
      color: rgba(96,143,255,.48);
      font-weight: 700;
    }
    #popupDetails.restricted .intelLabel{
      color: rgba(var(--restrictedTextRGB), .52);
      text-shadow: 0 0 10px rgba(var(--restrictedRGBHot), .16);
    }
    #popupDetails .intelList{ display:flex; flex-direction:column; gap: 6px; }
    #popupDetails .intelRow{ display:flex; align-items:center; gap: 10px; }
    #popupDetails .intelLogo{
      width: 65px; height: 65px;
      object-fit: contain;
      filter: drop-shadow(0 0 10px rgba(0,0,0,.55));
      opacity: .92;
    }
    #popupDetails .intelName{
      color: rgba(var(--ylRGB), .86);
      text-shadow: 0 0 12px rgba(var(--ylRGB), .10);
      font-weight: 700;
      letter-spacing: 1px;
      text-transform: uppercase;
      font-size: 15px;
    }
    #popupDetails.restricted .intelName{
      color: rgba(var(--restrictedTextRGB), .95);
      text-shadow: 0 0 12px rgba(var(--restrictedRGBHot), .22);
    }
    #popupDetails .intelDim{ color: rgba(215,230,255,.40); }

    /* Restricted MAP/INTEL warning */
    #popupDetails .intelWarning{
      position: relative;
      width: 100%;
      padding: 10px 10px;
      border: 1px solid rgba(96,143,255,.24);
      background:
        linear-gradient(180deg, rgba(0,0,0,.52), rgba(0,0,0,.22)),
        repeating-linear-gradient(0deg, rgba(96,143,255,.06), rgba(96,143,255,.06) 1px, transparent 1px, transparent 14px);
      overflow: hidden;
    }
    #popupDetails.restricted .intelWarning{
      border-color: rgba(var(--restrictedRGB), .55);
      box-shadow: 0 0 18px rgba(var(--restrictedRGBHot), .10);
      background:
        linear-gradient(180deg, rgba(0,0,0,.62), rgba(0,0,0,.26)),
        repeating-linear-gradient(0deg, rgba(var(--restrictedRGB), .10), rgba(var(--restrictedRGB), .10) 1px, transparent 1px, transparent 14px);
    }
    #popupDetails .intelWarning::after{
      content:"";
      position:absolute;
      inset: -2px;
      pointer-events:none;
      background:
        linear-gradient(90deg, transparent, rgba(255,255,255,.08), transparent),
        linear-gradient(0deg, rgba(255,255,255,.05) 0 1px, transparent 1px 6px);
      mix-blend-mode: screen;
      opacity: .22;
      animation: intelGlitch 1.25s steps(2, start) infinite;
    }
    #popupDetails .intelWarnTitle{
      font-weight: 900;
      letter-spacing: 2px;
      text-transform: uppercase;
      font-size: 12px;
      color: rgba(96,143,255,.92);
    }
    #popupDetails.restricted .intelWarnTitle{
      color: rgba(var(--restrictedTextRGB), .96);
      text-shadow: 0 0 12px rgba(var(--restrictedRGBHot), .24);
    }
    #popupDetails .intelWarnBody{
      margin-top: 6px;
      font-size: 12px;
      line-height: 1.25;
      color: rgba(215,230,255,.64);
    }
    #popupDetails.restricted .intelWarnBody{
      color: rgba(var(--restrictedTextRGB), .80);
    }
    #popupDetails .intelWarnBody .hard{
      font-weight: 800;
      letter-spacing: 1px;
      text-transform: uppercase;
      color: rgba(var(--ylRGB), .86);
    }
    #popupDetails.restricted .intelWarnBody .hard{
      color: rgba(var(--restrictedTextRGB), .95);
    }
    #popupDetails .intelWarnBody .stamp{
      display:inline-block;
      padding: 2px 6px;
      margin-top: 8px;
      border: 1px solid rgba(96,143,255,.34);
      color: rgba(96,143,255,.72);
      letter-spacing: 1.6px;
      text-transform: uppercase;
      font-size: 10px;
    }
    #popupDetails.restricted .intelWarnBody .stamp{
      border-color: rgba(var(--restrictedRGB), .55);
      color: rgba(var(--restrictedTextRGB), .80);
    }
    @keyframes intelGlitch{
      0%{ transform: translate(0,0); opacity:.22; }
      20%{ transform: translate(-2px, 1px); opacity:.30; }
      40%{ transform: translate(2px, -1px); opacity:.26; }
      60%{ transform: translate(-1px, 0); opacity:.34; }
      80%{ transform: translate(1px, -1px); opacity:.28; }
      100%{ transform: translate(0,0); opacity:.22; }
    }

    /* Restricted hack prompt ("BREACH PROTOCOL" button next to Area Details)
       Implemented as an SVG polygon so the outline stroke follows diagonals perfectly. */
    .hackPrompt{
      position: fixed;
      z-index: 65;
      display: none;
      pointer-events: auto;
      transform: translate3d(0,0,0);
    }
    .hackPrompt.on{ display: block; }

    .hackPrompt .btn{
      --bpStroke: 96, 143, 255;
      --bpStrokeHot: var(--ylRGB);
      --bpFillA: 6, 10, 22;
      --bpContentShift: 12px;
      --bpPress: 0px;
      appearance: none;
      border: 0;
      background: transparent;
      padding: 0;
      cursor: pointer;
      position: relative;
      width: 320px;
      height: 78px;
      text-transform: uppercase;
    }
    .hackPrompt.on .btn{ animation: breachPop .55s cubic-bezier(.18,.92,.12,1) both; }
    @keyframes breachPop{
      0%{ opacity: 0; transform: translate3d(-6px, 10px, 0) scale(.985); filter: blur(1.1px); }
      55%{ opacity: 1; transform: translate3d(2px, -2px, 0) scale(1.01); filter: blur(.25px); }
      100%{ opacity: 1; transform: translate3d(0,0,0) scale(1); filter: blur(0px); }
    }

    .hackPrompt .btn .bpSvg{
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      transform: translateY(var(--bpPress));
      transition: transform 70ms linear, filter 70ms linear;
    }
    .hackPrompt .btn .bpOutline{
      fill: none;
      stroke: rgba(var(--bpStroke), .92);
      stroke-width: 2;
      filter: drop-shadow(0 0 4px rgba(var(--bpStroke), .34));
    }
    .hackPrompt .btn .bpFill{ fill: rgba(var(--bpFillA), .86); }
    .hackPrompt .btn .bpTab{ fill: rgba(var(--bpStroke), .78); }
    .hackPrompt .btn .bpTabSep{
      fill: none;
      stroke: rgba(0,0,0,.55);
      stroke-width: 1.5;
      opacity: .48;
    }
    .hackPrompt .btn .bpTagText{
      font-family: "Rajdhani", ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      font-weight: 900;
      font-size: 28px;
      letter-spacing: 2px;
      text-transform: uppercase;
      fill: rgba(0,0,0,.86);
    }
    .hackPrompt .btn .bpScan{ fill: rgba(255,255,255,.22); }
    .hackPrompt .btn .bpLines{
      fill: url(#bpScanlines);
      opacity: .10;
    }

    .hackPrompt .btn .bpContent{
      position: relative;
      z-index: 1;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 22px;
      gap: 12px;
      /* Center content in the main bar area (the left tab raises the overall box) */
      transform: translateY(calc(var(--bpContentShift) + var(--bpPress)));
      transition: transform 70ms linear;
    }

    /* Click/press feedback ("boop" like a physical button) */
    .hackPrompt .btn:active{ --bpPress: 2px; }
    .hackPrompt .btn:active .bpOutline{ filter: drop-shadow(0 0 14px rgba(var(--bpStrokeHot), .58)); }
    .hackPrompt .btn:active .bpFill{ filter: brightness(.92); }
    .hackPrompt .btn:active .bpStatus{ transform: translateY(1px); }
    .hackPrompt .btn .bpTitle{
      font-weight: 900;
      letter-spacing: 2.4px;
      font-size: 14px;
      line-height: 1;
      color: rgba(var(--bpStroke), .94);
      text-shadow: 0 0 12px rgba(var(--bpStroke), .14);
      white-space: nowrap;
      /* Push title toward the center of the long bar */
      margin-left: 34px;
    }
    .hackPrompt .btn .bpStatus{
      display: inline-flex;
      align-items: center;
      font-weight: 800;
      letter-spacing: 1.8px;
      font-size: 11px;
      padding: 4px 10px;
      border: 1px solid rgba(var(--bpStroke), .70);
      color: rgba(var(--bpStroke), .92);
      background: rgba(0,0,0,.22);
      white-space: nowrap;
    }

    .hackPrompt .btn:hover .bpOutline{
      stroke: rgba(var(--bpStrokeHot), .98);
      filter: drop-shadow(0 0 10px rgba(var(--bpStrokeHot), .48));
    }
    .hackPrompt .btn:hover .bpTab{ fill: rgba(var(--bpStrokeHot), .92); }
    .hackPrompt .btn:hover .bpTitle{
      color: rgba(var(--bpStrokeHot), .92);
      text-shadow: 0 0 12px rgba(var(--bpStrokeHot), .16);
    }

    .hackPrompt .btn:hover .bpStatus{
      border-color: rgba(var(--bpStrokeHot), .92);
      color: rgba(0,0,0,.92);
      background: rgba(var(--bpStrokeHot), .92);
      text-shadow: none;
    }

    /* Keep BREACH PROTOCOL blue; just darken the fill slightly when the Area Details panel is restricted. */
    #popupDetails.restricted + .hackPrompt .btn{ --bpFillA: 0, 0, 0; }
    #popupDetails.restricted + .hackPrompt .btn .bpFill{ fill: rgba(0,0,0,.70); }

    /* Generic hack timer line inside the existing counterhack window */
    body.restricted-hack-active .counterhack-win .instr span:last-child{
      color: rgba(var(--ylRGB), .88);
      font-weight: 800;
      letter-spacing: 1.4px;
    }
    body.restricted-hack-active .counterhack-win .label{ letter-spacing: 2px; }

    /* Restricted theming (defaults to Merryweather-style yellow) */
    .restricted-overlay,
    #popupDetails.restricted{
      --restrictedRGB: 255, 238, 152;
      --restrictedRGBHot: 255, 196, 44;
      --restrictedTextRGB: 255, 238, 152;
    }
    #popupDetails.restricted{
      --pdStroke: var(--restrictedRGB);
      --pdStrokeHot: var(--restrictedRGBHot);
    }
    .restricted-overlay.theme-blue,
    #popupDetails.restricted.theme-blue{
      --restrictedRGB: 96, 143, 255;
      --restrictedRGBHot: 96, 143, 255;
      --restrictedTextRGB: 96, 143, 255;
    }
    .restricted-overlay.theme-red,
    #popupDetails.restricted.theme-red{
      --restrictedRGB: 207, 0, 0;
      --restrictedRGBHot: 255, 65, 65;
      --restrictedTextRGB: 255, 65, 65;
    }

    /* SecuroServ global UI mode: force the entire HUD palette to red shades */
    body.securosserv-mode{
      --ui: rgb(var(--ssHot));
      --yl: rgb(var(--ssHot));
      --panel: rgba(18, 4, 6, .78);
      --line: rgba(var(--ssHot), .70);
      --line2: rgba(var(--ssHot), .30);
      --glowB: 0 0 16px rgba(var(--ssHot), .28), 0 0 44px rgba(var(--ss), .20);
      --glowY: 0 0 12px rgba(var(--ssHot), .30), 0 0 30px rgba(var(--ssHot), .18);
    }

    body.securosserv-mode .hudtitle{ color: rgba(var(--ssHot), .95); }
    body.securosserv-mode .hudfoot{ color: rgba(var(--ssHot), .78); border-top-color: rgba(var(--ssHot), .35); }

    body.securosserv-mode .topnav .tabs::before,
    body.securosserv-mode .topnav .tabs::after{
      border-bottom-color: rgba(var(--ssHot), .24);
    }
    body.securosserv-mode .topnav .tab{ color: rgba(var(--ssHot), .86); }
    body.securosserv-mode .topnav .tab span{ border-bottom-color: rgba(var(--ssHot), .36); }
    body.securosserv-mode .topnav .tab.on span{ border-bottom-color: rgba(var(--ss), 1); }
    body.securosserv-mode .topnav .tab:hover{ color: rgba(var(--ssHot), .98); }
    body.securosserv-mode .topnav .tab:hover span{ border-bottom-color: rgba(var(--ssHot), .70); }

    body.securosserv-mode .sidemenu{ border-color: rgba(var(--ssHot), .26); box-shadow: var(--glowB); }
    body.securosserv-mode .sidemenu::before{ border-color: rgba(var(--ssHot), .26); color: rgba(var(--ssHot), .78); }
    body.securosserv-mode .sidemenu .tab,
    body.securosserv-mode .sidemenu .arrow{ color: rgba(var(--ssHot), .86); }
    body.securosserv-mode .sidemenu .tab span{ border-bottom-color: rgba(var(--ssHot), .36); }
    body.securosserv-mode .sidemenu .tab.on span{
      border-bottom-color: rgba(var(--ss), 1);
      filter:
        drop-shadow(0 0 10px rgba(var(--ssHot), .22))
        drop-shadow(0 0 18px rgba(var(--ssHot), .14));
    }
    body.securosserv-mode .sidemenu .tab:hover:not(.on),
    body.securosserv-mode .sidemenu .arrow:hover{ color: rgba(var(--ssHot), .98); }
    body.securosserv-mode .sidemenu .tab:hover:not(.on) span,
    body.securosserv-mode .sidemenu .arrow:hover span{
      filter:
        drop-shadow(0 0 10px rgba(var(--ssHot), .26))
        drop-shadow(0 0 18px rgba(var(--ssHot), .16));
    }
    body.securosserv-mode .sidemenu .tab:hover:not(.on) span{ border-bottom-color: rgba(var(--ssHot), .70); }

    body.securosserv-mode .tip{
      border-color: rgba(var(--ss), 1);
      box-shadow: 0 0 12px rgba(var(--ssHot), .24), 0 0 22px rgba(var(--ssHot), .14);
      color: rgba(var(--ssHot), .95);
      text-shadow: 0 0 7px rgba(var(--ssHot), .40), 0 0 14px rgba(var(--ssHot), .26);
    }

    body.securosserv-mode .term,
    body.securosserv-mode .boot-lines{
      color: rgba(var(--ssHot), .92);
      border-color: rgba(var(--ssHot), .28);
    }
    body.securosserv-mode .boot-top,
    body.securosserv-mode .boot-foot{ border-color: rgba(var(--ssHot), .30); }
    body.securosserv-mode .boot-title{ color: rgba(var(--ssHot), .96); }
    body.securosserv-mode .boot-sub{ color: rgba(var(--ssHot), .72); }
    body.securosserv-mode .boot-line.dim{ color: rgba(var(--ssHot), .62); }
    body.securosserv-mode .boot-meta{ color: rgba(var(--ssHot), .70); }
    body.securosserv-mode .boot-foot{ color: rgba(var(--ssHot), .66); }
    body.securosserv-mode .boot-inner::before{ border-color: rgba(var(--ssHot), .16); }
    body.securosserv-mode .boot-bar{ border-color: rgba(var(--ssHot), .30); }
    body.securosserv-mode .boot-bar-fill{ background: rgba(var(--ssHot), .92); }

    #popupDetails.restricted{
      animation: restrictedPanelPulse 4s ease-in-out infinite;
    }
    #popupDetails.restricted::before{
      background: rgba(0,0,0,.95);
      box-shadow:
        0 0 0 4px rgba(0,0,0,1) inset,
        0 0 32px rgba(var(--restrictedRGB), .85),
        inset 0 0 26px rgba(0,0,0,.65);
    }
    #popupDetails.restricted .hudhead{
      background: linear-gradient(120deg, rgba(var(--restrictedRGB), .18), rgba(6,10,22,.6));
    }
    #popupDetails.restricted .hudhead::before{
      background: linear-gradient(120deg, rgba(var(--restrictedRGB), .45), rgba(6,10,22,.55));
      border-color: rgba(var(--restrictedRGB), .8);
    }
    #popupDetails.restricted .hudhead::after{
      background: rgba(var(--restrictedRGB), .14);
      border-color: rgba(var(--restrictedRGB), .45);
    }
    #popupDetails.restricted .hudtitle{
      color: rgba(var(--restrictedTextRGB), .95);
      text-shadow: 0 0 8px rgba(var(--restrictedRGBHot), .55);
      font-weight: 700;
      letter-spacing: 3px;
    }
    #popupDetails.restricted .hudmeta{
      color: rgba(var(--restrictedTextRGB), .95);
      text-shadow: 0 0 8px rgba(var(--restrictedRGBHot), .55);
      font-weight: 700;
    }
    #popupDetails.restricted .hudfoot{
      border-top-color: rgba(var(--restrictedRGB), .6);
      color: rgba(var(--restrictedTextRGB), .95);
      text-shadow: 0 0 8px rgba(var(--restrictedRGBHot), .35);
      font-weight: 600;
    }
    #popupDetails.restricted .hudbody,
    #popupDetails.restricted .hudhead,
    #popupDetails.restricted .hudfoot{
      background: rgba(4,6,12,.75);
      border-color: transparent;
    }
    #popupDetails.restricted::after{
      content:"";
      position:absolute;
      inset: 2px;
      pointer-events:none;
      border-radius: inherit;
      background:
        linear-gradient(115deg, rgba(255,255,255,.08) 0 2px, transparent 2px 4px),
        linear-gradient(0deg, rgba(255,255,255,.05) 0 1px, transparent 1px 6px);
      mix-blend-mode: screen;
      clip-path: inherit;
      opacity: .45;
      animation: restrictedGlitch 1.4s linear infinite;
      background-size: 120% 120%;
      animation-timing-function: steps(2, start);
    }
    @keyframes restrictedGlitch{
      0%{ transform: translate(0,0); opacity:.45; }
      20%{ transform: translate(-3px, 1px); }
      40%{ transform: translate(2px, -1px); opacity:.6; }
      60%{ transform: translate(-2px, 0); }
      80%{ transform: translate(1px, -1px); opacity:.55; }
      100%{ transform: translate(0,0); }
    }
    @keyframes restrictedPanelPulse{
      0%,100%{ filter: drop-shadow(0 0 0 rgba(var(--restrictedRGB), 0.4)); }
      40%{ filter:
        drop-shadow(0 0 26px rgba(var(--restrictedRGB), .6))
        drop-shadow(0 0 42px rgba(var(--restrictedRGBHot), .35)); }
    }
    #popupDetails.restricted .details .dRow{
      border-color: rgba(var(--restrictedRGB), .35);
    }
    #popupDetails.restricted .details .dK{
      color: rgba(var(--restrictedTextRGB), .95);
      font-weight: 600;
    }
    #popupDetails.restricted .details .dV{
      color: rgba(var(--restrictedTextRGB), .95);
      font-weight: 600;
    }
    #popupDetails.restricted .details .dMedia{
      border-color: rgba(var(--restrictedRGB), .95);
      box-shadow: 0 0 24px rgba(var(--restrictedRGB), .45);
      background: rgba(4,2,8,.85);
    }
    #popupDetails.restricted .dNoteText{
      background: rgba(0,0,0,.8);
      border-color: rgba(var(--restrictedRGB), .85);
      color: rgba(var(--restrictedTextRGB), .95);
      box-shadow: inset 0 0 24px rgba(var(--restrictedRGB), .3);
    }

    /* Terminal */
    .term{
      height: 210px;
      overflow:auto;
      font-family: inherit;
      font-size: 12px;
      line-height: 1.35;
      color: rgba(var(--ylRGB), .85);
      background:
        linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,.22)),
        repeating-linear-gradient(0deg, rgba(96,143,255,.05), rgba(96,143,255,.05) 1px, transparent 1px, transparent 18px);
      border: 1px solid rgba(96,143,255,.24);
    }
    .termline{ padding: 3px 0; opacity:.92; }

    /* Bottom-left command feed (text-only) */
    .cmdFeed{
      position: fixed;
      left: 14px;
      bottom: 14px;
      z-index: 60;
      width: min(520px, calc(100vw - 28px));
      max-height: 44vh;
      overflow: hidden;
      pointer-events: none;
      user-select: none;
      -webkit-user-select: none;
      font-family: inherit;
      font-size: 12px;
      line-height: 1.35;
      color: rgba(var(--ylRGB), .86);
      text-shadow: 0 0 12px rgba(var(--ylRGB), .10);
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .cmdline{
      opacity: .95;
      transform: translateY(6px);
      filter: drop-shadow(0 0 10px rgba(0,0,0,.55));
      transition: opacity .55s ease, transform .55s ease;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .cmdline.on{ opacity: .95; transform: translateY(0); }
    .cmdline.off{ opacity: 0; transform: translateY(-6px); }

    /* Fake body scan */
    .scanbox{
      position:relative;
      height: 320px;
      border: 1px solid var(--line2);
      background: linear-gradient(180deg, rgba(96,143,255,.10), rgba(6,10,22,.0));
      overflow:hidden;
    }
    .scanfigure{
      position:absolute; inset: 18px;
      background:
        radial-gradient(circle at 50% 30%, rgba(96,143,255,.22), transparent 40%),
        radial-gradient(circle at 50% 70%, rgba(96,143,255,.14), transparent 45%);
      opacity:.8;
    }
    .scanmarks span{
      position:absolute;
      width: 10px; height: 10px;
      border: 1px solid rgba(96,143,255,.55);
      background: rgba(6,10,22,.35);
    }
    .scanmarks span:nth-child(1){ left: 26px; top: 90px; }
    .scanmarks span:nth-child(2){ right: 44px; top: 130px; }
    .scanmarks span:nth-child(3){ left: 60px; bottom: 82px; }
    .scanmarks span:nth-child(4){ right: 80px; bottom: 110px; }
    .scanline{
      position:absolute; left:-10%;
      top: 24px;
      width: 120%; height: 2px;
      background: rgba(var(--ylRGB), .55);
      box-shadow: var(--glowY);
      animation: scan 2.6s linear infinite;
      opacity:.55;
    }
    @keyframes scan{ 0%{ transform: translateY(0);} 100%{ transform: translateY(280px);} }

    /* Right visuals */
    .wavebox{
      height: 170px;
      border: 1px solid var(--line2);
      background: rgba(4,7,16,.35);
      overflow:hidden;
      position:relative;
    }
    .wave{
      position:absolute; inset:0;
      background:
        linear-gradient(transparent 60%, rgba(96,143,255,.06) 60%),
        repeating-linear-gradient(90deg, rgba(96,143,255,.06), rgba(96,143,255,.06) 1px, transparent 1px, transparent 18px);
      opacity:.8;
    }
    .wave::after{
      content:"";
      position:absolute; inset:0;
      background: linear-gradient(90deg, transparent, rgba(var(--ylRGB), .10), transparent);
      animation: sweep 2.2s linear infinite;
    }
    @keyframes sweep{ 0%{ transform: translateX(-60%);} 100%{ transform: translateX(60%);} }

    .gridbox{
      height: 260px;
      border: 1px solid var(--line2);
      background:
        repeating-linear-gradient(0deg, rgba(96,143,255,.08), rgba(96,143,255,.08) 1px, transparent 1px, transparent 18px),
        repeating-linear-gradient(90deg, rgba(96,143,255,.08), rgba(96,143,255,.08) 1px, transparent 1px, transparent 18px);
      position:relative;
    }
    .gridbox::after{
      content:"";
      position:absolute; inset: 22px;
      background: radial-gradient(circle at 50% 50%, rgba(var(--ylRGB), .75) 1px, transparent 1.2px);
      background-size: 22px 22px;
      opacity:.35;
    }

    /* Center map */
    .mapstage{ position:absolute; inset: 0; min-width:0; }
    .maphud{
      position:absolute;
      top: var(--topbar-h);
      left: 0;
      display:flex;
      gap: 10px;
      z-index: 6;
    }
    .hudchip{
      margin-top: 6px;
      padding: 8px 10px;
      background: rgba(6,10,22,.62);
      border: 1px solid var(--line2);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1.2px;
      color: rgba(215,230,255,.68);
      box-shadow: var(--glowB);
    }
    .hudchip span{ color: var(--yl); }

    /* Always-visible filter buttons */
    .hudfilters{
      display:flex;
      gap: 8px;
      align-items:center;
      margin-top: 6px;
    }
    .hudf{
      background: rgba(6,10,22,.62);
      border: 1px solid var(--line2);
      color: rgba(215,230,255,.72);
      padding: 8px 10px;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1.2px;
      cursor:pointer;
      box-shadow: var(--glowB);
    }
    .hudf:hover{
      border-color: rgba(var(--ylRGB), .35);
      color: var(--yl);
      box-shadow: var(--glowY);
    }
    .hudf.on{
      background: var(--yl);
      color:#0a1024;
      border-color: rgba(var(--ylRGB), .65);
      box-shadow: var(--glowY);
    }

    .mapwrap{
      position:absolute;
      inset: 0;
      border: none;
      background: transparent;
      overflow:hidden;
    }

    /* Side zoom bar (blue outline, yellow fill from center) */
    .zoomBar{
      position:absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      width: 10px;
      height: 190px;
      border: 1px solid var(--ui);
      background: transparent;
      z-index: 12;
      pointer-events:none;
      --fill: 0;
      display: flex;
      align-items: center;
      justify-content: flex-end;
    }
    .zoomReadout{
      position: absolute;
      right: 100%;
      margin-right: 8px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1.2px;
      color: rgba(96,143,255,.72);
      font-weight: 600;
      white-space: nowrap;
      writing-mode: vertical-rl;
      text-orientation: mixed;
      transform: rotate(180deg);
      pointer-events: none;
    }
    .zoomBar .fill{
      position:absolute;
      left: 1px;
      right: 1px;
      background: var(--yl);
    }
    .zoomBar .fill.up{
      bottom: 50%;
      height: calc(var(--fill) * 50%);
    }
    .zoomBar .fill.down{
      top: 50%;
      height: calc(var(--fill) * 50%);
    }
    /* Map stack: raster layers + SVG share one transform */
    #mapStack{
      position:absolute;
      left: 0;
      top: 0;
      transform-origin: 0 0;
      will-change: transform;
      cursor: grab;
    }
    #mapStack.grabbing{ cursor: grabbing; }
    /* Only raster base layers are direct children of #mapStack.
       Keep this rule from affecting district logo <img> elements. */
    #mapStack > img{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      object-fit: fill;
      pointer-events:none;
      user-select:none;
      z-index: 1;
    }

    #labelsLayer{
      position:absolute;
      inset:0;
      pointer-events:none;
      z-index: 8;
      display: none;
    }

    #logosLayer{
      position:absolute;
      inset:0;
      pointer-events:none;
      z-index: 7;
      --logoZoomScale: 1;
    }

    #markersLayer{
      position:absolute;
      inset: 0;
      z-index: 9;
      pointer-events: none;
    }
    .districtLogo{
      position:absolute;
      transform: translate(-50%, -50%) scale(calc(0.72 * var(--logoZoomScale, 1)));
      transform-origin: 50% 50%;
      opacity: .40;
      transition: transform .12s ease, opacity .12s ease, filter .12s ease;
      filter:
        drop-shadow(0 0 10px rgba(96,143,255,.10));
    }
    .districtLogo.ready{ opacity: .40; }
    .districtLogo img{
      width: 88px;
      height: 88px;
      object-fit: contain;
      display:block;
      opacity: 1;
    }
    .districtLogo.hot{
      opacity: 1;
      transform: translate(-50%, -50%) scale(calc(1.05 * var(--logoZoomScale, 1)));
      filter:
        drop-shadow(0 0 12px rgba(96,143,255,.18))
        drop-shadow(0 0 18px rgba(var(--ylRGB), .10));
    }
    .districtLabel{
      position:absolute;
      transform: translate(-50%, -50%);
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1.2px;
      color: var(--yl);
      text-shadow: 0 0 6px rgba(var(--ylRGB), .35), 0 0 12px rgba(var(--ylRGB), .25);
      white-space: nowrap;
    }
    #svgHost{
      position:absolute;
      inset: 0;
      display:block;
      transform-origin: 0 0;
      z-index: 6;
    }

    #restrictedBlurLayer{
      position:absolute;
      inset: 0;
      z-index: 5; /* above raster, below regions */
      pointer-events:none;
      opacity: 0;
      transition: opacity .16s ease;
    }
    #restrictedBlurLayer.on{ opacity: 1; }
    #restrictedBlurSvg{
      position:absolute;
      inset:0;
      display:block;
      width:100%;
      height:100%;
      pointer-events:none;
      user-select:none;
    }

    /* Tooltip */
    .tip{
      position:absolute;
      pointer-events:none;
      z-index: 10;
      padding: 10px 12px;
      border: 1px solid var(--ui); /* blue box */
      background: rgba(6,10,22,.78); /* dark blue, barely transparent */
      box-shadow: 0 0 10px rgba(96,143,255,.18), 0 0 18px rgba(96,143,255,.12); /* subtle blue glow */
      color: var(--yl); /* neon yellow text */
      opacity: 0;
      left: 50%;
      bottom: 0;
      transform: translateX(-50%);
      transition: opacity .12s ease;
      max-width: 360px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      text-transform: uppercase;
      font-size: 12px;
      letter-spacing: 1.15px;
      text-shadow: 0 0 6px rgba(var(--ylRGB), .35), 0 0 12px rgba(var(--ylRGB), .22); /* subtle yellow glow */
      border-bottom: none;
      border-radius: 0;
    }
    .tip.on{ opacity: 1; }

    /* SecuroServ hover: force tooltip to red even without selection */
    .tip.securoserv{
      border-color: rgba(var(--ss), 1);
      box-shadow: 0 0 12px rgba(var(--ssHot), .22), 0 0 22px rgba(var(--ssHot), .14);
      color: rgba(var(--ssHot), .95);
      text-shadow: 0 0 7px rgba(var(--ssHot), .40), 0 0 14px rgba(var(--ssHot), .26);
    }

    /* HARD RULE: no rounded edges anywhere */
    *, *::before, *::after{ border-radius: 0 !important; }

    /* Cursor-following district logo */
    .cursorLogo{
      position:absolute;
      z-index: 11;
      width: 69px;
      height: 69px;
      object-fit: contain;
      pointer-events:none;
      user-select:none;
      opacity: 0;
      /* anchor: immediately to the right of cursor, vertically centered */
      transform: translate(16px, -50%);
      transition: opacity .12s ease;
      filter:
        drop-shadow(0 0 10px rgba(96,143,255,.18))
        drop-shadow(0 0 18px rgba(96,143,255,.10));
    }
    /* Disabled: logos are now rendered in-district */
    .cursorLogo{ display:none !important; }
    .cursorLogo.on{
      opacity: 1;
      animation: logoGlitchInCursor .36s ease-out both;
    }

    @keyframes logoGlitchInCursor{
      0%{ opacity: 0; transform: translate(16px, -50%) scale(.82) skewX(12deg); filter: drop-shadow(0 0 22px rgba(96,143,255,.32)) drop-shadow(0 0 36px rgba(96,143,255,.18)); }
      16%{ opacity: .85; transform: translate(18px, -50%) scale(1.06) skewX(-10deg); }
      26%{ opacity: .25; transform: translate(14px, -50%) scale(.98) skewX(8deg); }
      38%{ opacity: .95; transform: translate(17px, -50%) scale(1.02) skewX(-6deg); }
      54%{ opacity: .55; transform: translate(15px, -50%) scale(1.00) skewX(4deg); }
      72%{ opacity: 1; transform: translate(16px, -50%) scale(1.00) skewX(-2deg); }
      100%{ opacity: 1; transform: translate(16px, -50%) scale(1) skewX(0deg); filter: drop-shadow(0 0 10px rgba(96,143,255,.18)) drop-shadow(0 0 18px rgba(96,143,255,.10)); }
    }

    /* Popup window */
    .hudpopup{
      position:fixed;
      left: 14px;
      top: var(--detailsTop, calc(var(--topbar-h) + 10px + 170px));
      bottom: calc(14px + var(--dockH, 0px) + 14px);
      width: 270px;
      max-height: none;
      overflow:auto;
      z-index: 7;
      display:none;
    }
    .hudpopup.on{ display:block; }

    .hudhead-actions{ display:flex; gap: 8px; align-items:center; }
    .hudbtn{
      background: rgba(0,0,0,.32);
      border: 1px solid rgba(96,143,255,.28);
      color: var(--text);
      padding: 6px 10px;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
      cursor:pointer;
    }
    .hudbtn:hover{
      border-color: rgba(var(--ylRGB), .45);
      color: var(--yl);
      box-shadow: var(--glowY);
    }
    .hudbtn-x{ width: 30px; padding: 6px 0; color: var(--yl); }

    /* Field */
    .field{ margin-top: 12px; }
    .field label{
      display:block;
      font-size: 10px;
      letter-spacing: 1.2px;
      text-transform: uppercase;
      color: rgba(96,143,255,.95);
      margin-bottom: 6px;
    }
    .field input{
      width: 100%;
      background: rgba(4,7,16,.45);
      border: 1px solid var(--line2);
      color: var(--text);
      padding: 10px;
      outline:none;
    }
    .field input:focus{
      border-color: rgba(var(--ylRGB), .40);
      box-shadow: var(--glowY);
    }

    /* Pills */
    .pillbar{ display:flex; gap: 10px; flex-wrap:wrap; margin-top: 12px; }
    .pill{
      padding: 6px 10px;
      border: 1px solid var(--line2);
      background: rgba(4,7,16,.35);
      color: rgba(215,230,255,.68);
      text-transform: uppercase;
      letter-spacing: 1.1px;
      font-size: 10px;
      cursor:pointer;
    }
    .pill.on{
      background: var(--yl);
      color:#0a1024;
      border-color: rgba(var(--ylRGB), .65);
      box-shadow: var(--glowY);
    }

    /* Details panel */
    .details .dHeader{
      display:flex;
      gap: 12px;
      align-items:flex-start;
    }
    .details .dKV{ flex: 1; min-width: 0; }
    .details .dMedia{
      width: 78px;
      height: 78px;
      border: 1px solid var(--ui);
      background: color-mix(in srgb, var(--ui) 10%, transparent);
      box-shadow: var(--glowB);
      display:flex;
      align-items:center;
      justify-content:center;
      flex: 0 0 auto;
      overflow:hidden;
    }
    .details .dMedia img{
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: none;
      image-rendering: auto;
    }
    .details .dMedia img.on{ display:block; }

    .details .dRow{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding: 6px 0;
      border-bottom: 1px solid rgba(96,143,255,.12);
    }
    .details .dRow:last-child{ border-bottom:none; }
    .details .dK{
      color: rgba(96,143,255,.95);
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1.2px;
    }
    .details .dV{
      color: var(--text);
      font-size: 11px;
      text-align:right;
    }
    .details .dSep{
      height: 1px;
      background: rgba(96,143,255,.25);
      margin: 12px 0;
    }
    .details .dActions{
      display:flex;
      gap: 8px;
      margin-bottom: 12px;
    }
    .details .dLore{ display:none; }
    .details .dLore.on{ display:block; }
    .details .dLore .dNoteText{
      width: 100%;
      min-height: 56px;
      background: rgba(4,7,16,.35);
      border: 1px solid var(--line2);
      color: var(--text);
      padding: 8px;
      font-family: inherit;
      font-size: 11px;
      line-height: 1.35;
      white-space: pre-wrap;
      user-select: text;
    }

    /* (Scrapped) feed/dock/biometric UI styles removed */

    /* =========================
       SVG LAYERS (THIN STROKES)
       ========================= */

    #svgHost .region:not(.wall){
      transition: stroke-opacity .12s ease, stroke-width .12s ease, stroke .12s ease, fill .12s ease;
      /* Outline-only: slightly thicker, but very transparent by default */
      stroke-width: calc(var(--sw-region) + 1.8px) !important;
      vector-effect: non-scaling-stroke !important;
      opacity: 1;
      stroke-opacity: .16 !important;
      filter: none !important;
      /* Never show region fills; keep a tiny invisible fill for hit-testing */
      fill: rgba(0,0,0,0.001) !important;
    }

    /* Restricted zones: always more visible than normal (idle/hover/selected). */
    #svgHost .region.restricted:not(.wall):not(.hot):not(.selected){
      stroke-opacity: .30 !important;
    }
    #svgHost .region.restricted.hot:not(.selected):not(.wall){
      stroke-opacity: .50 !important;
    }
    #svgHost .region.restricted.selected:not(.wall){
      stroke-opacity: .50 !important;
    }

    /* Hovered: less transparent */
    #svgHost .region.hot:not(.selected):not(.wall){
      stroke-opacity: .30 !important;
      stroke-width: calc(var(--sw-region) + 2.4px) !important;
      filter: none !important;
    }

    /* Selected: even less transparent */
    #svgHost .region.selected:not(.wall){
      stroke-opacity: .45 !important;
      stroke-width: calc(var(--sw-region) + 3.0px) !important;
      filter: none !important;
    }



    .restricted-overlay{
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 6;
      opacity: 0;
      transition: opacity .6s ease;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      padding-bottom: 12vh;
    }
    .restricted-overlay.on{
      opacity: 1;
    }

    .securoserv-wall{
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      pointer-events: none;
      z-index: 50;
      opacity: 0;
      transition: opacity .6s ease;
    }
    .securoserv-wall.on{
      opacity: .18;
    }

    .securoserv-chaos{
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 70;
      opacity: 0;
      transition: opacity .55s ease;
    }
    .securoserv-chaos.on{ opacity: 1; }

    .screen-glitch{
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 90;
      opacity: 0;
      transition: opacity .45s ease;
    }
    .screen-glitch.on{ opacity: calc(0.18 + (var(--g, 0) * 0.82)); }
    .screen-glitch::before{
      content:"";
      position:absolute;
      inset: 0;
      /* scanlines + slight chroma offset */
      background:
        repeating-linear-gradient(
          180deg,
          rgba(0,0,0,.00) 0px,
          rgba(0,0,0,.00) 2px,
          rgba(var(--ssHot), .055) 3px,
          rgba(0,0,0,.00) 4px
        ),
        linear-gradient(90deg,
          rgba(var(--ssHot), .075),
          rgba(0,0,0,0) 35%,
          rgba(var(--ssHot), .050) 70%,
          rgba(0,0,0,0)
        );
      mix-blend-mode: screen;
      opacity: calc(0.22 + (var(--g, 0) * 0.86));
      filter: blur(.15px);
      animation: securoservScanDrift calc(1.55s - (var(--g, 0) * 0.95s)) steps(2) infinite;
    }
    .screen-glitch::after{
      content:"";
      position:absolute;
      inset: 0;
      /* glitch bars + noise-like speckle using gradients */
      background:
        linear-gradient(0deg,
          transparent 0%,
          rgba(var(--ssHot), .00) 18%,
          rgba(var(--ssHot), .18) 22%,
          rgba(var(--ssHot), .00) 26%,
          rgba(0,0,0,0) 100%
        ),
        repeating-linear-gradient(90deg,
          rgba(var(--ssHot), .10) 0px,
          rgba(var(--ssHot), .10) 1px,
          rgba(0,0,0,0) 1px,
          rgba(0,0,0,0) 7px
        ),
        radial-gradient(circle at 18% 34%, rgba(var(--ssHot), .12), transparent 40%),
        radial-gradient(circle at 72% 68%, rgba(var(--ssHot), .08), transparent 42%);
      mix-blend-mode: screen;
      opacity: calc(0.12 + (var(--g, 0) * 0.80));
      animation: securoservGlitchBars calc(1.25s - (var(--g, 0) * 0.85s)) steps(2) infinite;
    }
    @keyframes securoservScanDrift{
      0%{ transform: translate3d(0,0,0); }
      20%{ transform: translate3d(0,-1px,0) skewX(-0.3deg); }
      45%{ transform: translate3d(0,1px,0) skewX(0.4deg); }
      70%{ transform: translate3d(0,-2px,0) skewX(-0.6deg); }
      100%{ transform: translate3d(0,0,0); }
    }
    @keyframes securoservGlitchBars{
      0%{ transform: translate3d(0,0,0); clip-path: inset(0 0 0 0); }
      18%{ transform: translate3d(2px,0,0); clip-path: inset(8% 0 62% 0); }
      32%{ transform: translate3d(-3px,0,0); clip-path: inset(42% 0 38% 0); }
      46%{ transform: translate3d(1px,0,0); clip-path: inset(64% 0 18% 0); }
      62%{ transform: translate3d(-2px,0,0); clip-path: inset(12% 0 70% 0); }
      78%{ transform: translate3d(3px,0,0); clip-path: inset(52% 0 26% 0); }
      100%{ transform: translate3d(0,0,0); clip-path: inset(0 0 0 0); }
    }
    .securoserv-chaos .chaos-pop{
      position: absolute;
      min-width: 220px;
      max-width: min(520px, 70vw);
      background: rgba(0,0,0,.72);
      border: 1px solid rgba(var(--ss), .82);
      box-shadow:
        0 0 20px rgba(var(--ssHot), .24),
        0 0 54px rgba(var(--ss), .14);
      padding: 10px 12px;
      opacity: .92;
      filter:
        drop-shadow(0 0 12px rgba(var(--ssHot), .18))
        drop-shadow(0 0 26px rgba(var(--ss), .12));
      transform: translate3d(0,0,0);
      animation: securoservPopIn .45s ease both;
    }

    /* DISTINCT STYLE â€œSKINSâ€ (same red palette, different look) */
    .securoserv-chaos .chaos-pop.style-wire{
      background:
        linear-gradient(180deg, rgba(var(--ssHot), .09), rgba(0,0,0,.78)),
        repeating-linear-gradient(90deg, rgba(var(--ssHot), .06), rgba(var(--ssHot), .06) 1px, transparent 1px, transparent 14px);
      border-color: rgba(var(--ss), .90);
      box-shadow: 0 0 16px rgba(var(--ssHot), .20), 0 0 46px rgba(var(--ss), .12);
    }
    .securoserv-chaos .chaos-pop.style-solid{
      background:
        linear-gradient(180deg, rgba(80,0,0,.70), rgba(0,0,0,.82));
      border-color: rgba(var(--ssHot), .40);
      box-shadow: 0 0 24px rgba(var(--ssHot), .22), 0 0 78px rgba(var(--ss), .12);
    }
    .securoserv-chaos .chaos-pop.style-toast{
      background:
        linear-gradient(90deg, rgba(var(--ssHot), .26), rgba(0,0,0,.78) 46%, rgba(0,0,0,.78));
      border-left-width: 4px;
      border-left-color: rgba(var(--ss), 1);
      padding: 10px 14px;
    }
    .securoserv-chaos .chaos-pop.style-dialog{
      background:
        radial-gradient(circle at 10% 0%, rgba(var(--ssHot), .18), transparent 40%),
        linear-gradient(180deg, rgba(0,0,0,.78), rgba(0,0,0,.90));
      border-width: 2px;
    }
    .securoserv-chaos .chaos-pop.style-terminal{
      background:
        linear-gradient(180deg, rgba(0,0,0,.92), rgba(0,0,0,.78));
      border-color: rgba(var(--ssHot), .40);
      box-shadow: inset 0 0 0 1px rgba(var(--ssHot), .10), 0 0 28px rgba(var(--ss), .14);
    }
    .securoserv-chaos .chaos-pop.style-siren{
      background:
        linear-gradient(180deg, rgba(var(--ssHot), .18), rgba(0,0,0,.78));
      border-color: rgba(var(--ss), .96);
    }
    .securoserv-chaos .chaos-pop.style-siren .chaos-h{
      text-shadow: 0 0 14px rgba(var(--ssHot), .36);
    }
    .securoserv-chaos .chaos-pop.style-siren::after{
      content:"";
      position:absolute;
      left: 0;
      right: 0;
      top: 0;
      height: 10px;
      background:
        repeating-linear-gradient(90deg, rgba(var(--ss), 1), rgba(var(--ss), 1) 14px, rgba(0,0,0,.0) 14px, rgba(0,0,0,.0) 26px);
      opacity: .45;
      mix-blend-mode: screen;
    }

    /* Mid-screen SecuroServ "loading" bar (appears during escalation) */
    .securoserv-midbar{
      position: fixed;
      left: 50%;
      top: 46%;
      transform: translate(-50%, -50%);
      z-index: 95;
      pointer-events: none;
      opacity: 0;
      transition: opacity .35s ease;
    }
    .securoserv-midbar.on{ opacity: 1; }
    .securoserv-midbar .frame{
      width: min(920px, 88vw);
      background: rgba(0,0,0,.78);
      border: 2px solid rgba(var(--ss), .95);
      box-shadow: 0 0 26px rgba(var(--ssHot), .22), 0 0 84px rgba(var(--ss), .14);
      padding: 14px 16px 16px;
      position: relative;
      clip-path: polygon(0 18px, 18px 0, 100% 0, 100% calc(100% - 18px), calc(100% - 18px) 100%, 0 100%);
    }
    .securoserv-midbar .label{
      font-weight: 700;
      letter-spacing: 3px;
      text-transform: uppercase;
      color: rgba(var(--ssHot), .95);
      text-shadow: 0 0 12px rgba(var(--ssHot), .22);
      margin-bottom: 10px;
      font-size: 16px;
    }
    .securoserv-midbar .bar{
      height: 22px;
      border: 1px solid rgba(var(--ssHot), .46);
      background: rgba(0,0,0,.55);
      position: relative;
      overflow: hidden;
    }
    .securoserv-midbar .fill{
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, rgba(var(--ss), .95), rgba(var(--ssHot), .95));
      box-shadow: 0 0 18px rgba(var(--ssHot), .22);
      transition: width .10s linear;
    }
    .securoserv-midbar .bar::after{
      content:"";
      position:absolute;
      inset: -30% -10%;
      background:
        repeating-linear-gradient(180deg, rgba(0,0,0,0) 0 8px, rgba(var(--ssHot), .09) 8px 9px),
        repeating-linear-gradient(90deg, rgba(var(--ssHot), .08) 0 1px, rgba(0,0,0,0) 1px 10px);
      mix-blend-mode: screen;
      opacity: calc(0.22 + (var(--g, 0) * 0.72));
      animation: midbarGlitch calc(1.15s - (var(--g,0) * 0.65s)) steps(2) infinite;
      pointer-events:none;
    }
    @keyframes midbarGlitch{
      0%{ transform: translate3d(0,0,0) skewX(0deg); clip-path: inset(0 0 0 0); }
      20%{ transform: translate3d(3px,0,0) skewX(-0.8deg); clip-path: inset(0 0 54% 0); }
      45%{ transform: translate3d(-4px,0,0) skewX(0.9deg); clip-path: inset(42% 0 0 0); }
      70%{ transform: translate3d(2px,0,0) skewX(-0.6deg); clip-path: inset(18% 0 28% 0); }
      100%{ transform: translate3d(0,0,0) skewX(0deg); clip-path: inset(0 0 0 0); }
    }
    .securoserv-midbar .meta{
      display:flex;
      justify-content: space-between;
      margin-top: 10px;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1.8px;
      color: rgba(var(--ssHot), .78);
    }

    /* Counterhack success transition: freeze & fade hack UI while success overlay fades in */
    body.counterhack-resolving #securoservMidbar,
    body.counterhack-resolving #securoservChaos,
    body.counterhack_resolving #screenGlitch,
    body.counterhack_resolving #securoservWall,
    body.counterhack_resolving .counterhack-win{
      opacity: 0 !important;
      transition: opacity 2.9s ease !important;
    }
    body.counterhack_resolving .securoserv-chaos .chaos-pop{
      animation-play-state: paused !important;
    }

    /* Dramatic screen power-off (used when countdown ends and ESC wasn't used) */
    .screen-off{
      position: fixed;
      inset: 0;
      z-index: 12050;
      pointer-events: none;
      opacity: 0;
      background: rgba(0,0,0,1);
      transition: opacity .12s linear;
    }
    .screen-off.on{ opacity: 1; }
    .screen-off.black::before{ display:none; }
    .screen-off.fadeout{ opacity: 0; transition: opacity 2.2s ease; }

    /* While the screen is powering off, force-hide HUD so nothing can leak */
    body.powering-off .topnav,
    body.powering-off .sidemenu,
    body.powering-off .layerToggles,
    body.powering-off .termDock,
    body.powering-off .hudpopup,
    body.powering-off .securserve-badge,
    body.powering-off .tip{
      opacity: 0 !important;
      pointer-events: none !important;
      transition: opacity .10s linear;
    }

    /* Blocks all mouse input during SecuroServ countermeasures */
    .input-blocker{
      position: fixed;
      inset: 0;
      z-index: 110;
      display: none;
      pointer-events: auto;
      background: transparent;
    }
    .input-blocker.on{ display:block; }

    /* User counterhack window (yellow) â€” separate from red system midbar */
    .counterhack-win{
      --hackRGB: var(--ylRGB);
      position: fixed;
      /* Slightly off-center + lower to feel "manual" */
      left: 46.5%;
      top: 65%;
      transform: translate(-50%, -50%) rotate(-1.15deg);
      z-index: 100;
      pointer-events: none;
      opacity: 0;
      filter: blur(.7px);
      transition: opacity .38s ease, transform .62s cubic-bezier(.18,.92,.12,1), filter .62s cubic-bezier(.18,.92,.12,1);
    }

    /* SecuroServ (and SecuroServ-themed BREACH) uses red "correct" symbols. */
    body.securosserv-mode .counterhack-win,
    body.simplehack-securosserv .counterhack-win{
      --hackRGB: var(--ssHot);
    }

    /* Hard glitch-in for hacking UI (one-shot, on open) */
    .counterhack-win.glitch-in::before,
    .counterhack-win.glitch-in::after{
      content:"";
      position:absolute;
      inset:-18px -22px;
      pointer-events:none;
      opacity: 0;
    }
    .counterhack-win.glitch-in::before{
      /* scan split + bars */
      background:
        repeating-linear-gradient(180deg,
          rgba(var(--hackRGB), 0) 0px,
          rgba(var(--hackRGB), 0) 6px,
          rgba(var(--hackRGB), .16) 7px,
          rgba(var(--hackRGB), 0) 10px
        ),
        linear-gradient(90deg,
          rgba(var(--hackRGB), .16),
          rgba(0,0,0,0) 35%,
          rgba(var(--hackRGB), .12) 70%,
          rgba(0,0,0,0)
        );
      mix-blend-mode: screen;
      animation: challengeHardBars .62s steps(2) both;
    }
    .counterhack-win.glitch-in::after{
      /* chroma split pass */
      background:
        linear-gradient(0deg,
          rgba(0,0,0,0) 0%,
          rgba(255,255,255,.06) 18%,
          rgba(255,255,255,0) 28%,
          rgba(255,255,255,.08) 52%,
          rgba(255,255,255,0) 60%,
          rgba(0,0,0,0) 100%
        );
      mix-blend-mode: screen;
      filter: drop-shadow(3px 0 0 rgba(255,0,0,.10)) drop-shadow(-3px 0 0 rgba(0,220,255,.10));
      animation: challengeHardSplit .62s steps(2) both;
    }
    .counterhack-win.glitch-in .frame{
      animation: challengeHardFrame .62s steps(2) both;
    }
    .counterhack-win.glitch-in .label,
    .counterhack-win.glitch-in .instr,
    .counterhack-win.glitch-in .hint{
      text-shadow:
        0 0 14px rgba(var(--hackRGB), .22),
        2px 0 0 rgba(255,0,0,.12),
        -2px 0 0 rgba(0,220,255,.10);
    }

    .counterhack-win.glitch-in .frame::before{
      content:"";
      position:absolute;
      inset: -6px;
      pointer-events:none;
      background:
        linear-gradient(0deg, rgba(255,255,255,.06), rgba(255,255,255,0) 55%),
        repeating-linear-gradient(90deg,
          rgba(var(--hackRGB), .18) 0px,
          rgba(var(--hackRGB), .18) 1px,
          rgba(0,0,0,0) 1px,
          rgba(0,0,0,0) 9px
        );
      mix-blend-mode: screen;
      opacity: 0;
      clip-path: inset(0 0 0 0);
      animation: challengeHardSlices .62s steps(2) both;
    }
    .counterhack-win.glitch-in .frame::after{
      animation: challengeHardOutline .62s steps(2) both;
    }
    @keyframes challengeHardBars{
      0%{ opacity: 0; transform: translate3d(0,0,0); clip-path: inset(0 0 0 0); }
      14%{ opacity: 1; transform: translate3d(6px,-2px,0); clip-path: inset(0 0 70% 0); }
      36%{ opacity: .85; transform: translate3d(-8px,2px,0); clip-path: inset(44% 0 0 0); }
      58%{ opacity: .72; transform: translate3d(5px,0,0); clip-path: inset(12% 0 48% 0); }
      78%{ opacity: .62; transform: translate3d(-4px,1px,0); clip-path: inset(62% 0 10% 0); }
      100%{ opacity: 0; transform: translate3d(0,0,0); clip-path: inset(0 0 0 0); }
    }
    @keyframes challengeHardSplit{
      0%{ opacity: 0; transform: translate3d(0,0,0); }
      18%{ opacity: 1; transform: translate3d(4px,0,0) skewX(-2.4deg); }
      44%{ opacity: .75; transform: translate3d(-6px,0,0) skewX(3.0deg); }
      72%{ opacity: .50; transform: translate3d(3px,0,0) skewX(-1.8deg); }
      90%{ opacity: .30; transform: translate3d(-2px,0,0) skewX(1.2deg); }
      100%{ opacity: 0; transform: translate3d(0,0,0); }
    }
    @keyframes challengeHardFrame{
      0%{ transform: translate3d(0,10px,0) skewX(-1.4deg); filter: blur(1.8px) contrast(1.22) saturate(1.10); }
      24%{ transform: translate3d(6px,-4px,0) skewX(3.0deg); filter: blur(1.2px) contrast(1.24) saturate(1.10); }
      52%{ transform: translate3d(-8px,2px,0) skewX(-2.8deg); filter: blur(.7px) contrast(1.16) saturate(1.06); }
      78%{ transform: translate3d(4px,-1px,0) skewX(1.6deg); filter: blur(.35px) contrast(1.10) saturate(1.02); }
      100%{ transform: translate3d(0,0,0) skewX(0deg); filter: blur(0px) contrast(1.02) saturate(.92); }
    }

    @keyframes challengeHardSlices{
      0%{ opacity: 0; transform: translate3d(0,0,0); clip-path: inset(0 0 0 0); }
      16%{ opacity: .95; transform: translate3d(8px,0,0); clip-path: inset(0 0 62% 0); }
      38%{ opacity: .70; transform: translate3d(-10px,0,0); clip-path: inset(34% 0 0 0); }
      62%{ opacity: .55; transform: translate3d(6px,0,0); clip-path: inset(12% 0 40% 0); }
      82%{ opacity: .40; transform: translate3d(-4px,0,0); clip-path: inset(56% 0 10% 0); }
      100%{ opacity: 0; transform: translate3d(0,0,0); clip-path: inset(0 0 0 0); }
    }
    @keyframes challengeHardOutline{
      0%{ transform: translate3d(6px,-4px,0) skewX(-2deg); opacity: 0; }
      26%{ transform: translate3d(-7px,3px,0) skewX(2.6deg); opacity: .95; }
      62%{ transform: translate3d(4px,-2px,0) skewX(-2.0deg); opacity: .70; }
      100%{ transform: translate3d(1px,-1px,0) skewX(-.6deg); opacity: .9; }
    }

    body.securosserv-mode .counterhack-win .slot.ok,
    body.simplehack-securosserv .counterhack-win .slot.ok{
      animation: securoOkFlash .42s steps(2) both;
    }
    @keyframes securoOkFlash{
      0%{ transform: translate3d(0,0,0) scale(1); filter: brightness(1.15); }
      35%{ transform: translate3d(1px,-1px,0) scale(1.06); filter: brightness(1.22); }
      70%{ transform: translate3d(-1px,1px,0) scale(1.02); filter: brightness(1.08); }
      100%{ transform: translate3d(0,0,0) scale(1); filter: brightness(1); }
    }
    .counterhack-win[aria-hidden="false"]{
      opacity: 1;
      filter: blur(0px);
      transform: translate(-50%, -50%) rotate(-1.15deg);
      animation: counterhackWinPop .62s cubic-bezier(.18,.92,.12,1) both;
    }
    @keyframes counterhackWinPop{
      0%{ transform: translate(-50%, calc(-50% + 18px)) rotate(-1.15deg) scale(.975); opacity: 0; filter: blur(1.2px); }
      55%{ transform: translate(-50%, calc(-50% - 2px)) rotate(-1.15deg) scale(1.01); opacity: 1; filter: blur(.2px); }
      100%{ transform: translate(-50%, -50%) rotate(-1.15deg) scale(1); opacity: 1; filter: blur(0px); }
    }
    .counterhack-win .frame{
      width: min(860px, 92vw);
      background: rgba(0,0,0,.78);
      border: 2px solid rgba(var(--hackRGB), .78);
      /* Less "pretty" than the corporate UI: softer + dirtier */
      box-shadow: 0 0 22px rgba(var(--hackRGB), .10), 0 0 58px rgba(var(--hackRGB), .06);
      padding: 14px 16px 16px;
      position: relative;
      clip-path: polygon(0 18px, 18px 0, 100% 0, 100% calc(100% - 18px), calc(100% - 18px) 100%, 0 100%);
      filter: contrast(1.02) saturate(.92);
    }
    /* No animated glitches here (keeps it lightweight). */
    .counterhack-win .frame::after{
      /* Slightly misaligned outline = DIY/buggy overlay feel */
      content:"";
      position:absolute;
      inset:-2px -3px;
      border: 1px solid rgba(var(--hackRGB), .24);
      transform: translate3d(1px,-1px,0) skewX(-.6deg);
      clip-path: polygon(0 18px, 18px 0, 100% 0, 100% calc(100% - 18px), calc(100% - 18px) 100%, 0 100%);
      pointer-events:none;
      opacity:.9;
    }
    .counterhack-win .label{
      font-weight: 900;
      letter-spacing: 3px;
      text-transform: uppercase;
      color: rgba(var(--hackRGB), .92);
      text-shadow: 0 0 14px rgba(var(--hackRGB), .16);
      margin-bottom: 10px;
      font-size: 14px;
    }
    .counterhack-win .instr,
    .counterhack-win .hint{
      display:flex;
      justify-content: space-between;
      gap: 14px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1.6px;
      color: rgba(215,230,255,.62);
    }
    .counterhack-win .instr{ margin-bottom: 10px; }
    .counterhack-win .hint{ margin-top: 10px; }
    .counterhack-win .slots{
      display:flex;
      justify-content: center;
      gap: 10px;
    }
    .counterhack-win .slot{
      width: 34px;
      height: 34px;
      display:grid;
      place-items:center;
      border: 1px solid rgba(var(--hackRGB), .42);
      background: rgba(0,0,0,.42);
      color: rgba(var(--hackRGB), .92);
      font-size: 16px;
      letter-spacing: 1px;
      text-shadow: 0 0 12px rgba(var(--hackRGB), .12);
    }
    .counterhack-win .slot.ok{
      border: 2px solid rgba(var(--hackRGB), .92);
      background: rgba(var(--hackRGB), .08);
      color: rgb(var(--hackRGB));
      font-weight: 900;
      text-shadow: 0 0 14px rgba(var(--hackRGB), .22);
      box-shadow:
        0 0 18px rgba(var(--hackRGB), .10),
        inset 0 0 18px rgba(var(--hackRGB), .08);
    }

    /* Generic restricted hack: keep the window steady; glitch the background instead */
    body.restricted-hack-active .counterhack-win{
      pointer-events: none;
      animation: none !important;
    }
    body.restricted-hack-active .counterhack-win .frame{
      box-shadow:
        0 0 26px rgba(var(--ylRGB), .14),
        0 0 70px rgba(var(--ylRGB), .08);
    }
    body.restricted-hack-active .counterhack-win .frame::before{
      content:"";
      position:absolute;
      inset: 0;
      pointer-events:none;
      background:
        repeating-linear-gradient(0deg, rgba(255,255,255,.05), rgba(255,255,255,.05) 1px, transparent 1px, transparent 10px),
        linear-gradient(90deg, transparent, rgba(255,255,255,.08), transparent);
      mix-blend-mode: screen;
      opacity: .18;
      animation: intelGlitch 1.05s steps(2, start) infinite;
      clip-path: inherit;
    }

    /* Screen background glitch during generic restricted hacks and while viewing unlocked restricted intel (tinted by restricted theme) */
    body.restricted-hack-active #screenGlitch.on,
    body.restricted-unlocked-view #screenGlitch.on{ opacity: calc(0.10 + (var(--g, 0) * 0.60)); }
    body.restricted-hack-active #screenGlitch::before,
    body.restricted-unlocked-view #screenGlitch::before{
      background:
        repeating-linear-gradient(
          180deg,
          rgba(0,0,0,.00) 0px,
          rgba(0,0,0,.00) 2px,
          rgba(var(--restrictedRGBHot), .065) 3px,
          rgba(0,0,0,.00) 4px
        ),
        linear-gradient(90deg,
          rgba(var(--restrictedRGBHot), .08),
          rgba(0,0,0,0) 35%,
          rgba(var(--restrictedRGBHot), .055) 70%,
          rgba(0,0,0,0)
        );
      opacity: calc(0.18 + (var(--g, 0) * 0.70));
    }
    body.restricted-hack-active #screenGlitch::after,
    body.restricted-unlocked-view #screenGlitch::after{
      background:
        linear-gradient(0deg,
          transparent 0%,
          rgba(var(--restrictedRGBHot), .00) 18%,
          rgba(var(--restrictedRGBHot), .18) 22%,
          rgba(var(--restrictedRGBHot), .00) 26%,
          rgba(0,0,0,0) 100%
        ),
        repeating-linear-gradient(90deg,
          rgba(var(--restrictedRGBHot), .10) 0px,
          rgba(var(--restrictedRGBHot), .10) 1px,
          rgba(0,0,0,0) 1px,
          rgba(0,0,0,0) 7px
        ),
        radial-gradient(circle at 18% 34%, rgba(var(--restrictedRGBHot), .12), transparent 40%),
        radial-gradient(circle at 72% 68%, rgba(var(--restrictedRGBHot), .08), transparent 42%);
      opacity: calc(0.10 + (var(--g, 0) * 0.62));
    }
    body.restricted-hack-active .counterhack-win .instr,
    body.restricted-hack-active .counterhack-win .hint{
      color: rgba(215,230,255,.78);
    }
    body.restricted-hack-active .counterhack-win .slot{
      box-shadow: inset 0 0 18px rgba(var(--hackRGB), .06);
    }

    /* Counterhack success flash */
    .counterhack-fx{
      position: fixed;
      inset: 0;
      z-index: 12040;
      pointer-events: none;
      display: none;
      opacity: 0;
      background: rgba(var(--ylRGB), .92);
    }
    .counterhack-fx.on{
      display: block;
      /* Cap intensity: only 50% of previous opacity */
      opacity: .5;
      transition: opacity 2.9s ease;
    }
    .counterhack-fx.on.fade{
      opacity: 0;
      transition: opacity 2.9s ease;
    }
    .counterhack-fx .msg{
      position:absolute;
      left: 50%;
      top: 46%;
      transform: translate(-50%, -50%);
      font-size: clamp(26px, 5vw, 54px);
      font-weight: 900;
      letter-spacing: 4px;
      text-transform: uppercase;
      color: rgba(6,10,22,.96);
      text-shadow: 0 0 22px rgba(255,255,255,.16);
      white-space: nowrap;
      opacity: 0;
      filter: blur(.6px);
    }
    .counterhack-fx.on .msg{
      opacity: 1;
      filter: blur(0px);
      animation:
        counterhackMsgIn .62s cubic-bezier(.18,.92,.12,1) both,
        counterhackMsgGlitch 1.1s steps(2, end) infinite;
    }
    .counterhack-fx.on.fade .msg{
      animation: counterhackMsgGlitch .9s steps(2, end) infinite;
    }
    @keyframes counterhackMsgIn{
      0%{ opacity: 0; transform: translate3d(0,6px,0) scale(.99); letter-spacing: 12px; filter: blur(1.2px); }
      40%{ opacity: .75; transform: translate3d(0,0,0) scale(1.004); letter-spacing: 6px; }
      70%{ opacity: 1; transform: translate3d(0,0,0) scale(1.0); letter-spacing: 4px; }
      100%{ opacity: 1; transform: translate3d(0,0,0) scale(1); letter-spacing: 4px; filter: blur(0px); }
    }
    @keyframes counterhackMsgGlitch{
      0%{ transform: translate3d(0,0,0) skewX(0deg); clip-path: inset(0 0 0 0); }
      18%{ transform: translate3d(2px,-1px,0) skewX(-2deg); clip-path: inset(0 0 58% 0); }
      36%{ transform: translate3d(-3px,1px,0) skewX(2.5deg); clip-path: inset(42% 0 0 0); }
      54%{ transform: translate3d(1px,0,0) skewX(-1.2deg); clip-path: inset(12% 0 28% 0); }
      72%{ transform: translate3d(-1px,-1px,0) skewX(1.8deg); clip-path: inset(26% 0 10% 0); }
      100%{ transform: translate3d(0,0,0) skewX(0deg); clip-path: inset(0 0 0 0); }
    }
    .screen-off::before{
      content:"";
      position:absolute;
      inset: 0;
      background:
        radial-gradient(circle at 50% 50%, rgba(var(--ssHot), .14), transparent 52%),
        linear-gradient(180deg, rgba(var(--ssHot), .10), transparent 40%, rgba(var(--ssHot), .08));
      mix-blend-mode: screen;
      opacity: .9;
      transform-origin: 50% 50%;
    }
    .screen-off.on::before{
      animation: screenPowerOff .72s cubic-bezier(.2,.9,.1,1) forwards;
    }
    @keyframes screenPowerOff{
      0%{ transform: scaleY(1) translate3d(0,0,0); filter: blur(0px); opacity: .95; }
      60%{ transform: scaleY(.06) translate3d(0,0,0); filter: blur(.35px); opacity: 1; }
      78%{ transform: scaleY(.012) translate3d(0,0,0); filter: blur(.55px); opacity: .95; }
      100%{ transform: scaleY(0) translate3d(0,0,0); filter: blur(.8px); opacity: 0; }
    }

    /* SecuroServ reboot UI inside the existing boot overlay */
    .boot-ss{
      display: none;
      margin-top: 14px;
      padding-top: 14px;
      border-top: 1px solid rgba(var(--ssHot), .22);
    }
    /* SecuroServ reboot starts as "code only" then reveals logo+bar */
    .boot.securosserv-reboot .boot-ss{
      display: block;
      opacity: 0;
      transform: translate3d(0,10px,0);
      transition: opacity .7s ease, transform .7s ease;
    }
    .boot.securosserv-reboot.ss-showbar .boot-ss{
      opacity: 1;
      transform: translate3d(0,0,0);
    }

    /* Background "code" writer layer (used during SecuroServ reboot) */
    .boot-bgcode{
      position: absolute;
      inset: 0;
      padding: 18px 18px 18px;
      font-size: 11px;
      letter-spacing: 1.6px;
      line-height: 1.25;
      white-space: pre;
      overflow: hidden;
      opacity: 0;
      pointer-events: none;
      color: rgba(var(--ssHot), .42);
      text-shadow: 0 0 10px rgba(var(--ssHot), .10);
      filter: blur(.15px);
    }
    .boot.securosserv-reboot .boot-bgcode{ opacity: .9; }

    /* Simplify SecuroServ reboot view: only logo+bar+bg code */
    .boot.securosserv-reboot{
      --bootBlack: 1;
      border: none !important;
    }
    .boot.securosserv-reboot .boot-inner{
      background: transparent;
      border-color: rgba(var(--ssHot), .22);
      box-shadow: none;
    }
    .boot.securosserv-reboot .boot-top,
    .boot.securosserv-reboot .boot-foot,
    .boot.securosserv-reboot .boot-lines,
    .boot.securosserv-reboot .boot-bar,
    .boot.securosserv-reboot .boot-meta{ display: none; }
    .boot.securosserv-reboot .boot-mid{ padding-top: 10px; }

    /* Opaque blackout phase (prevents seeing anything underneath)
       Implemented as a black overlay that can fade back to dark-blue. */
    .boot.blackout{
      --bootBlack: 1;
      border: none !important;
    }
    .boot.blackout .boot-inner{ opacity: 0; }
    .boot-ssLogo{
      width: 86px;
      height: 86px;
      display:block;
      margin: 4px auto 10px;
      filter: drop-shadow(0 0 16px rgba(var(--ssHot), .22));
      animation: bootSpin 1.58s linear infinite;
      opacity: .92;
    }
    @keyframes bootSpin{ to{ transform: rotate(360deg); } }
    .boot-ssBar{
      height: 18px;
      border: 1px solid rgba(var(--ssHot), .46);
      background: rgba(0,0,0,.55);
      position: relative;
      overflow: hidden;
    }
    .boot-ssFill{
      width: 0%;
      height: 100%;
      background: linear-gradient(90deg, rgba(var(--ss), .95), rgba(var(--ssHot), .95));
      box-shadow: 0 0 18px rgba(var(--ssHot), .22);
      transition: width .10s linear;
    }
    .boot-ssBar::after{
      content:"";
      position:absolute;
      inset: -40% -10%;
      background:
        repeating-linear-gradient(180deg, rgba(0,0,0,0) 0 7px, rgba(var(--ssHot), .09) 7px 8px),
        repeating-linear-gradient(90deg, rgba(var(--ssHot), .08) 0 1px, rgba(0,0,0,0) 1px 9px);
      mix-blend-mode: screen;
      opacity: .55;
      animation: midbarGlitch 1.05s steps(2) infinite;
    }
    .boot-ssMeta{
      margin-top: 10px;
      display:flex;
      justify-content: space-between;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1.2px;
      color: rgba(var(--ssHot), .70);
    }

    /* Header bar option */
    .securoserv-chaos .chaos-bar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      margin: -10px -12px 10px -12px;
      padding: 8px 12px;
      border-bottom: 1px solid rgba(var(--ssHot), .30);
      background: rgba(var(--ssHot), .10);
    }
    .securoserv-chaos .chaos-bar .tag{
      font-weight: 900;
      letter-spacing: 3.0px;
      text-transform: uppercase;
      color: rgba(var(--ssHot), .92);
    }
    .securoserv-chaos .chaos-bar .meta{
      font-size: 11px;
      letter-spacing: 2.0px;
      color: rgba(var(--ssHot), .70);
      text-transform: uppercase;
      white-space: nowrap;
      opacity: .95;
    }

    /* Dialog footer option */
    .securoserv-chaos .chaos-foot{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap: 10px;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(var(--ssHot), .22);
      color: rgba(var(--ssHot), .70);
      text-transform: uppercase;
      letter-spacing: 2.2px;
      font-size: 11px;
    }
    .securoserv-chaos .chaos-foot .btn{
      padding: 4px 8px;
      border: 1px solid rgba(var(--ssHot), .32);
      background: rgba(0,0,0,.35);
    }

    /* Terminal body block option */
    .securoserv-chaos .chaos-code{
      margin-top: 6px;
      padding: 8px 10px;
      border: 1px solid rgba(var(--ssHot), .22);
      background: rgba(0,0,0,.50);
      color: rgba(var(--ssHot), .74);
      white-space: pre;
      overflow: hidden;
      max-height: 220px;
    }
    .securoserv-chaos .chaos-pop.variant-small{
      min-width: 180px;
      max-width: min(360px, 62vw);
      padding: 8px 10px;
    }
    .securoserv-chaos .chaos-pop.variant-wide{
      min-width: 360px;
      max-width: min(780px, 86vw);
    }
    .securoserv-chaos .chaos-pop.variant-tall{
      min-height: 180px;
    }
    .securoserv-chaos .chaos-pop.variant-banner{
      min-width: 60vw;
      max-width: 92vw;
      padding: 10px 14px;
    }
    .securoserv-chaos .chaos-pop.variant-modal{
      min-width: min(560px, 84vw);
      max-width: min(860px, 92vw);
      padding: 14px 16px;
      border-width: 2px;
    }
    .securoserv-chaos .chaos-pop.cut{
      clip-path: polygon(
        0 0,
        calc(100% - 14px) 0,
        100% 14px,
        100% 100%,
        14px 100%,
        0 calc(100% - 14px)
      );
    }
    .securoserv-chaos .chaos-pop.scan::after{
      content:"";
      position:absolute;
      inset: 0;
      pointer-events:none;
      background:
        repeating-linear-gradient(
          180deg,
          rgba(var(--ssHot), .00) 0px,
          rgba(var(--ssHot), .00) 3px,
          rgba(var(--ssHot), .07) 4px
        );
      mix-blend-mode: screen;
      opacity: .6;
    }
    .securoserv-chaos .chaos-pop::before{
      content:"";
      position:absolute;
      left:0; right:0; top:0;
      height: 1px;
      background: rgba(var(--ss), 1);
      box-shadow: 0 0 18px rgba(var(--ssHot), .22);
      opacity: .85;
    }
    .securoserv-chaos .chaos-h{
      font-weight: 800;
      letter-spacing: 2.2px;
      text-transform: uppercase;
      color: rgba(var(--ssHot), .94);
      text-shadow: 0 0 12px rgba(var(--ssHot), .22);
      margin-bottom: 6px;
      line-height: 1.15;
    }
    .securoserv-chaos .chaos-pop.variant-modal .chaos-h{
      letter-spacing: 3.2px;
      font-size: 14px;
    }
    .securoserv-chaos .chaos-pop.variant-banner .chaos-h{
      letter-spacing: 3.0px;
    }
    .securoserv-chaos .chaos-b{
      font-size: 12px;
      line-height: 1.3;
      color: rgba(var(--ssHot), .78);
      white-space: pre-wrap;
    }
    .securoserv-chaos .chaos-pop.variant-small .chaos-b{ font-size: 11px; }
    .securoserv-chaos .chaos-pop.variant-modal .chaos-b{ font-size: 12px; line-height: 1.35; }
    .securoserv-chaos .chaos-pop.glitch{
      animation: securoservPopIn .45s ease both, securoservBoxGlitch 1.2s steps(2) infinite;
    }
    @keyframes securoservPopIn{
      from{ opacity: 0; transform: translate3d(0, 10px, 0) scale(.98); }
      to{ opacity: .92; transform: translate3d(0, 0, 0) scale(1); }
    }
    @keyframes securoservBoxGlitch{
      0%{ transform: translate3d(0,0,0); }
      12%{ transform: translate3d(1px,-1px,0); }
      24%{ transform: translate3d(-2px,0,0); }
      36%{ transform: translate3d(2px,1px,0); }
      48%{ transform: translate3d(-1px,1px,0); }
      60%{ transform: translate3d(0,-2px,0); }
      72%{ transform: translate3d(1px,0,0); }
      84%{ transform: translate3d(-1px,0,0); }
      100%{ transform: translate3d(0,0,0); }
    }

    .tip.glitch{
      animation: securoservTipGlitch .85s steps(2) infinite;
      text-shadow:
        0 0 10px rgba(var(--ssHot), .35),
        2px 0 0 rgba(var(--ss), .22),
        -2px 0 0 rgba(var(--ssHot), .18);
    }
    @keyframes securoservTipGlitch{
      0%{ transform: translateX(-50%) translateY(0); opacity: 1; }
      20%{ transform: translateX(calc(-50% + 1px)) translateY(-1px); }
      40%{ transform: translateX(calc(-50% - 2px)) translateY(1px); }
      60%{ transform: translateX(calc(-50% + 2px)) translateY(0); }
      80%{ transform: translateX(calc(-50% - 1px)) translateY(-1px); }
      100%{ transform: translateX(-50%) translateY(0); opacity: 1; }
    }

    .termline.glitch{
      position: relative;
      color: rgba(var(--ssHot), .86);
      text-shadow:
        0 0 10px rgba(var(--ssHot), .22),
        2px 0 0 rgba(var(--ss), .18),
        -2px 0 0 rgba(var(--ssHot), .12);
      animation: securoservTermGlitch .9s steps(2) infinite;
    }
    @keyframes securoservTermGlitch{
      0%{ transform: translate3d(0,0,0); }
      25%{ transform: translate3d(1px,0,0); }
      50%{ transform: translate3d(-2px,0,0); }
      75%{ transform: translate3d(2px,0,0); }
      100%{ transform: translate3d(0,0,0); }
    }
    .restricted-overlay::before{
      content:"";
      position:absolute;
      top: -20px;
      left: -20px;
      right: -20px;
      bottom: -20px;
      background:
        radial-gradient(circle at 50% 0%, rgba(var(--restrictedRGB), .34), transparent 45%),
        radial-gradient(circle at 50% 100%, rgba(var(--restrictedRGBHot), .28), transparent 45%),
        radial-gradient(circle at 0% 50%, rgba(var(--restrictedRGB), .24), transparent 40%),
        radial-gradient(circle at 100% 50%, rgba(var(--restrictedRGBHot), .24), transparent 40%);
      filter: blur(16px);
      opacity: .55;
      mix-blend-mode: screen;
      pointer-events:none;
      z-index:-1;
    }
    .restricted-overlay::after{
      content:"";
      position:absolute;
      top: calc(var(--topbar-h) + 4px);
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 0;
      border: none;
      background:
        linear-gradient(0deg, rgba(var(--restrictedRGB), .14), transparent 40%),
        linear-gradient(90deg, rgba(var(--restrictedRGB), .14), transparent 60%);
      box-shadow:
        0 0 42px rgba(var(--restrictedRGB), .32),
        0 0 80px rgba(var(--restrictedRGBHot), .22);
      opacity: .6;
      pointer-events:none;
      mix-blend-mode: screen;
      z-index:-1;
    }
    .restricted-overlay .restricted-message{
      position:relative;
      color: rgba(var(--restrictedTextRGB), .95);
      font-size: clamp(20px, 3vw, 38px);
      letter-spacing: 6px;
      text-transform: uppercase;
      font-weight: 700;
      line-height: 1.15;
      text-align:center;
      text-shadow:
        0 0 12px rgba(var(--restrictedTextRGB), .9),
        0 0 26px rgba(var(--restrictedRGBHot), .55),
        0 0 46px rgba(var(--restrictedRGBHot), .35);
      filter: drop-shadow(0 0 26px rgba(var(--restrictedRGB), .55));
      animation: restrictedPulse 2.5s ease-in-out infinite;
      z-index: 1;
    }
    @keyframes restrictedPulse{
      0%{ transform: translate3d(0, 0, 0) scale(1); opacity:.92; }
      40%{ transform: translate3d(0, -6px, 0) scale(1.04); opacity:1; }
      100%{ transform: translate3d(0, 0, 0) scale(1); opacity:.92; }
    }
    @keyframes restrictedScan{
      from{ transform: translateY(-100%); }
      to{ transform: translateY(100%); }
    }
    #svgHost .region.dimmed{ opacity: .14; }
    #svgHost .region.hidden{ display: none !important; }

    /* In outline-only mode, never boost opacity or add glow for "dimmed" regions.
       The base/hover/selected stroke-opacity ramps handle visibility. */
    #svgHost.dimmedOthers .region:not(.selected):not(.wall){
      opacity: 1 !important;
      filter: none !important;
    }

    /* WALLS: no fill, slightly stronger outline */
    #svgHost .wall, #svgHost .wall *{
      fill: none !important;
      stroke: rgba(96,143,255,.85) !important;      /* default wall color (blue) */
      stroke-width: var(--sw-wall) !important;
      vector-effect: non-scaling-stroke !important;
      stroke-linecap: square !important;
      stroke-linejoin: miter !important;
      opacity: .95 !important;
      pointer-events: none !important;

      /* subtle barrier glow */
      filter:
        drop-shadow(0 0 8px rgba(96,143,255,.14)) !important;
    }

    /* Wasteline labels layer */
    #svgHost #wastelineLabelsLayer{
      pointer-events: none !important;
      opacity: 1 !important;
      filter: none !important;
    }

    /* THE WASTELINE: thick solid transparent yellow line */
    #svgHost #THE_WASTELINE, #svgHost #THE_WASTELINE *{
      fill: none !important;
      stroke: var(--yl) !important;
      stroke-width: 6px !important;
      stroke-opacity: 1 !important;
      vector-effect: non-scaling-stroke !important;
      stroke-linecap: square !important;
      stroke-linejoin: miter !important;
      opacity: 1 !important;
      pointer-events: none !important;
      filter:
        drop-shadow(0 0 6px rgba(0,0,0,.9))
        drop-shadow(0 0 16px rgba(var(--ylRGB), .35)) !important;
    }

    /* Wasteline labels at ends */
    .wastelineEndLabel{
      font-family: "Rajdhani", sans-serif;
      font-weight: 900;
      text-transform: uppercase;
      letter-spacing: 4px;
      pointer-events: none;
      filter:
        drop-shadow(0 0 6px rgba(0,0,0,.9));
    }
    .wastelineEndLabel.title{
      font-size: 28px;
      fill: var(--yl);
      filter:
        drop-shadow(0 0 6px rgba(0,0,0,.9))
        drop-shadow(0 0 16px rgba(var(--ylRGB), .35));
    }
    .wastelineEndLabel.sub{
      font-size: 26px;
      fill: var(--ui);
      opacity: 0.55;
      filter:
        drop-shadow(0 0 6px rgba(0,0,0,.9))
        drop-shadow(0 0 14px rgba(96,143,255,.22));
    }

    /* Wasteline marquee (textPath along the line) */
    #svgHost #wastelineMarqueeLayer .wastelineMarqueeText{
      font-weight: 900;
      letter-spacing: 10px;
      font-size: 32px;
      fill: var(--yl) !important;
      stroke: none !important;
      stroke-width: 0 !important;
      opacity: 1;
      filter:
        drop-shadow(0 0 3px rgba(0,0,0,.95))
        drop-shadow(0 0 26px rgba(0,0,0,.85))
        drop-shadow(0 0 18px rgba(var(--ylRGB), .12)) !important;
    }
    /* Ensure no stroke and correct fill on marquee descendants (wall rules can override) */
    #svgHost #wastelineMarqueeLayer .wastelineMarqueeText, #svgHost #wastelineMarqueeLayer .wastelineMarqueeText *{
      fill: var(--yl) !important;
      stroke: none !important;
      stroke-width: 0 !important;
    }

    /* PERFORMANCE OPTIMIZATIONS */
    /* Transform now applies to #mapStack; svgHost renders regions only */

    /* =======================
       BOOT LOADING OVERLAY
       ======================= */
    .boot{
      position: fixed;
      inset: 0;
      z-index: 9999;
      display: grid;
      place-items: center;
      isolation: isolate;
      --bootBlack: 0;
      background:
        radial-gradient(900px 600px at 30% 20%, rgba(96,143,255,.18), transparent 60%),
        radial-gradient(700px 500px at 70% 70%, rgba(var(--ylRGB), .10), transparent 62%),
        linear-gradient(180deg, rgba(3,5,12,.95), rgba(6,10,22,.92));
      border-top: 2px solid rgba(var(--ylRGB), .55);
      border-bottom: 2px solid rgba(96,143,255,.35);
      opacity: 1;
      transition: opacity .6s ease;
    }
    .boot::before{
      content:"";
      position:absolute;
      inset: 0;
      background: #000;
      opacity: var(--bootBlack, 0);
      transition: opacity .8s ease;
      pointer-events:none;
      z-index: 0;
    }
    .boot-inner{
      width: min(760px, calc(100vw - 40px));
      border: 1px solid rgba(96,143,255,.25);
      background: rgba(6,10,22,.72);
      box-shadow: var(--glowB);
      position: relative;
      overflow: hidden;
      z-index: 1;
      transform: translate3d(0,0,0) scale(1);
      filter: blur(0);
      transition: opacity .45s ease, transform .55s ease, filter .55s ease;
    }
    .boot-inner::before{
      content:"";
      position:absolute; inset:-1px;
      border: 1px solid rgba(96,143,255,.12);
      pointer-events:none;
    }
    .boot-inner::after{
      content:"";
      position:absolute; left:-1px; top:-1px;
      width: 18px; height: 18px;
      border-left: 2px solid var(--yl);
      border-top: 2px solid var(--yl);
      opacity:.75;
      pointer-events:none;
    }
    .boot-top{
      padding: 14px 16px 10px;
      border-bottom: 1px solid rgba(96,143,255,.25);
      display: grid;
      gap: 6px;
      text-transform: uppercase;
      letter-spacing: 1.2px;
    }
    .boot-tag{
      display:inline-block;
      width: fit-content;
      padding: 4px 10px;
      background: var(--yl);
      color: #0a1024;
      box-shadow: var(--glowY);
      font-size: 12px;
    }
    .boot-title{ font-size: 14px; color: rgba(96,143,255,.95); }
    .boot-sub{ font-size: 12px; color: rgba(215,230,255,.62); }
    .boot-mid{ padding: 14px 16px 16px; }
    .boot-lines{
      height: 220px;
      border: 1px solid rgba(var(--ylRGB), .18);
      background: rgba(4,7,16,.45);
      overflow: hidden;
      padding: 10px 12px;
      font-family: inherit;
      font-size: 12px;
      line-height: 1.35;
      color: rgba(var(--ylRGB), .85);
    }
    .boot-line{ opacity:.92; padding: 2px 0; }
    .boot-line.dim{ opacity:.65; color: rgba(215,230,255,.55); }
    .boot-bar{
      margin-top: 12px;
      height: 10px;
      border: 1px solid rgba(var(--ylRGB), .25);
      background: rgba(4,7,16,.35);
      overflow:hidden;
    }
    .boot-bar-fill{
      width: 0%;
      height: 100%;
      background: rgba(var(--ylRGB), .85);
      box-shadow: var(--glowY);
      transition: width .18s linear;
    }
    .boot-meta{
      margin-top: 10px;
      display:flex;
      justify-content: space-between;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1.2px;
      color: rgba(215,230,255,.65);
    }
    #bootPct{ color: var(--yl); }
    .boot-foot{
      padding: 10px 16px;
      border-top: 1px solid rgba(96,143,255,.25);
      display:flex;
      justify-content: space-between;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1.2px;
      color: rgba(215,230,255,.55);
    }
    .boot.softclose .boot-inner{
      opacity: 0;
      transform: translate3d(0,10px,0) scale(.985);
      filter: blur(.6px);
    }
    .boot.off{ opacity: 0; }
    .boot.hidden{ display:none; }
  </style>
</head>
<body>
  <!-- TOP TABS -->
  <header class="topnav" aria-label="Top navigation">
    <div class="topmeta left" aria-hidden="true">
      <div class="metaGroup"><span class="metaDot"></span><span class="metaText">POLICE</span></div>
      <div class="metaGroup"><span class="metaDot red"></span><span class="metaText red">SERGEANT</span></div>
    </div>
    <div class="tabs" role="tablist" aria-label="Menu">
      <button class="tab disabled" data-view="settings" role="tab" aria-selected="false" tabindex="-1" aria-disabled="true"><span>SETTINGS</span></button>
      <button class="tab on" data-view="map" role="tab" aria-selected="true"><span>MAP</span></button>
      <button class="tab disabled" data-view="inventory" role="tab" aria-selected="false" tabindex="-1" aria-disabled="true"><span>INVENTORY</span></button>
      <button class="tab disabled" data-view="augments" role="tab" aria-selected="false" tabindex="-1" aria-disabled="true"><span>AUGMENTS</span></button>
      <button class="tab tab-lore" data-view="lore" role="tab" aria-selected="false" tabindex="-1"><span>LORE TERMINAL</span></button>
    </div>
    <div class="topmeta right" aria-hidden="true">
      <div class="metaStat"><span class="metaIcon" aria-hidden="true"></span><span>200/100</span></div>
      <div class="metaStat yl"><span class="metaIcon" aria-hidden="true"></span><span>2000</span></div>
    </div>
  </header>

  <!-- Quick loading overlay for smooth view switches -->
  <div class="quickload" id="quickLoad" aria-hidden="true">
    <div class="inner">
      <div class="label">LOADING</div>
      <div class="bar"><div class="fill" id="quickLoadFill"></div></div>
    </div>
  </div>

  <!-- MAIN STAGE -->
  <div class="stage">
    <!-- MAP (full page) -->
    <main class="mapstage">
      <div class="maphud">

        <div class="hudfilters" id="hudFilters">
          <button class="hudf" id="btnShowAllDistricts">SHOW ALL DISTRICTS</button>
          <button class="hudf" id="btnRestricted">RESTRICTED ZONE</button>
          <button class="hudf" id="btnHideAll">HIDE ALL DISTRICTS</button>
        </div>
      </div>

      <div class="mapwrap">
        <div id="mapStack">
          <img id="layerOcean" draggable="false" />
          <img id="layerLand" draggable="false" />
          <img id="layerBuildings" draggable="false" />
          <img id="layerRoads" draggable="false" />
          <div id="restrictedBlurLayer" aria-hidden="true">
            <svg id="restrictedBlurSvg" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="none" aria-hidden="true"></svg>
          </div>
          <div id="svgHost"></div>
          <div id="logosLayer"></div>
          <div id="markersLayer" aria-hidden="true"></div>
          <div id="labelsLayer"></div>
        </div>
        <div class="tip" id="tooltip"></div>
        <img id="cursorLogo" class="cursorLogo" draggable="false" alt="" />
        <div id="zoomBar" class="zoomBar" aria-hidden="true">
          <div id="zoomReadout" class="zoomReadout">100%</div>
          <div class="fill up" id="zoomFillUp"></div>
          <div class="fill down" id="zoomFillDown"></div>
        </div>
      </div>

      <div class="securserve-badge" id="securserveBadge" aria-hidden="true">
        <img src="./logos/SS.png" alt="" draggable="false" onerror="this.onerror=null; this.src='./logos/SS.png';" />
      </div>
    </main>

    <!-- INVENTORY (disabled / removed) -->
    <main class="inventorystage" id="inventoryStage" aria-hidden="true"></main>

    <!-- LORE TERMINAL (full page) -->
    <main class="lorestage" id="loreStage" aria-hidden="true">
      <div class="loreInner" id="loreInner" aria-label="Neon City history archive">
        <div class="loreHead">
          <div class="loreTitle">NE0N CITY :: HIST0RY ARCHIVE</div>
          <div class="loreSub">[RECOVERED_DATASET // PARTIAL_INTEGRITY]</div>
        </div>
        <div class="loreScroll" id="loreScroll" aria-label="Lore log">
          <pre class="loreCode" id="loreCode" aria-label="Archive data"></pre>
        </div>
      </div>
    </main>
    <div class="restricted-overlay" id="restrictedOverlay" aria-hidden="true">
      <div class="restricted-message">WARNING:// RESTRICTED AREA SELECTED</div>
    </div>

    <svg class="securoserv-wall" id="securoservWall" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="none" aria-hidden="true"></svg>
    <div class="securoserv-chaos" id="securoservChaos" aria-hidden="true"></div>
    <div class="screen-glitch" id="screenGlitch" aria-hidden="true"></div>

    <div class="securoserv-midbar" id="securoservMidbar" aria-hidden="true">
      <div class="frame">
        <div class="label">SYNC:// SECUROSERV COUNTERMEASURES</div>
        <div class="bar"><div class="fill" id="securoservMidbarFill"></div></div>
        <div class="meta"><span id="securoservMidbarPct">0%</span><span>COUNTERMEASURES ACTIVE</span></div>
      </div>
    </div>
    <div class="input-blocker" id="inputBlocker" aria-hidden="true"></div>

    <!-- USER COUNTERHACK WINDOW (separate from red system UI) -->
    <div class="counterhack-win" id="securoservChallenge" aria-hidden="true">
      <div class="frame" role="status" aria-live="polite">
        <div class="label">USER OVERRIDE:// COUNTERHACK</div>
        <div class="instr"><span>TYPE THE SYMBOLS LEFT â†’ RIGHT</span><span>SYMBOLS SHIFT EVERY 2S</span></div>
        <div class="slots" aria-label="Bypass code">
          <div class="slot" id="ssSlot0">?</div>
          <div class="slot" id="ssSlot1">?</div>
          <div class="slot" id="ssSlot2">?</div>
          <div class="slot" id="ssSlot3">?</div>
          <div class="slot" id="ssSlot4">?</div>
          <div class="slot" id="ssSlot5">?</div>
        </div>
        <div class="hint"><span>COUNTERMEASURES PAUSED ON SUCCESS</span><span>ESC DISABLED</span></div>
      </div>
    </div>

    <div class="counterhack-fx" id="counterhackFx" aria-hidden="true">
      <div class="msg">COUNTERHACK SUCCESFULL</div>
    </div>
    <div class="screen-off" id="screenOff" aria-hidden="true"></div>
  </div>

  <!-- LEFT DISTRICT MENU (replaces the 3 HUD buttons) -->
  <nav class="sidemenu" aria-label="District filters">
    <div class="sidemenu-row">
      <button class="arrow" id="menuPrev" type="button" aria-label="Previous filter"><span>â€¹</span></button>
      <div class="tabs" role="tablist" aria-label="District filters">
        <button class="tab on" id="menuShowAll" type="button" role="tab" aria-selected="true" title="Show all zones" aria-label="Show all zones"><span>SHOW ALL</span></button>
        <button class="tab" id="menuRestricted" type="button" role="tab" aria-selected="false" title="Only restricted zones" aria-label="Only restricted zones"><span>RESTRICTED</span></button>
        <button class="tab" id="menuHideAll" type="button" role="tab" aria-selected="false" title="Hide all zones" aria-label="Hide all zones"><span>HIDE ALL</span></button>
      </div>
      <button class="arrow" id="menuNext" type="button" aria-label="Next filter"><span>â€º</span></button>
    </div>

  </nav>

  <!-- LAYER TOGGLES (free-floating, beneath the left menu) -->
  <div class="layerToggles" id="layerToggles" role="group" aria-label="Layer visibility">
    <button class="layerToggle" id="toggleRoads" type="button" aria-pressed="false">
      <span class="layerToggle-icon" aria-hidden="true"></span>
      <span>HIDE ROADS</span>
    </button>
    <button class="layerToggle" id="toggleBuildings" type="button" aria-pressed="false">
      <span class="layerToggle-icon" aria-hidden="true"></span>
      <span>HIDE BUILDINGS</span>
    </button>
    <button class="layerToggle" id="toggleMarkers" type="button" aria-pressed="false">
      <span class="layerToggle-icon" aria-hidden="true"></span>
      <span>HIDE MARKERS</span>
    </button>
  </div>

  <!-- AREA DETAILS (POPUP WINDOW) -->
  <section class="hudpopup" id="popupDetails" aria-live="polite">
    <svg viewBox="0 0 600 420" class="pdSvg" preserveAspectRatio="none" aria-hidden="true" focusable="false">
      <defs>
        <pattern id="pdScanlines" width="12" height="12" patternUnits="userSpaceOnUse">
          <rect x="0" y="0" width="12" height="1" class="pdScan" />
        </pattern>
      </defs>
      <polygon class="pdOutline" points="18,2 582,2 598,18 598,402 582,418 2,418 2,18" />
      <polygon class="pdFill" points="26,10 574,10 590,26 590,394 574,410 10,410 10,26" />
      <polygon class="pdLines" points="26,10 574,10 590,26 590,394 574,410 10,410 10,26" />
    </svg>
    <div class="hudhead">
      <span class="hudtitle">AREA DETAILS</span>
      <div class="hudhead-actions">
        <span class="hudmeta" id="detailState">NO TARGET</span>
        <button class="hudbtn hudbtn-x" id="btnCloseDetails" title="Close">X</button>
      </div>
    </div>

    <div class="hudbody details">
      <div class="dHeader">
        <div class="dKV">
          <div class="dRow"><div class="dK">NAME</div><div class="dV" id="dName">â€”</div></div>
          <div class="dRow"><div class="dK">ID</div><div class="dV" id="dId">â€”</div></div>
          <div class="dRow"><div class="dK">TYPE</div><div class="dV" id="dType">â€”</div></div>
          <div class="dRow"><div class="dK">ZONE</div><div class="dV" id="dZone">â€”</div></div>
          <div class="dRow"><div class="dK">BOUNDS</div><div class="dV" id="dBounds">â€”</div></div>
        </div>
        <div class="dMedia" aria-hidden="true">
          <img id="detailLogo" alt="" draggable="false" />
        </div>
      </div>

      <div class="dSep"></div>

      <div class="dActions"></div>

      <div class="dLore">
        <div class="dK" style="margin-bottom:6px;">LORE / NOTES</div>
        <div class="dNoteText" id="dNotes"></div>
      </div>
    </div>

    <div class="hudfoot">
      <span>MAP/INTEL</span>
      <div id="detailFoot"><div class="intelDim">waiting</div></div>
    </div>
  </section>

  <!-- RESTRICTED HACK PROMPT (shown next to Area Details) -->
  <div class="hackPrompt" id="hackPrompt" aria-hidden="true">
    <button class="btn" id="btnHackRestricted" type="button">
      <svg viewBox="-3 -3 606 126" class="bpSvg" preserveAspectRatio="none" aria-hidden="true" focusable="false">
        <defs>
          <pattern id="bpScanlines" width="12" height="12" patternUnits="userSpaceOnUse">
            <rect x="0" y="0" width="12" height="1" class="bpScan" />
          </pattern>
        </defs>
        <!-- outer outline (reference shape: top-left tab + angled bottom-left + right chamfer) -->
        <polygon class="bpOutline" points="0,0 168,0 226,40 594,40 600,46 600,106 572,120 92,120 46,82 0,82" />
        <!-- main interior fill -->
        <polygon class="bpFill" points="3,3 165,3 223,43 591,43 597,49 597,103 569,117 95,117 49,79 3,79" />
        <!-- subtle scanlines overlay inside fill -->
        <polygon class="bpLines" points="3,3 165,3 223,43 591,43 597,49 597,103 569,117 95,117 49,79 3,79" />
        <!-- top-left tab overlay (separate color) + separator and tag text -->
        <polygon class="bpTab" points="0,0 168,0 226,40 0,40" />
        <path class="bpTabSep" d="M0 40 H226 M168 0 L226 40" />
        <text class="bpTagText" x="12" y="30">SIMPLEHACK</text>
      </svg>

      <span class="bpContent">
        <span class="bpTitle">BREACH PROTOCOL</span>
        <span class="bpStatus">READY</span>
      </span>
    </button>
  </div>

  <!-- COMMAND FEED (BOTTOM-LEFT) -->
  <div class="cmdFeed" id="cmdFeed" aria-live="polite" aria-label="Command feed"></div>

  <!-- BOOT OVERLAY -->
  <div class="boot" id="boot">
    <div class="boot-inner">
      <div class="boot-bgcode" id="bootBgCode" aria-hidden="true"></div>
      <div class="boot-top">
        <div class="boot-tag">NETRUN</div>
        <div class="boot-title">INITIALIZING MAP INTERFACE</div>
        <div class="boot-sub">SUBSYSTEM: LS-GRID â€¢ ACCESS LEVEL: LOCAL</div>
      </div>

      <div class="boot-mid">
        <div class="boot-lines" id="bootLines" aria-live="polite"></div>

        <div class="boot-bar">
          <div class="boot-bar-fill" id="bootFill"></div>
        </div>

        <div class="boot-meta">
          <span id="bootPct">0%</span>
          <span id="bootPhase">handshake</span>
        </div>

        <div class="boot-ss" id="bootSecuroserv" aria-hidden="true">
            <img class="boot-ssLogo" id="bootSecuroLogo" src="./logos/SS2.png" alt="" draggable="false" onerror="this.onerror=null; this.src='./logos/SS2.png';" />
          <div class="boot-ssBar"><div class="boot-ssFill" id="bootSecuroFill"></div></div>
          <div class="boot-ssMeta"><span id="bootSecuroPct">0%</span><span id="bootSecuroPhase">reboot</span></div>
        </div>
      </div>

      <div class="boot-foot">
        <span>PRESS ANY KEY: DISABLED</span>
        <span id="bootHint">LINK STABLE</span>
      </div>
    </div>
  </div>

  <script>
    /**
     * CONFIG
     * Put your SVG file next to this HTML and name it "map.svg", or change this path.
     */
    const SVG_URL = "./REGIONS.svg";
    const LAYERS = {
      ocean: "./FINAL OCEAN.webp",
      land: "./FINAL LAND.webp",
      buildings: "./FINAL BUILDINGS.webp",
      roads: "./FINAL ROADS.webp",
    };

    // Ensure SecuroServ overlays are not trapped under other fixed UI stacking contexts.
    // Hoisting them to <body> makes their z-index consistently cover the left menu/toggles
    // and allows the input blocker to actually intercept clicks.
    function hoistToBody(id){
      const el = document.getElementById(id);
      if(!el) return;
      if(el.parentElement === document.body) return;
      try{ document.body.appendChild(el); }catch{}
    }
    function hoistSecuroservOverlays(){
      [
        "securoservWall",
        "securoservChaos",
        "screenGlitch",
        "securoservMidbar",
        "inputBlocker",
        "securoservChallenge",
        "counterhackFx",
        "screenOff",
      ].forEach(hoistToBody);
    }
    hoistSecuroservOverlays();
    // Load raster layers
    document.getElementById("layerOcean").src = LAYERS.ocean;
    document.getElementById("layerLand").src = LAYERS.land;
    document.getElementById("layerBuildings").src = LAYERS.buildings;
    document.getElementById("layerRoads").src = LAYERS.roads;

    function ensureRestrictedBlurSvg(){
      const svg = document.getElementById("restrictedBlurSvg");
      if(!svg) return null;

      // One-time build
      if(svg.querySelector("defs")) return svg;

      const NS = "http://www.w3.org/2000/svg";
      const defs = document.createElementNS(NS, "defs");

      const filter = document.createElementNS(NS, "filter");
      filter.setAttribute("id", "restrictedBlurFilter");
      filter.setAttribute("x", "-12%");
      filter.setAttribute("y", "-12%");
      filter.setAttribute("width", "124%");
      filter.setAttribute("height", "124%");
      const blur = document.createElementNS(NS, "feGaussianBlur");
      blur.setAttribute("stdDeviation", "3.2");
      filter.appendChild(blur);
      defs.appendChild(filter);

      const clip = document.createElementNS(NS, "clipPath");
      clip.setAttribute("id", "restrictedBlurClip");
      clip.setAttribute("clipPathUnits", "userSpaceOnUse");
      defs.appendChild(clip);

      svg.appendChild(defs);

      const g = document.createElementNS(NS, "g");
      g.setAttribute("id", "restrictedBlurGroup");
      g.setAttribute("clip-path", "url(#restrictedBlurClip)");
      g.setAttribute("filter", "url(#restrictedBlurFilter)");

      const mkImg = (key, href) => {
        const im = document.createElementNS(NS, "image");
        im.setAttribute("data-blur-layer", key);
        im.setAttribute("x", "0");
        im.setAttribute("y", "0");
        im.setAttribute("preserveAspectRatio", "none");
        if(href) im.setAttribute("href", href);
        return im;
      };
      g.appendChild(mkImg("ocean", LAYERS.ocean));
      g.appendChild(mkImg("land", LAYERS.land));
      g.appendChild(mkImg("buildings", LAYERS.buildings));
      g.appendChild(mkImg("roads", LAYERS.roads));
      svg.appendChild(g);
      return svg;
    }

    function rebuildRestrictedBlurClip(){
      const blurLayer = document.getElementById("restrictedBlurLayer");
      const blurSvg = ensureRestrictedBlurSvg();
      const clip = blurSvg?.querySelector?.("#restrictedBlurClip");
      if(!blurLayer || !blurSvg || !clip || !svgEl){
        if(blurLayer) blurLayer.classList.remove("on");
        return;
      }

      clip.replaceChildren();

      // Blur all restricted regions EXCEPT those explicitly unlocked via generic hacks.
      const candidates = Array.from(svgEl.querySelectorAll(".region.restricted:not(.wall):not(.hidden)"))
        .filter((src) => {
          const k = normalizeRegionKey(src?.id || src?.getAttribute?.("data-name") || "");
          if(!k) return true;
          // SecuroServ: keep blurred until *fully* unlocked (post-counterhack second-stage hack).
          if(isSecuroservKey(k)) return !(securoservBypassedThisSession && unlockedRestrictedIntel.has(k));
          return !unlockedRestrictedIntel.has(k);
        });
      for(const src of candidates){
        try{
          const clone = src.cloneNode(true);
          clone.removeAttribute?.("style");
          clone.removeAttribute?.("filter");
          clone.removeAttribute?.("mask");
          clone.removeAttribute?.("clip-path");
          clone.removeAttribute?.("opacity");
          clone.removeAttribute?.("stroke");
          clone.removeAttribute?.("fill");

          const m = src?.getCTM?.();
          clone.removeAttribute?.("transform");
          if(m){
            clone.setAttribute?.("transform", `matrix(${m.a} ${m.b} ${m.c} ${m.d} ${m.e} ${m.f})`);
          }
          clip.appendChild(clone);
        }catch(e){
          // ignore bad shapes
        }
      }

      blurLayer.classList.toggle("on", clip.childNodes.length > 0);
    }

    function syncRestrictedBlurLayerSources(){
      const svg = ensureRestrictedBlurSvg();
      if(!svg) return;
      const set = (key, href) => {
        const im = svg.querySelector(`image[data-blur-layer='${key}']`);
        if(im) im.setAttribute("href", href);
      };
      set("ocean", LAYERS.ocean);
      set("land", LAYERS.land);
      set("buildings", LAYERS.buildings);
      set("roads", LAYERS.roads);
    }
    syncRestrictedBlurLayerSources();

    // BOOT CONTROLLER
    const boot = {
      el: document.getElementById("boot"),
      linesEl: document.getElementById("bootLines"),
      fillEl: document.getElementById("bootFill"),
      pctEl: document.getElementById("bootPct"),
      phaseEl: document.getElementById("bootPhase"),
      hintEl: document.getElementById("bootHint"),
    };

    function bootLine(text, dim=false){
      if(!boot.linesEl) return;
      const div = document.createElement("div");
      div.className = "boot-line" + (dim ? " dim" : "");
      div.textContent = text;
      boot.linesEl.appendChild(div);
      boot.linesEl.scrollTop = boot.linesEl.scrollHeight;
    }

    function bootSet(pct, phase){
      pct = Math.max(0, Math.min(100, pct));
      if(boot.fillEl) boot.fillEl.style.width = pct + "%";
      if(boot.pctEl) boot.pctEl.textContent = Math.round(pct) + "%";
      if(boot.phaseEl) boot.phaseEl.textContent = phase || "";
    }

    function bootClose(){
      if(!boot.el) return;
      boot.el.classList.add("softclose");
      setTimeout(() => {
        boot.el.classList.add("off");
      }, 120);
      setTimeout(() => {
        boot.el.classList.add("hidden");
        boot.el.classList.remove("softclose");
      }, 760);
    }

    function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

    async function startBoot(){
      bootSet(0, "handshake");
      bootLine("[BOOT] initializing runtimeâ€¦");
      await sleep(180);

      bootSet(12, "handshake");
      bootLine("[NET] link stable â€¢ encryption ok");
      await sleep(220);

      bootSet(25, "auth");
      bootLine("[AUTH] credentials verified â€¢ LS-07");
      await sleep(220);

      bootSet(40, "mount");
      bootLine("[FS] mounting local assetâ€¦");
      await sleep(220);

      bootSet(55, "request");
      bootLine(`[SVG] requesting payload: ${SVG_URL}`);
      bootLine("[SVG] awaiting payload streamâ€¦", true);

      // start actual load
      loadSvg();
    }

    // State
    let svgEl = null;
    let selectedEl = null;
    let hoveredEl = null;

    let securoservChaosTimer = null;
    let securoservTooltipTimer = null;
    let securoservEscalationTimer = null;
    let securoservMidbarDelayTimer = null;
    let securoservMidbarTickTimer = null;
    let securoservChallengeShuffleTimer = null;
    let securoservChallengeActive = false;
    let securoservChallengeSolved = false;
    let securoservChallengeIndex = 0;
    let securoservChallengeSymbols = [];
    let securoservChallengeRevealPct = 0.20;
    let securoservChallengeRevealed = false;
    let securoservMidbarProgress = 0;
    let securoservSecretStreak = 0;
    let securoservShutdownInProgress = false;
    let securoservRebootTriggered = false;
    let securoservCounterhackResolving = false;
    let securoservSuccessDelayTimer = null;
    // After a successful counterhack, disable all SecuroServ hack effects for the rest of
    // the session (until the page is manually refreshed).
    let securoservBypassedThisSession = false;
    let counterhackFxOffTimer = null;
    let bootBgCodeTimer = null;

    const SECUROSERV_CHAOS_MAX = 34;

    // Labels are currently disabled (names hidden).
    const SHOW_LABELS = false;

    const missingDistrictLogos = new Set();
    let selectionGlowFilter = null;
    let selectionGlowAnimation = null;

    function term(msg, opts = null){
      // Text-only bottom-left feed (no terminal panel)
      const feed = document.getElementById("cmdFeed");
      if(feed){
        const div = document.createElement("div");
        div.className = "cmdline";
        div.textContent = msg;
        if(opts && opts.glitch) div.classList.add("glitch");

        feed.appendChild(div);
        // trigger entrance transition
        requestAnimationFrame(() => div.classList.add("on"));

        // Keep only a small stack visible
        const MAX_LINES = 10;
        while(feed.childElementCount > MAX_LINES){
          feed.removeChild(feed.firstElementChild);
        }

        // Auto-expire
        const lifeMs = 5200;
        const fadeMs = 650;
        setTimeout(() => div.classList.add("off"), Math.max(0, lifeMs - fadeMs));
        setTimeout(() => { try{ div.remove(); }catch{} }, lifeMs);
        return;
      }

      // Legacy fallback (in case a future edit re-adds it)
      const log = document.getElementById("termLog");
      if(log){
        const div = document.createElement("div");
        div.className = "termline";
        div.textContent = msg;
        if(opts && opts.glitch) div.classList.add("glitch");
        log.appendChild(div);
        log.scrollTop = log.scrollHeight;
      }
    }

    // =========================
    // AREA NOTES (READ-ONLY)
    // =========================
    // Replace these TEMPLATE lines with your own intel.
    // Notes only render if a non-empty entry exists for the selected area.
    const AREA_NOTES = {
      APEX_HQ: "TEMPLATE APEX_HQ â€” Corporate command node; replace intel.",
      DISTRICT_HARMONY: "TEMPLATE DISTRICT_HARMONY â€” Residential/market district; replace intel.",
      HUMANE_LABS: "TEMPLATE HUMANE_LABS â€” Research site with restricted access; replace intel.",
      LA_PUERTA: "TEMPLATE LA_PUERTA â€” Industrial/harbor-adjacent zone; replace intel.",
      LITTLE_SOEUL: "TEMPLATE LITTLE_SOEUL â€” Neon retail blocks; replace intel.",
      MERRYWEATHER_BASE: "TEMPLATE MERRYWEATHER_BASE â€” Private military installation; replace intel.",
      MERRYWEATHER_PORT: "TEMPLATE MERRYWEATHER_PORT â€” Secured port logistics; replace intel.",
      MIRROR_HILLS: "TEMPLATE MIRROR_HILLS â€” Hillside housing sector; replace intel.",
      NEON_CITY_NATIONAL_AIRPORT: "TEMPLATE NEON_CITY_NATIONAL_AIRPORT â€” Air traffic hub; replace intel.",
      NEON_CITY_PORTS: "TEMPLATE NEON_CITY_PORTS â€” Cargo docks & transit lanes; replace intel.",
      NEON_CITY_PRISON: "TEMPLATE NEON_CITY_PRISON â€” Restricted detention complex; replace intel.",
      NEON_CORE: "TEMPLATE NEON_CORE â€” Central metro/core district; replace intel.",
      PACIFIC_BLUFFS: "TEMPLATE PACIFIC_BLUFFS â€” Coastal luxury zone; replace intel.",
      PALAMINO_LANDS: "TEMPLATE PALAMINO_LANDS â€” Rural outskirts; replace intel.",
      PATH1: "TEMPLATE PATH1 â€” Replace this area intel.",
      PATH104: "TEMPLATE PATH104 â€” Replace this area intel.",
      PATH14: "TEMPLATE PATH14 â€” Replace this area intel.",
      PATH18: "TEMPLATE PATH18 â€” Replace this area intel.",
      PATH19: "TEMPLATE PATH19 â€” Replace this area intel.",
      PATH2: "TEMPLATE PATH2 â€” Replace this area intel.",
      PATH20: "TEMPLATE PATH20 â€” Replace this area intel.",
      PATH21: "TEMPLATE PATH21 â€” Replace this area intel.",
      PATH3: "TEMPLATE PATH3 â€” Replace this area intel.",
      PATH4: "TEMPLATE PATH4 â€” Replace this area intel.",
      PATH46: "TEMPLATE PATH46 â€” Replace this area intel.",
      PATH47: "TEMPLATE PATH47 â€” Replace this area intel.",
      PATH48: "TEMPLATE PATH48 â€” Replace this area intel.",
      PATH49: "TEMPLATE PATH49 â€” Replace this area intel.",
      PATH5: "TEMPLATE PATH5 â€” Replace this area intel.",
      PATH50: "TEMPLATE PATH50 â€” Replace this area intel.",
      PATH6: "TEMPLATE PATH6 â€” Replace this area intel.",
      PATH68: "TEMPLATE PATH68 â€” Replace this area intel.",
      PATH8: "TEMPLATE PATH8 â€” Replace this area intel.",
      PATH81: "TEMPLATE PATH81 â€” Replace this area intel.",
      PATH84: "TEMPLATE PATH84 â€” Replace this area intel.",
      ROCKFORD_HILLS: "TEMPLATE ROCKFORD_HILLS â€” Wealthy hillside estates; replace intel.",
      SOUTH_SIDE: "TEMPLATE SOUTH_SIDE â€” Street-level sprawl; replace intel.",
      SECUROSERV_PORT: "TEMPLATE SECUROSERV_PORT â€” SecuroServ perimeter access; replace intel.",
      VESPUCCI: "TEMPLATE VESPUCCI â€” Beachfront strip; replace intel.",
      VINEWOOD_HILLS: "TEMPLATE VINEWOOD_HILLS â€” Hills + media mansions; replace intel.",
    };

    // =========================
    // MAP/INTEL (GANGS)
    // =========================
    const GANGS = {
      THE_LEX: { name: "THE LEX", iconFiles: ["LEX.png", "lex.png"] },
      NCPD: { name: "NCPD", iconFiles: ["ncpd.png", "NCPD.png", "NEON_CITY_PRISON.png", "neon_city_prison.png"] },
      TACMED: { name: "TACMED", iconFiles: ["tacmed.png", "TACMED.png"] },
      APEX: { name: "APEX", iconFiles: ["APEX_HQ.png", "apex_hq.png"] },
      MERRYWEATHER: { name: "MERRYWEATHER", iconFiles: ["mw.png", "MW.png"] },
      SECUROSERV: { name: "SECUROSERV", iconFiles: ["SS2.png", "ss2.png"] },
    };
    const REGION_GANGS = {
      SOUTH_SIDE: ["THE_LEX"],
      NEON_CORE: ["NCPD", "TACMED"],
      NEON_CITY_PRISON: ["NCPD"],
      APEX_HQ: ["NCPD", "APEX"],
      MERRYWEATHER_BASE: ["MERRYWEATHER"],
      SECUROSERV_PORT: ["SECUROSERV"],
      SECUROSERVE_PORT: ["SECUROSERV"],
    };

    // Restricted intel unlock state (session only)
    const unlockedRestrictedIntel = new Set();
    function isHackableRestrictedKey(normKey){
      const k = normalizeRegionKey(normKey);
      if(k === "MERRYWEATHER_BASE") return true;
      if(k === "NEON_CITY_PRISON") return true;
      if(k === "APEX" || k === "APEX_HQ" || k.startsWith("APEX_")) return true;
      // SecuroServ: second-stage hack is only available AFTER counterhack bypass.
      if(k === "SECUROSERV_PORT" || k === "SECUROSERVE_PORT" || k.startsWith("SECUROSERV_")) return true;
      return false;
    }
    function isRestrictedIntelUnlockedFor(el){
      if(!el) return false;
      if(!(el.classList && el.classList.contains("restricted"))) return true;

      const k = normalizeRegionKey(el.id || el.getAttribute("data-name") || "");
      // SecuroServ is two-stage:
      // 1) Counterhack bypass stops countermeasures (does NOT reveal intel)
      // 2) Second-stage hack (unlockedRestrictedIntel) reveals intel + removes blur
      if(k === "SECUROSERV_PORT" || k === "SECUROSERVE_PORT" || k.startsWith("SECUROSERV_")){
        return Boolean(securoservBypassedThisSession && unlockedRestrictedIntel.has(k));
      }
      return unlockedRestrictedIntel.has(k);
    }

    // Generic restricted-area hack (reuses the SecuroServ counterhack window, but with an in-window timer)
    let restrictedHackActive = false;
    let restrictedHackKey = "";
    let restrictedHackEndsAt = 0;
    let restrictedHackTimer = null;

    function ssChallengeEls(){
      const root = document.getElementById("securoservChallenge");
      return {
        root,
        label: root?.querySelector?.(".label") || null,
        instrSpans: root ? Array.from(root.querySelectorAll(".instr span")) : [],
        hintSpans: root ? Array.from(root.querySelectorAll(".hint span")) : [],
      };
    }

    function fmtMs(ms){
      const s = Math.max(0, Math.ceil(ms / 1000));
      const m = Math.floor(s / 60);
      const r = s % 60;
      return `${String(m).padStart(2,'0')}:${String(r).padStart(2,'0')}`;
    }

    function glitchInHackingUI(){
      const w = document.getElementById("securoservChallenge");
      if(!w) return;
      try{ w.classList.remove("glitch-in"); void w.offsetWidth; w.classList.add("glitch-in"); }catch{}

      // Spike the global screen glitch briefly (keeps existing state if it was already on).
      try{
        const sg = document.getElementById("screenGlitch");
        if(sg){
          const wasOn = sg.classList.contains("on");
          const prevG = sg.style.getPropertyValue("--g");
          sg.style.setProperty("--g", "0.98");
          sg.classList.add("on");
          setTimeout(() => {
            try{
              if(prevG) sg.style.setProperty("--g", prevG);
              else sg.style.removeProperty("--g");
              if(!wasOn) sg.classList.remove("on");
            }catch{}
          }, 520);
        }
      }catch{}

      setTimeout(() => { try{ w.classList.remove("glitch-in"); }catch{} }, 720);
    }

    function stopRestrictedHack(){
      restrictedHackActive = false;
      restrictedHackKey = "";
      restrictedHackEndsAt = 0;
      document.body?.classList?.remove?.("restricted-hack-active");
      document.body?.classList?.remove?.("simplehack-securosserv");

      // While hacking, we block mouse input (same behavior as SecuroServ countermeasures).
      // When stopping, restore the block state to match SecuroServ mode (if any).
      try{ setSecuroservMouseBlock(Boolean(document.body && document.body.classList.contains("securosserv-mode"))); }catch{}

      // Turn off the temporary background glitch overlay
      try{
        const screenGlitch = document.getElementById("screenGlitch");
        if(screenGlitch){
          screenGlitch.classList.remove("on");
          screenGlitch.style.removeProperty("--g");
        }
      }catch{}

      if(restrictedHackTimer){
        clearInterval(restrictedHackTimer);
        restrictedHackTimer = null;
      }

      // Hide the shared counterhack window
      try{ stopSecuroservChallenge(); }catch{}

      // Remove the temporary keydown wrapper if present
      try{
        if(window._restrictedHackKeydown){
          window.removeEventListener("keydown", window._restrictedHackKeydown, true);
          delete window._restrictedHackKeydown;
        }
      }catch{}
    }

    function abortSimplehackToNeutral(msg = "SIMPLEHACK FAILED"){
      // Show failure overlay, then return to a neutral centered view with no selection.
      try{
        counterhackFxShow(msg);
        setTimeout(() => counterhackFxFadeOutAndHide(2300), 700);
      }catch{}
      try{ term(`[HACK] ${msg}`); }catch{}

      // If we are inside SecuroServ mode, use its dedicated cleanup to guarantee
      // all timers/blocks are removed and the UI returns to a stable default.
      try{
        if(document.body?.classList?.contains?.("securosserv-mode")){
          cleanupSecuroservToDefault();
          return;
        }
      }catch{}

      try{ clearSelection(); }catch{}
      try{ cameraFlyToFitCenter(1100); }catch{}
    }

    function failRestrictedHack(){
      stopRestrictedHack();
      abortSimplehackToNeutral("SIMPLEHACK FAILED");
    }

    function succeedRestrictedHack(normKey){
      const k = normalizeRegionKey(normKey);
      unlockedRestrictedIntel.add(k);
      stopRestrictedHack();
      counterhackFxShow("hack succesfull");
      setTimeout(() => counterhackFxFadeOutAndHide(2300), 700);
      term(`[HACK] success â€¢ intel unlocked: ${k}`);
      // Remove restricted blur for this zone and update restricted UI state immediately.
      try{ rebuildRestrictedBlurClip(); }catch{}
      try{ updateRestrictedOverlayState(); }catch{}
      try{
        if(selectedEl){
          const selK = normalizeRegionKey(selectedEl.id || selectedEl.getAttribute("data-name") || "");
          if(selK === k){
            setRestrictedWallVisibleForRegion(selectedEl, false);
            setStripeThicknessForRegion(selectedEl, "base");
            updateSelectionGlowColor(null);
            // Notes/lore are gated for restricted zones; refresh immediately on unlock.
            setAreaNotesFor(selectedEl);
          }
        }
      }catch{}
      // Refresh the MAP/INTEL footer immediately
      try{ renderMapIntelFor(selectedEl); }catch{}
      try{ updateHackPromptForSelection(); }catch{}
    }

    function startRestrictedHackForKey(normKey){
      const k = normalizeRegionKey(normKey);
      if(!k) return;
      if(!isHackableRestrictedKey(k)) return;
      if(unlockedRestrictedIntel.has(k)) return;
      // SecuroServ second-stage hack requires counterhack bypass first.
      if(isSecuroservKey(k) && !securoservBypassedThisSession) return;
      if(securoservShutdownInProgress || securoservCounterhackResolving) return;
      if(restrictedHackActive) return;
      // Do not allow this while SecuroServ countermeasures are active
      if(document.body?.classList?.contains?.("securosserv-mode") && !securoservBypassedThisSession) return;

      restrictedHackActive = true;
      restrictedHackKey = k;
      restrictedHackEndsAt = performance.now() + 15000;
      document.body?.classList?.add?.("restricted-hack-active");

      // Disallow any click-off/selection changes while the hack is running.
      try{ setSecuroservMouseBlock(true); }catch{}

      // If this is the SecuroServ second-stage BREACH, theme the hack UI to match SecuroServ counterhack.
      if(isSecuroservKey(k)){
        document.body?.classList?.add?.("simplehack-securosserv");
      }

      // Enable background glitch overlay for the duration of this hack
      try{
        const screenGlitch = document.getElementById("screenGlitch");
        if(screenGlitch){
          screenGlitch.style.setProperty("--g", "0.65");
          screenGlitch.classList.add("on");
        }
      }catch{}

      // Reuse the existing symbol challenge mechanics, but change the window copy
      const { root, label, instrSpans, hintSpans } = ssChallengeEls();
      if(root) root.setAttribute("aria-hidden", "false");
      glitchInHackingUI();
      if(label) label.textContent = isSecuroservKey(k) ? "BREACH PROTOCOL:// COUNTERHACK" : "USER OVERRIDE:// HACK";
      if(instrSpans[0]) instrSpans[0].textContent = "TYPE THE SYMBOLS LEFT â†’ RIGHT";
      if(instrSpans[1]) instrSpans[1].textContent = "TIME LEFT: 00:15";
      if(hintSpans[0]) hintSpans[0].textContent = "UNLOCK MAP/INTEL ON SUCCESS";
      if(hintSpans[1]) hintSpans[1].textContent = "FAILURE ABORTS SIMPLEHACK";

      // Initialize the shared symbol slots state
      securoservChallengeSolved = false;
      securoservChallengeActive = true;
      securoservChallengeIndex = 0;
      securoservChallengeSymbols = Array.from({length:6}, () => ssRandomSymbol());
      renderSecuroservChallenge();

      // Shuffle remaining symbols every 2 seconds (same as SecuroServ)
      if(securoservChallengeShuffleTimer){
        clearInterval(securoservChallengeShuffleTimer);
        securoservChallengeShuffleTimer = null;
      }
      securoservChallengeShuffleTimer = setInterval(() => {
        if(!restrictedHackActive) return;
        for(let i=securoservChallengeIndex;i<6;i++){
          securoservChallengeSymbols[i] = ssRandomSymbol();
        }
        renderSecuroservChallenge();
      }, 2000);

      // Timer tick
      if(restrictedHackTimer){
        clearInterval(restrictedHackTimer);
        restrictedHackTimer = null;
      }
      restrictedHackTimer = setInterval(() => {
        if(!restrictedHackActive) return;
        const left = restrictedHackEndsAt - performance.now();
        if(instrSpans[1]) instrSpans[1].textContent = "TIME LEFT: " + fmtMs(left);
        if(left <= 0 && !securoservChallengeSolved){
          failRestrictedHack();
        }
      }, 120);

      // Use the same keydown handler, but intercept success
      const wrapped = (e) => {
        if(!restrictedHackActive) return;
        handleSecuroservChallengeKeydown(e);
        if(securoservChallengeSolved && restrictedHackActive){
          succeedRestrictedHack(restrictedHackKey);
        }
      };
      // store reference for removal
      window._restrictedHackKeydown = wrapped;
      window.addEventListener("keydown", wrapped, true);
    }

    // Hack prompt button
    document.getElementById("btnHackRestricted")?.addEventListener("click", () => {
      if(!selectedEl) return;
      const k = normalizeRegionKey(selectedEl.id || selectedEl.getAttribute("data-name") || "");
      startRestrictedHackForKey(k);
    });

    // Delay the prompt so it appears a beat after selection (more immersive).
    let hackPromptDelayTimer = null;
    let hackPromptDelayKey = "";

    function hideHackPrompt(){
      const hp = document.getElementById("hackPrompt");
      if(!hp) return;
      hp.classList.remove("on");
      hp.setAttribute("aria-hidden", "true");

      if(hackPromptDelayTimer){
        clearTimeout(hackPromptDelayTimer);
        hackPromptDelayTimer = null;
      }
      hackPromptDelayKey = "";
    }

    function positionHackPrompt(){
      const hp = document.getElementById("hackPrompt");
      const panel = document.getElementById("popupDetails");
      if(!hp || !panel) return;
      const r = panel.getBoundingClientRect();
      // Place to the right of the panel, aligned near the header
      const left = Math.min(window.innerWidth - 10, r.right + 12);
      const top = Math.max(10, r.top + 38);
      hp.style.left = left + "px";
      hp.style.top = top + "px";
    }

    function updatePopupDetailsFrame(){
      const panel = document.getElementById("popupDetails");
      if(!panel || !panel.classList.contains("on")) return;

      const svg = panel.querySelector(".pdSvg");
      if(!svg) return;

      const w = panel.clientWidth;
      const h = panel.clientHeight;
      if(!w || !h) return;

      const cut = (parseFloat(getComputedStyle(panel).getPropertyValue("--cut")) || 16);
      const pad = 2; // keeps outline stroke from being clipped
      const inset = pad; // keep fill tight to the outline (no visible gap)

      svg.setAttribute("viewBox", `0 0 ${w} ${h}`);

      const outline = svg.querySelector(".pdOutline");
      const fill = svg.querySelector(".pdFill");
      const lines = svg.querySelector(".pdLines");

      const outerPts = [
        `${cut + pad},${pad}`,
        `${w - cut - pad},${pad}`,
        `${w - pad},${cut + pad}`,
        `${w - pad},${h - cut - pad}`,
        `${w - cut - pad},${h - pad}`,
        `${pad},${h - pad}`,
        `${pad},${cut + pad}`,
      ].join(" ");

      const innerPts = [
        `${cut + inset},${inset}`,
        `${w - cut - inset},${inset}`,
        `${w - inset},${cut + inset}`,
        `${w - inset},${h - cut - inset}`,
        `${w - cut - inset},${h - inset}`,
        `${inset},${h - inset}`,
        `${inset},${cut + inset}`,
      ].join(" ");

      if(outline) outline.setAttribute("points", outerPts);
      if(fill) fill.setAttribute("points", innerPts);
      if(lines) lines.setAttribute("points", innerPts);
    }

    function updateHackPromptForSelection(){
      const hp = document.getElementById("hackPrompt");
      const panel = document.getElementById("popupDetails");
      if(!hp || !panel) return;

      // Always start hidden; show after a short delay if eligible.
      hideHackPrompt();

      if(!selectedEl) return;
      if(!(selectedEl.classList && selectedEl.classList.contains("restricted"))) return;

      const k = normalizeRegionKey(selectedEl.id || selectedEl.getAttribute("data-name") || "");

      const eligibleNow = (() => {
        if(!panel.classList.contains("on")) return false;

        // SecuroServ: before bypass, it uses the counterhack flow (no prompt).
        // After bypass, allow a second-stage "BREACH PROTOCOL" to fully unlock SecuroServ.
        if(k === "SECUROSERV_PORT" || k === "SECUROSERVE_PORT" || k.startsWith("SECUROSERV_")){
          if(!securoservBypassedThisSession) return false;
          if(unlockedRestrictedIntel.has(k)) return false;
          return true;
        }

        if(!isHackableRestrictedKey(k)) return false;
        if(unlockedRestrictedIntel.has(k)) return false;
        return true;
      })();

      if(!eligibleNow) return;

      hackPromptDelayKey = k;
      hackPromptDelayTimer = setTimeout(() => {
        hackPromptDelayTimer = null;

        if(!selectedEl) return;
        const currentK = normalizeRegionKey(selectedEl.id || selectedEl.getAttribute("data-name") || "");
        if(currentK !== hackPromptDelayKey) return;
        if(!(selectedEl.classList && selectedEl.classList.contains("restricted"))) return;
        if(!panel.classList.contains("on")) return;

        // Re-check eligibility after delay.
        if(currentK === "SECUROSERV_PORT" || currentK === "SECUROSERVE_PORT" || currentK.startsWith("SECUROSERV_")){
          if(!securoservBypassedThisSession) return;
          if(unlockedRestrictedIntel.has(currentK)) return;
        }else{
          if(!isHackableRestrictedKey(currentK)) return;
          if(unlockedRestrictedIntel.has(currentK)) return;
        }

        hp.classList.add("on");
        hp.setAttribute("aria-hidden", "false");
        positionHackPrompt();
      }, 1000);
    }

    window.addEventListener("resize", () => { try{ positionHackPrompt(); }catch{} });
    window.addEventListener("resize", () => { try{ updatePopupDetailsFrame(); }catch{} });

    function renderMapIntelFor(el){
      const foot = document.getElementById("detailFoot");
      if(!foot) return;

      foot.replaceChildren();

      if(!el){
        const dim = document.createElement("div");
        dim.className = "intelDim";
        dim.textContent = "waiting";
        foot.appendChild(dim);
        return;
      }

      // Restricted areas: show classified warning until unlocked.
      if(el.classList && el.classList.contains("restricted") && !isRestrictedIntelUnlockedFor(el)){
        const label = document.createElement("div");
        label.className = "intelLabel";
        label.textContent = "INTEL";
        foot.appendChild(label);

        const warn = document.createElement("div");
        warn.className = "intelWarning";

        const title = document.createElement("div");
        title.className = "intelWarnTitle";
        title.textContent = "WARNING";

        const body = document.createElement("div");
        body.className = "intelWarnBody";
        body.innerHTML =
          `<div class="hard">DATA CLASSIFIED</div>` +
          `<div>Access level insufficient â€¢ feed blocked</div>` +
          `<div class="stamp">NOFORN / EYES ONLY</div>`;

        warn.appendChild(title);
        warn.appendChild(body);
        foot.appendChild(warn);
        return;
      }

      const normKey = normalizeRegionKey(el.id || el.getAttribute("data-name") || "");
      const gangIds = (REGION_GANGS[normKey] || []).filter(Boolean);

      const label = document.createElement("div");
      label.className = "intelLabel";
      label.textContent = "ACTIVE GANGS";
      foot.appendChild(label);

      const list = document.createElement("div");
      list.className = "intelList";

      if(gangIds.length === 0){
        const none = document.createElement("div");
        none.className = "intelDim";
        none.textContent = "none detected";
        list.appendChild(none);
      }else{
        for(const gid of gangIds){
          const g = GANGS[gid];
          if(!g) continue;
          const row = document.createElement("div");
          row.className = "intelRow";

          const img = document.createElement("img");
          img.className = "intelLogo";
          img.alt = "";
          img.draggable = false;
          // Try multiple candidate paths (case-sensitive) using the same logic as other logos
          setImgCandidates(img, expandLogoPaths(g.iconFiles || []));
          img.addEventListener("error", () => {
            if(!advanceImgCandidate(img, "GANGLOGO")){
              try{ img.remove(); }catch{}
            }
          });

          const name = document.createElement("div");
          name.className = "intelName";
          name.textContent = g.name;

          row.appendChild(img);
          row.appendChild(name);
          list.appendChild(row);
        }
      }

      foot.appendChild(list);
    }

    function setAreaNotesFor(el){
      const box = document.getElementById("dNotes");
      const wrap = document.querySelector("#popupDetails .dLore");
      if(!box || !wrap){
        return;
      }

      if(!el){
        box.textContent = "";
        wrap.classList.remove("on");
        return;
      }

      // Restricted areas: lore/notes are classified until the zone is unlocked via hack.
      try{
        if(el.classList && el.classList.contains("restricted") && !isRestrictedIntelUnlockedFor(el)){
          box.textContent = "DATA CLASSIFIED â€¢ ACCESS LEVEL INSUFFICIENT";
          wrap.classList.add("on");
          return;
        }
      }catch{}

      const key = normalizeRegionKey(el.id || el.getAttribute("data-name") || "");
      const note = (AREA_NOTES[key] || "").trim();
      if(!note){
        box.textContent = "";
        wrap.classList.remove("on");
        return;
      }

      box.textContent = note;
      wrap.classList.add("on");
    }

    // Popup close handlers
    document.addEventListener("click", (e) => {
      const btn = e.target.closest("[data-close]");
      if(!btn) return;
      document.getElementById(btn.getAttribute("data-close"))?.classList.remove("on");
    });

    // Pan/zoom transform on #mapStack; #svgHost holds regions SVG.
    const mapStack = document.getElementById("mapStack");
    const host = document.getElementById("svgHost");
    const tooltip = document.getElementById("tooltip");
    const cursorLogo = document.getElementById("cursorLogo");
    const detailLogo = document.getElementById("detailLogo");
    const selectionText = document.getElementById("selectionText");
    const zoomReadout = document.getElementById("zoomReadout");
    const zoomBar = document.getElementById("zoomBar");
    const logosLayer = document.getElementById("logosLayer");

    function uniq(arr){
      const out = [];
      const seen = new Set();
      for(const v of (arr || [])){
        const s = String(v || "");
        if(!s) continue;
        if(seen.has(s)) continue;
        seen.add(s);
        out.push(s);
      }
      return out;
    }

    function expandLogoPaths(fileNames){
      const paths = [];
      for(const f of (fileNames || [])){
        paths.push(`./${f}`);
        paths.push(`./logos/${f}`);
      }
      return uniq(paths);
    }

    // =========================
    // LOGO PRELOAD (CACHE WARM)
    // =========================
    // Preload known logo assets so they show instantly when requested.
    const LOGO_PRELOAD_URLS = [
      "./logos/APEX_HQ.png",
      "./logos/HUMANE_LABS.png",
      "./logos/LA_PUERTA.png",
      "./logos/LEX.png",
      "./logos/LEXIES.png",
      "./logos/LITTLE_SOEUL.png",
      "./logos/MERRYWEATHER_BASE.png",
      "./logos/MIRROR_HILLS.png",
      "./logos/MW.png",
      "./logos/NEON_CITY_NATIONAL_AIRPORT.png",
      "./logos/NEON_CITY_PORTS.png",
      "./logos/NEON_CITY_PRISON.png",
      "./logos/NEON_CORE.png",
      "./logos/PACIFIC_BLUFFS.png",
      "./logos/PALAMINO_LANDS.png",
      "./logos/ROCKFORD_HILLS.png",
      "./logos/SECUROSERV_PORT.png",
      "./logos/SOUTH_SIDE.png",
      "./logos/SS.png",
      "./logos/SS2.png",
      "./logos/TACMED.png",
      "./logos/VESPUCCI.png",
      "./logos/VINEWOOD_HILLS.png",
    ];

    const _preloadedUrls = new Set();

    function preloadOneImage(url){
      if(!url || _preloadedUrls.has(url)) return Promise.resolve(false);
      _preloadedUrls.add(url);

      return new Promise((resolve) => {
        const img = new Image();
        img.decoding = "async";
        img.loading = "eager";
        img.onload = () => {
          // decode() avoids a jank spike on first paint in some browsers
          const d = (img.decode ? img.decode() : null);
          if(d && typeof d.then === "function"){
            d.then(() => resolve(true)).catch(() => resolve(true));
          }else{
            resolve(true);
          }
        };
        img.onerror = () => resolve(false);
        img.src = url;
      });
    }

    async function preloadImages(urls, concurrency = 4){
      const list = uniq(urls);
      let i = 0;
      const worker = async () => {
        while(i < list.length){
          const url = list[i++];
          await preloadOneImage(url);
        }
      };
      const workers = Array.from({ length: Math.max(1, Math.min(concurrency, list.length)) }, worker);
      await Promise.allSettled(workers);
    }

    function scheduleLogoPreload(){
      const run = () => {
        // Keep this low-priority so it doesn't compete with initial map rendering.
        try{ preloadImages(LOGO_PRELOAD_URLS, 4); }catch{}
      };

      if("requestIdleCallback" in window){
        window.requestIdleCallback(run, { timeout: 1500 });
      }else{
        setTimeout(run, 600);
      }
    }

    scheduleLogoPreload();

    function setImgCandidates(img, paths){
      if(!img) return;
      const list = uniq(paths);
      img.dataset.logoCandidates = JSON.stringify(list);
      img.dataset.logoIndex = "0";
      img.src = list[0] || "";
    }

    function advanceImgCandidate(img, missingTag){
      if(!img) return false;
      let list = [];
      try{ list = JSON.parse(img.dataset.logoCandidates || "[]"); }catch{ list = []; }
      const idx = parseInt(img.dataset.logoIndex || "0", 10);
      const nextIdx = idx + 1;
      if(nextIdx < list.length){
        img.dataset.logoIndex = String(nextIdx);
        img.src = list[nextIdx];
        return true;
      }

      // Exhausted candidates
      const last = list[list.length - 1] || "";
      if(last){
        term(`[${missingTag}] missing: ${last}`);
      }
      return false;
    }

    if(cursorLogo){
      cursorLogo.addEventListener("load", () => {
        cursorLogo.dataset.failed = "0";
        cursorLogo.classList.add("on");
      });
      cursorLogo.addEventListener("error", () => {
        cursorLogo.dataset.failed = "1";
        cursorLogo.classList.remove("on");
        // Try next candidate (root vs ./logos, securoserv_port vs SECUROSERV_PORT)
        advanceImgCandidate(cursorLogo, "LOGO");
      });
    }

    if(detailLogo){
      detailLogo.addEventListener("load", () => {
        detailLogo.classList.add("on");
      });
      detailLogo.addEventListener("error", () => {
        detailLogo.classList.remove("on");
        if(!advanceImgCandidate(detailLogo, "DETAILLOGO")){
          detailLogo.removeAttribute("src");
        }
      });
    }

    // =========================
    // GAME CAMERA (SMOOTH)
    // =========================
    const camera = {
      x: 0, y: 0,
      zoom: 1,
      targetX: 0, targetY: 0,
      targetZoom: 1,
      minZoom: 0.06,
      maxZoom: 6.0,

      // smoothing (higher = snappier)
      panSmooth: 0.18,
      zoomSmooth: 0.20,

      // bounds from SVG viewBox
      vb: null, // {x,y,width,height}

      // original viewBox origin (used to convert SVG units -> stack pixels)
      vbOrigin: { x: 0, y: 0 },

      // viewport size cache
      vw: 1, vh: 1,

      // transitions
      anim: null, // {t0, dur, from, to}
    };

    // Cache viewport size (no getBoundingClientRect spam)
    const mapwrap = document.querySelector(".mapwrap");
    function updateViewport(){
      const r = mapwrap.getBoundingClientRect();
      camera.vw = r.width;
      camera.vh = r.height;
    }
    updateViewport();
    new ResizeObserver(updateViewport).observe(mapwrap);

    function updateDockMetrics(){
      // Terminal dock removed; ensure dependent offsets resolve to 0
      document.documentElement.style.setProperty("--dockH", "0px");

      const toggles = document.getElementById("layerToggles");
      if(toggles){
        const b = Math.round(toggles.getBoundingClientRect().bottom);
        document.documentElement.style.setProperty("--detailsTop", (b + 14) + "px");
      }
    }
    window.addEventListener("resize", () => requestAnimationFrame(updateDockMetrics));
    requestAnimationFrame(updateDockMetrics);

    // perf mode removed; transforms now apply to lightweight raster stack

    // Easing
    function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

    // Clamp helpers
    function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
    function lerp(a,b,t){ return a + (b-a)*t; }

    // User preference: no movement restrictions (no clamping).
    const DISABLE_CAMERA_CLAMP = true;

    // Keep camera from losing the map entirely.
    // This is intentionally loose: you can pan freely, and the only constraint is that
    // the map cannot be completely off-screen.
    function clampToBounds(){
      if(!camera.vb) return;
      if(DISABLE_CAMERA_CLAMP) return;

      const vb = camera.vb;

      // half-viewport in world units
      const halfW = (camera.vw / 2) / camera.targetZoom;
      const halfH = (camera.vh / 2) / camera.targetZoom;

      // Ensure viewport intersects map bounds (non-empty overlap).
      // viewport in world = [targetX-halfW, targetX+halfW]
      // map in world      = [vb.x, vb.x+vb.width]
      const minX = vb.x - halfW;
      const maxX = (vb.x + vb.width) + halfW;
      const minY = vb.y - halfH;
      const maxY = (vb.y + vb.height) + halfH;

      camera.targetX = clamp(camera.targetX, minX, maxX);
      camera.targetY = clamp(camera.targetY, minY, maxY);
    }

    // Render camera transform (centered)
    function renderCamera(){
      const cx = camera.vw / 2;
      const cy = camera.vh / 2;
      mapStack.style.transform =
        `translate3d(${cx}px, ${cy}px, 0) scale(${camera.zoom}) translate(${-camera.x}px, ${-camera.y}px)`;
      if(zoomReadout) zoomReadout.textContent = `ZOOM: ${Math.round(camera.zoom * 100)}%`;
      const panEl = document.getElementById("panReadout");
      if(panEl) panEl.textContent = `${Math.round(camera.x)},${Math.round(camera.y)}`;
      if(logosLayer){
        const scale = camera.zoom > 0 ? 1 / camera.zoom : 1;
        logosLayer.style.setProperty('--logoZoomScale', String(scale));
      }

      // Side zoom bar fills from center: up for zoom-in, down for zoom-out
      if(zoomBar){
        // True percentage meter from min->max, drawn symmetrically from the center.
        const z = camera.zoom;
        const denom = Math.max(0.0001, (camera.maxZoom - camera.minZoom));
        const fill = (z - camera.minZoom) / denom;
        zoomBar.style.setProperty('--fill', String(clamp(fill, 0, 1)));
      }
    }


    // Animation loop (smooth inertial pan/zoom + transitions)
    let rafId = null;
    let wastelineMarquee = null;
    function startTick(){
      if(rafId) return; // already running
      const loop = () => {
        rafId = requestAnimationFrame(loop);

        const now = performance.now();

        // Wasteline marquee (seamless textPath scroll)
        if(wastelineMarquee && wastelineMarquee.a && wastelineMarquee.length > 0){
          const dt = Math.max(0, (now - wastelineMarquee.last) / 1000);
          wastelineMarquee.last = now;
          const referenceLength = wastelineMarquee.textLength || wastelineMarquee.length;
          if(!referenceLength) return;
          wastelineMarquee.offset = (wastelineMarquee.offset + (wastelineMarquee.speed * dt)) % referenceLength;
          try{ wastelineMarquee.a.setAttribute("startOffset", String(wastelineMarquee.offset)); }catch{}
        }

        // run scripted animation if any
        if(camera.anim){
          const t = (now - camera.anim.t0) / camera.anim.dur;
          const k = easeOutCubic(clamp(t, 0, 1));
          camera.targetX = lerp(camera.anim.from.x, camera.anim.to.x, k);
          camera.targetY = lerp(camera.anim.from.y, camera.anim.to.y, k);
          camera.targetZoom = lerp(camera.anim.from.zoom, camera.anim.to.zoom, k);
          clampToBounds();
          if(t >= 1) camera.anim = null;
        }

        // smooth approach targets (inertial feel)
        camera.zoom = lerp(camera.zoom, camera.targetZoom, camera.zoomSmooth);
        camera.x = lerp(camera.x, camera.targetX, camera.panSmooth);
        camera.y = lerp(camera.y, camera.targetY, camera.panSmooth);

        renderCamera();
      };
      loop();
    }

    // Set camera instantly (no smoothing)
    function cameraSetInstant(x,y,z){
      camera.x = camera.targetX = x;
      camera.y = camera.targetY = y;
      camera.zoom = camera.targetZoom = z;
      clampToBounds();
      renderCamera();
    }

    // Animate camera to target (selection transitions)
    function cameraFlyTo(x,y,z, dur=420){
      camera.anim = {
        t0: performance.now(),
        dur,
        from: { x: camera.targetX, y: camera.targetY, zoom: camera.targetZoom },
        to: { x, y, zoom: z }
      };
    }

    function resetCameraToFitCenter(){
      if(!camera.vb) return;
      updateViewport();
      const vw = camera.vw || 1;
      const vh = camera.vh || 1;
      const fit = clamp(Math.min(vw / camera.vb.width, vh / camera.vb.height), camera.minZoom, camera.maxZoom);
      cameraSetInstant(camera.vb.width/2, camera.vb.height/2, fit);
    }

    function cameraFlyToFitCenter(dur=1200){
      if(!camera.vb) return;
      updateViewport();
      const vw = camera.vw || 1;
      const vh = camera.vh || 1;
      const fit = clamp(Math.min(vw / camera.vb.width, vh / camera.vb.height), camera.minZoom, camera.maxZoom);
      cameraFlyTo(camera.vb.width/2, camera.vb.height/2, fit, dur);
    }

    function flyToElement(el, zoom=2.2, dur=520, allowAutoZoom=true){
      if(!el) return;
      try{
        updateViewport();

        // Center: use screen->world inversion so we don't depend on SVG viewBox origin quirks.
        const c = regionCenterInWorld(el);

        // Size: use SVG bbox (width/height are stable even if viewBox x/y is negative).
        const b = el.getBBox();
        const pad = 80; // in world units (same units as b.width/b.height)

        let z = zoom;
        if(allowAutoZoom){
          const fitX = camera.vw / (b.width + pad);
          const fitY = camera.vh / (b.height + pad);
          const fit = clamp(Math.min(fitX, fitY), camera.minZoom, camera.maxZoom);
          // Fit always wins (guarantees it stays fully visible). Clamp handles max zoom.
          z = fit;
        }

        if(c){
          cameraFlyTo(c.x, c.y, clamp(z, camera.minZoom, camera.maxZoom), dur);
          return;
        }

        // Fallback: compute center from bbox (using vbOrigin shift)
        if(!camera.vbOrigin) return;
        const cx = (b.x - camera.vbOrigin.x) + b.width/2;
        const cy = (b.y - camera.vbOrigin.y) + b.height/2;
        cameraFlyTo(cx, cy, clamp(z, camera.minZoom, camera.maxZoom), dur);
      }catch{
        // ignore
      }
    }

    function centerOnElement(el, dur=320){
      if(!el || !camera.vbOrigin) return;
      try{
        updateViewport();
        const c = regionCenterInWorld(el);
        if(c){
          cameraFlyTo(c.x, c.y, camera.targetZoom, dur);
          return;
        }
        const b = el.getBBox();
        const cx = (b.x - camera.vbOrigin.x) + b.width/2;
        const cy = (b.y - camera.vbOrigin.y) + b.height/2;
        cameraFlyTo(cx, cy, camera.targetZoom, dur);
      }catch{
        // ignore
      }
    }

    // Pan + zoom controls
    let isPointerDown = false;
    let isDragging = false; // true only after exceeding threshold
    let last = { x: 0, y: 0 };
    let dragStart = null;
    let dragMoved = false;
    let dragStartedOnRegion = false;
    let suppressRegionClickOnce = false;
    const DRAG_CLICK_THRESHOLD_PX = 12;

    mapwrap.addEventListener("mousedown", (e) => {
      if(e.button !== 0) return; // left button only
      isPointerDown = true;
      isDragging = false;
      last.x = e.clientX;
      last.y = e.clientY;
      dragStart = { x: e.clientX, y: e.clientY };
      dragMoved = false;
      dragStartedOnRegion = Boolean(e.target?.closest?.('.region'));
    });

    window.addEventListener("mouseup", () => {
      if(!isPointerDown) return;
      isPointerDown = false;
      mapStack.classList.remove("grabbing");

      // If we panned starting on a district, do not treat mouseup as a click.
      if(isDragging && dragStartedOnRegion){
        suppressRegionClickOnce = true;
      }

      isDragging = false;
      dragStart = null;
      dragMoved = false;
      dragStartedOnRegion = false;
    });

    window.addEventListener("mousemove", (e) => {
      if(!isPointerDown) return;

      if(dragStart && !dragMoved){
        const dx0 = e.clientX - dragStart.x;
        const dy0 = e.clientY - dragStart.y;
        if(Math.hypot(dx0, dy0) >= DRAG_CLICK_THRESHOLD_PX){
          dragMoved = true;
          isDragging = true;
          mapStack.classList.add("grabbing");
        }
      }

      if(!isDragging) return;

      const dx = e.clientX - last.x;
      const dy = e.clientY - last.y;
      last.x = e.clientX;
      last.y = e.clientY;

      // Move camera opposite to drag direction
      camera.targetX -= dx / camera.targetZoom;
      camera.targetY -= dy / camera.targetZoom;
      clampToBounds();
    });

    mapwrap.addEventListener("wheel", (e) => {
      e.preventDefault();
      updateViewport();
      const rect = mapwrap.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      // World point under cursor (using target values for stability)
      const wx = camera.targetX + (mx - camera.vw/2) / camera.targetZoom;
      const wy = camera.targetY + (my - camera.vh/2) / camera.targetZoom;

      const zoomFactor = (e.deltaY > 0) ? 0.92 : 1.08;
      const newZ = clamp(camera.targetZoom * zoomFactor, camera.minZoom, camera.maxZoom);
      if(newZ === camera.targetZoom) return;

      camera.targetZoom = newZ;
      // Keep mouse anchored in world space
      camera.targetX = wx - (mx - camera.vw/2) / camera.targetZoom;
      camera.targetY = wy - (my - camera.vh/2) / camera.targetZoom;
      clampToBounds();
    }, { passive:false });

    // Note: no post-pan/post-zoom snapping. Selection is centered once on click.

    function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

    function hashToHue(str){
      // stable hash -> 0..359
      let h = 2166136261;
      for(let i=0;i<str.length;i++){
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return Math.abs(h) % 360;
    }

    function normalizeRegionKey(s){
      return String(s || "")
        .trim()
        .toUpperCase()
        .replace(/[^A-Z0-9]+/g, "_")
        .replace(/^_+|_+$/g, "");
    }

    function getRegionAccentColor(el){
      const key = normalizeRegionKey(el?.id || el?.getAttribute?.("data-name") || "");

      // Exact overrides requested
      if(key === "NEON_CITY_PRISON") return "#608fff";
      if(key === "APEX" || key === "APEX_HQ" || key.startsWith("APEX_")) return "#608fff";
      if(key === "MERRYWEATHER_PORT" || key === "MERRYWEATHER_BASE" || key.startsWith("MERRYWEATHER_")) return "#d9b026";

      return null;
    }

    function getRegionColorOverride(key){
      const k = normalizeRegionKey(key);

      function hexToRgba(hex, a){
        const h = String(hex || "").trim().replace(/^#/, "");
        if(h.length !== 6) return hex;
        const r = parseInt(h.slice(0,2), 16);
        const g = parseInt(h.slice(2,4), 16);
        const b = parseInt(h.slice(4,6), 16);
        return `rgba(${r}, ${g}, ${b}, ${a})`;
      }

      // User-specified district palette
      if(k === "NEON_CITY_PRISON" || k === "APEX" || k === "APEX_HQ" || k.startsWith("APEX_")){
        // Fill is handled by selection (text-wall hidden until clicked)
        return { stroke: "#608fff" };
      }

      if(k === "SOUTH_SIDE"){
        return { stroke: "#ff0000", fill: hexToRgba("360000", 0.68) };
      }

      if(k === "LITTLE_SOEUL"){
        // Keep the original district outline color, while matching SOUTH_SIDE fill.
        return { stroke: "#f2c25c", fill: hexToRgba("360000", 0.68) };
      }

      if(k === "NEON_CORE"){
        return { stroke: "#7dc5bd", fill: hexToRgba("2c063c", 0.72) };
      }

      if(k === "VESPUCCI"){
        return { stroke: "#ffd164", fill: hexToRgba("6000bb", 0.44) };
      }

      if(k === "LA_PUERTA"){
        return { stroke: "#eb55d8", fill: hexToRgba("260240", 0.72) };
      }

      if(k === "PACIFIC_BLUFFS"){
        return { stroke: "#8f2a1a", fill: hexToRgba("39110a", 0.62) };
      }

      if(k === "HUMANE_LABS"){
        return { stroke: "#48afff", fill: hexToRgba("00213b", 0.6) };
      }

      if(k === "NEON_CITY_NATIONAL_AIRPORT"){
        return { stroke: "#c9cfcf", fill: "#1c222a" };
      }

      if(k === "NEON_CITY_PORTS"){
        return { stroke: "#4c5a76", fill: "#051025" };
      }

      if(k === "PALAMINO_LANDS"){
        return { stroke: "#71050d", fill: hexToRgba("360000", 0.68) };
      }

      if(k === "MIRROR_HILLS"){
        return { stroke: "#9bbac3", fill: "#0b242f" };
      }

      if(k === "MERRYWEATHER_BASE"){
        return { stroke: "#d9b026" };
      }

      if(k === "MERRYWEATHER_PORT"){
        return { stroke: "#d9b026" };
      }

      if(k === "SECUROSERV_PORT" || k === "SECUROSERVE_PORT"){
        // Fill is handled by selection (text-wall hidden until clicked)
        return { stroke: "#cf0000" };
      }

      return null;
    }

    function getRestrictedWallPatternIdForRegion(el){
      const normKey = normalizeRegionKey(el?.id || el?.getAttribute?.("data-name") || "");
      if(normKey === "SECUROSERV_PORT" || normKey === "SECUROSERVE_PORT" || normKey.startsWith("SECUROSERV_")){
        return ensureRestrictedMatrixPatternSecuroserv();
      }
      return ensureRestrictedMatrixPattern();
    }

    function clearSelectionVisualsImmediatelyForSecuroservSuccess(){
      // The success overlay fades in while hack UI fades out; clear selection + text-wall
      // immediately so they don't appear "stuck" underneath the overlay.
      try{
        if(selectedEl){
          if(selectedEl.classList?.contains?.('restricted')){
            setRestrictedWallVisibleForRegion(selectedEl, false);
            setStripeThicknessForRegion(selectedEl, "base");
          }
          selectedEl.classList?.remove?.('selected');
          try{ setDistrictLogoStateFor(selectedEl, selectedEl === hoveredEl ? "hover" : "base"); }catch{}
        }
      }catch{}

      try{
        if(hoveredEl){
          hoveredEl.classList?.remove?.('hot');
          clearHotStyle(hoveredEl);
          try{ setDistrictLogoStateFor(hoveredEl, "base"); }catch{}
        }
      }catch{}

      try{ updateSelectionGlowColor(null); }catch{}
      try{ updateSelectionDimming(); }catch{}

      hoveredEl = null;
      try{ selectedEl = null; }catch{}

      try{ refreshHoverTab(); }catch{}
    }

    function setRestrictedWallVisibleForRegion(el, visible){
      if(!el || !el.classList?.contains?.('restricted') || el.classList.contains('wall')) return;
      if(visible){
        const pat = getRestrictedWallPatternIdForRegion(el);
        if(pat) el.style.fill = `url(#${pat})`;
        else el.style.fill = "rgba(0,0,0,0.001)";
      }else{
        // Only the blur layer should be visible until clicked.
        // IMPORTANT: keep an (almost) invisible fill so the whole region remains clickable/hoverable.
        el.style.fill = "rgba(0,0,0,0.001)";
      }
    }

    function ensureStripePattern(svg, id, color){
      if(!svg) return null;
      const safeId = String(id);
      if(svg.querySelector(`#${CSS.escape(safeId)}`)) return safeId;

      let defs = svg.querySelector("defs");
      if(!defs){
        defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
        svg.insertBefore(defs, svg.firstChild);
      }

      const pattern = document.createElementNS("http://www.w3.org/2000/svg", "pattern");
      pattern.setAttribute("id", safeId);
      pattern.setAttribute("patternUnits", "userSpaceOnUse");
      pattern.setAttribute("width", "14");
      pattern.setAttribute("height", "14");
      pattern.setAttribute("patternTransform", "rotate(45)");

      // Slightly visible tinted fill behind stripes
      const bg = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      bg.setAttribute("x", "0");
      bg.setAttribute("y", "0");
      bg.setAttribute("width", "14");
      bg.setAttribute("height", "14");
      bg.setAttribute("fill", color);
      bg.setAttribute("opacity", ".16");
      pattern.appendChild(bg);

      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("data-stripe", "1");
      line.setAttribute("x1", "0");
      line.setAttribute("y1", "0");
      line.setAttribute("x2", "0");
      line.setAttribute("y2", "14");
      line.setAttribute("stroke", color);
      line.setAttribute("stroke-width", "2.6");
      line.setAttribute("stroke-linecap", "square");
      line.setAttribute("opacity", ".85");

      pattern.appendChild(line);
      defs.appendChild(pattern);
      return safeId;
    }

    function setStripeThicknessForRegion(el, mode){
      if(!el) return;
      const patId = el.getAttribute("data-stripe-pat");
      if(!patId || !svgEl) return;
      const line = svgEl.querySelector(`#${CSS.escape(patId)} line[data-stripe='1']`);
      if(!line) return;
      const w = mode === "selected" ? 4.2 : mode === "hover" ? 3.4 : 2.6;
      line.setAttribute("stroke-width", String(w));
    }

    function colorizeRegions(){
      if(!svgEl) return;
      const regions = svgEl.querySelectorAll(".region");
      const INVISIBLE_FILL = "rgba(0,0,0,0.001)";

      regions.forEach((r, i) => {
        if(r.classList.contains("wall")){
          r.style.fill = "none";
          return;
        }

        const rawKey = r.id || r.getAttribute("data-name") || String(i);
        const hue = hashToHue(rawKey);
        r.setAttribute("data-hue", String(hue));

        const normKey = normalizeRegionKey(rawKey);
        const isDanger =
          (normKey === "NEON_CITY_PRISON") ||
          (normKey === "APEX") || (normKey === "APEX_HQ") || normKey.startsWith("APEX_");
        r.classList.toggle("danger", isDanger);

        const restricted = isRegionRestricted(r);
        r.classList.toggle("restricted", restricted);

        const override = getRegionColorOverride(normKey);
        let fallback = null;
        if(!override && !restricted){
          if(normKey === "VINEWOOD_HILLS" || normKey === "ROCKFORD_HILLS"){
            // Match the existing random district-label color style (stable per region)
            fallback = {
              stroke: `hsl(${hue}, 85%, 68%)`,
              fill: `hsla(${hue}, 70%, 18%, 0.62)`,
            };
          }else{
            // Unset districts (non-restricted only): intentionally obnoxious neon green
            fallback = { stroke: "#39ff14" };
          }
        }
        const effective = override || fallback;

        // Stroke color:
        // - Normal areas: let CSS control (blue base, yellow hover/selected)
        // - Restricted or explicitly-accented: set stroke via JS
        const accent = getRegionAccentColor(r);
        if(effective?.stroke){
          r.style.stroke = effective.stroke;
        }else if(accent || restricted){
          const strokeCol = accent || `rgb(96,143,255)`;
          r.style.stroke = strokeCol;
        }else{
          r.style.removeProperty("stroke");
        }

        // Fill: always invisible (outline-only mode). Keep a tiny fill so regions remain clickable.
        r.removeAttribute("data-stripe-pat");
        if(restricted) setRestrictedWallVisibleForRegion(r, false);
        r.style.fill = INVISIBLE_FILL;
      });

      // Keep restricted blur mask in sync with current visibility/state
      rebuildRestrictedBlurClip();

      // Enforce paint order: normal < restricted < walls
      restackRegionLayers();
    }

    function isRegionRestricted(el){
      if(!el) return false;

      // Preferred marker: restriction="y"
      const restriction = (el.getAttribute("restriction") || "").trim().toLowerCase();
      if(restriction === "y") return true;

      // Back-compat markers
      const restrictedAttr = (el.getAttribute("data-restricted") || "").trim().toLowerCase() === "true";
      if(restrictedAttr) return true;
      if(el.classList?.contains("restricted")) return true;

      return false;
    }

    function regionCenterInWorld(el, mapRect){
      if(!el || !mapwrap) return null;
      const r = el.getBoundingClientRect();
      if(!r || !isFinite(r.left) || !isFinite(r.top) || (r.width === 0 && r.height === 0)) return null;

      const wrapRect = mapRect || mapwrap.getBoundingClientRect();
      const sx = (r.left + r.right) / 2 - wrapRect.left;
      const sy = (r.top + r.bottom) / 2 - wrapRect.top;

      // Invert renderCamera transform:
      // screen = (world - camera.xy) * zoom + (vw/2, vh/2)
      const x = camera.x + (sx - camera.vw / 2) / camera.zoom;
      const y = camera.y + (sy - camera.vh / 2) / camera.zoom;
      if(!isFinite(x) || !isFinite(y)) return null;
      return { x, y };
    }

    function buildLabels(filterFn = null){
      const layer = document.getElementById("labelsLayer");
      if(!layer || !svgEl) return;
      layer.innerHTML = "";
      if(!SHOW_LABELS) return;
      const mapRect = mapwrap.getBoundingClientRect();
      svgEl.querySelectorAll(".region:not(.wall)").forEach(r => {
        if(r.classList.contains("hidden")) return;
        const key = normalizeRegionKey(r.id || r.getAttribute("data-name") || "");
        if(!key || key.startsWith("PATH")) return;
        const name = (r.getAttribute("data-name") || r.id || "(unnamed)");
        const restricted = isRegionRestricted(r);
        if(filterFn && !filterFn({el:r, restricted})) return;
        const c = regionCenterInWorld(r, mapRect);
        if(!c) return;
        const x = c.x;
        const y = c.y;
        const hue = parseInt(r.getAttribute("data-hue") || "210", 10);
        const color = `hsl(${hue}, 85%, 68%)`;
        const div = document.createElement("div");
        div.className = "districtLabel";
        div.textContent = name;
        div.style.left = x + "px";
        div.style.top = y + "px";
        div.style.color = color;
        div.style.textShadow = `0 0 6px hsla(${hue}, 85%, 65%, .35), 0 0 12px hsla(${hue}, 85%, 65%, .25)`;
        layer.appendChild(div);
      });
    }

    function setDistrictLogoStateFor(el, state){
      if(!el) return;
      const key = normalizeRegionKey(el.id || el.getAttribute?.("data-name") || "");
      const node = document.querySelector(`#logosLayer .districtLogo[data-key="${CSS.escape(key)}"]`);
      if(!node) return;
      if(state === "base"){
        node.classList.remove("hot");
        return;
      }
      const isActive = state === "hover" || state === "selected";
      node.classList.toggle("hot", isActive);
    }

    function buildDistrictLogos(filterFn = null){
      const layer = document.getElementById("logosLayer");
      if(!layer || !svgEl) return;
      layer.innerHTML = "";

      function getDistrictLogoOffset(el){
        const key = normalizeRegionKey(el?.id || el?.getAttribute?.("data-name") || "");
        if(key === "NEON_CITY_PORTS"){
          try{
            const b = el.getBBox?.();
            const dx = -Math.max(50, (Number(b?.width) || 0) * 0.16);
            return { dx, dy: 0 };
          }catch{
            return { dx: -70, dy: 0 };
          }
        }
        if(key === "LITTLE_SOEUL"){
          return { dx: 14, dy: -10 };
        }
        if(key === "SOUTH_SIDE"){
          return { dx: 0, dy: -30 };
        }
        return { dx: 0, dy: 0 };
      }

      const mapRect = mapwrap.getBoundingClientRect();

      svgEl.querySelectorAll(".region:not(.wall)").forEach(r => {
        if(r.classList.contains("hidden")) return;

        const restricted = isRegionRestricted(r);
        if(filterFn && !filterFn({el:r, restricted})) return;

        const c = regionCenterInWorld(r, mapRect);
        if(!c) return;
        const off = getDistrictLogoOffset(r);
        const x = c.x + (off.dx || 0);
        const y = c.y + (off.dy || 0);

        const key = normalizeRegionKey(r.id || r.getAttribute("data-name") || "");
        if(!key || key.startsWith("PATH")) return;
        if(!key) return;

        const isSecuroserv = isSecuroservKey(key);

        // Hide SecuroServ logo until the user successfully counter-hacks it.
        if(isSecuroserv && !securoservBypassedThisSession) return;

        const wrap = document.createElement("div");
        wrap.className = "districtLogo";
        wrap.dataset.key = key;
        wrap.style.left = x + "px";
        wrap.style.top = y + "px";

        const img = document.createElement("img");
        img.alt = "";
        img.draggable = false;
        img.loading = "lazy";

        const primaryFiles = isSecuroserv
          ? ["securoserv_port.png", `${key}.png`]
          : [`${key}.png`];

        setImgCandidates(img, expandLogoPaths(primaryFiles));
        img.addEventListener("load", () => {
          wrap.classList.add("ready");
        });
        img.addEventListener("error", () => {
          if(advanceImgCandidate(img, "LOGO")) return;
          wrap.remove();
        });

        wrap.appendChild(img);
        layer.appendChild(wrap);
      });

      // Apply current hover/selection state to rebuilt layer
      if(hoveredEl) setDistrictLogoStateFor(hoveredEl, "hover");
      if(selectedEl) setDistrictLogoStateFor(selectedEl, "selected");
    }

    // COMPAT: prevent crashes if old loader code still calls setProgress()
    function setProgress(p, label, meta=""){
      // p is 0..1
      const pct = Math.round(Math.max(0, Math.min(1, p)) * 100);

      // Drive the boot overlay (55%+ is handled by real download too, this is fine)
      bootSet(pct, label || "");
      if(meta) bootLine(`[PROGRESS] ${label} â€¢ ${meta}`, true);
    }

    const SVG_NS = "http://www.w3.org/2000/svg";
    const SELECTION_GLOW_FILTER_ID = "selectionGlowInner";
    const RESTRICTED_TEXT_PATTERN_ID = "restricted-text-pattern";
    const RESTRICTED_MATRIX_PATTERN_ID = "restricted-matrix-pattern";

    function fnv1a32(str){
      str = String(str || "");
      let h = 2166136261;
      for(let i=0;i<str.length;i++){
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return (h >>> 0);
    }

    function makeRng(seedStr){
      let x = fnv1a32(seedStr) || 1;
      return function rand(){
        // xorshift32
        x ^= (x << 13);
        x ^= (x >>> 17);
        x ^= (x << 5);
        x >>>= 0;
        return x / 4294967296;
      };
    }

    function ensureRestrictedMatrixPatternCustom(patternId, opts){
      if(!svgEl) return null;
      const safeId = String(patternId || "").trim();
      if(!safeId) return null;

      let defs = svgEl.querySelector("defs");
      if(!defs){
        defs = document.createElementNS(SVG_NS, "defs");
        svgEl.insertBefore(defs, svgEl.firstChild);
      }
      const existing = svgEl.querySelector(`#${CSS.escape(safeId)}`);
      if(existing){
        // If an older/smaller pattern exists, rebuild it so the wall is continuous across the whole map.
        const isWall = existing.getAttribute("data-wall") === "1";
        const wantW = Math.ceil(camera?.vb?.width || svgEl.viewBox?.baseVal?.width || 0);
        const wantH = Math.ceil(camera?.vb?.height || svgEl.viewBox?.baseVal?.height || 0);
        const curW = Number(existing.getAttribute("width")) || 0;
        const curH = Number(existing.getAttribute("height")) || 0;
        if(isWall && wantW > 0 && wantH > 0 && curW === wantW && curH === wantH){
          return safeId;
        }
        existing.remove();
      }

      const {
        color = "#ffee98",
        opacity = 0.34,
        rotate = 0,
        // When true, the pattern is built to the full map size so fills are seamless across shapes.
        fullMap = true,
        width = 220,
        height = 220,
        fontSize = 10,
        letterSpacing = 0.25,
        lineHeight = 11,
        pad = 0,
        charset = "01ABCDEFGHIJKLMNOPQRSTUVWXYZ$#%*+_",
      } = opts || {};

      const rand = makeRng(safeId);

      const worldW = Math.ceil(camera?.vb?.width || svgEl.viewBox?.baseVal?.width || width);
      const worldH = Math.ceil(camera?.vb?.height || svgEl.viewBox?.baseVal?.height || height);
      const baseW = (fullMap && worldW > 0) ? worldW : width;
      const baseH = (fullMap && worldH > 0) ? worldH : height;

      // Snap tile dimensions to the text grid and overscan; when fullMap=true, this creates one continuous wall.
      const charW = Math.max(5.0, (fontSize * 0.62) + letterSpacing);
      const colsBase = Math.max(32, Math.ceil((baseW - pad * 2) / charW));
      const rowsBase = Math.max(24, Math.ceil((baseH - pad * 2) / lineHeight));
      // Overscan by 2 columns/rows and start negative; this removes visible gaps at tile boundaries.
      const cols = colsBase + 2;
      const rows = rowsBase + 2;
      const tileW = Math.round(colsBase * charW);
      const tileH = Math.round(rowsBase * lineHeight);
      const startX = -charW;
      const startY = -lineHeight;

      const pattern = document.createElementNS(SVG_NS, "pattern");
      pattern.setAttribute("id", safeId);
      pattern.setAttribute("data-wall", "1");
      pattern.setAttribute("patternUnits", "userSpaceOnUse");
      pattern.setAttribute("width", String(tileW));
      pattern.setAttribute("height", String(tileH));
      pattern.setAttribute("patternTransform", `rotate(${rotate})`);

      const g = document.createElementNS(SVG_NS, "g");
      g.setAttribute("opacity", String(opacity));

      const textEl = document.createElementNS(SVG_NS, "text");
      textEl.setAttribute("x", String(startX));
      textEl.setAttribute("y", String(startY));
      textEl.setAttribute("fill", color);
      textEl.setAttribute("font-family", "Rajdhani, sans-serif");
      textEl.setAttribute("font-size", String(fontSize));
      textEl.setAttribute("letter-spacing", String(letterSpacing));
      textEl.setAttribute("font-weight", "800");
      textEl.setAttribute("dominant-baseline", "text-before-edge");

      const pick = () => charset[Math.floor(rand() * charset.length)] || "0";
      for(let r=0;r<rows;r++){
        let line = "";
        for(let c=0;c<cols;c++) line += pick();
        const sp = document.createElementNS(SVG_NS, "tspan");
        sp.setAttribute("x", String(startX));
        sp.setAttribute("dy", r === 0 ? "0" : String(lineHeight));
        sp.textContent = line;
        textEl.appendChild(sp);
      }

      g.appendChild(textEl);
      pattern.appendChild(g);
      defs.appendChild(pattern);
      return safeId;
    }

    function ensureRestrictedMatrixPattern(){
      return ensureRestrictedMatrixPatternCustom(RESTRICTED_MATRIX_PATTERN_ID, {
        color: "#ffee98",
        rotate: 0,
        opacity: 0.34,
        fullMap: true,
        fontSize: 10,
        letterSpacing: 0.25,
        lineHeight: 11,
        pad: 0,
        charset: "01ABCDEFGHIJKLMNOPQRSTUVWXYZ$#%*+_",
      });
    }

    function ensureRestrictedMatrixPatternBlue(){
      return ensureRestrictedMatrixPatternCustom("restricted-matrix-pattern-blue", {
        color: "#d6e8ff",
        rotate: 0,
        opacity: 0.78,
        fullMap: true,
        fontSize: 10,
        letterSpacing: 0.28,
        lineHeight: 11,
        pad: 0,
        charset: "01ABCDEFGHIJKLMNOPQRSTUVWXYZ$#%*+_",
      });
    }

    function ensureRestrictedMatrixPatternSecuroserv(){
      return ensureRestrictedMatrixPatternCustom("restricted-matrix-pattern-securoserv", {
        color: "#ff5a5a",
        opacity: 0.52,
        rotate: 0,
        fullMap: true,
        fontSize: 10,
        letterSpacing: 0.42,
        lineHeight: 11,
        pad: 0,
        charset: "01ACCESSRESTRICTED$#%*+_",
      });
    }

    function ensureRestrictedMatrixPatternCustomOnSvg(targetSvg, patternId, opts){
      if(!targetSvg) return null;
      const safeId = String(patternId || "").trim();
      if(!safeId) return null;

      let defs = targetSvg.querySelector("defs");
      if(!defs){
        defs = document.createElementNS(SVG_NS, "defs");
        targetSvg.insertBefore(defs, targetSvg.firstChild);
      }
      const existing = targetSvg.querySelector(`#${CSS.escape(safeId)}`);
      if(existing){
        const isWall = existing.getAttribute("data-wall") === "1";
        const wantW = Math.ceil(targetSvg.viewBox?.baseVal?.width || 0);
        const wantH = Math.ceil(targetSvg.viewBox?.baseVal?.height || 0);
        const curW = Number(existing.getAttribute("width")) || 0;
        const curH = Number(existing.getAttribute("height")) || 0;
        if(isWall && wantW > 0 && wantH > 0 && curW === wantW && curH === wantH){
          return safeId;
        }
        existing.remove();
      }

      const {
        color = "#ffee98",
        opacity = 0.34,
        rotate = 0,
        fullMap = true,
        width = 220,
        height = 220,
        fontSize = 10,
        letterSpacing = 0.25,
        lineHeight = 11,
        pad = 0,
        charset = "01ABCDEFGHIJKLMNOPQRSTUVWXYZ$#%*+_",
      } = opts || {};

      const rand = makeRng(safeId);

      const worldW = Math.ceil(targetSvg.viewBox?.baseVal?.width || width);
      const worldH = Math.ceil(targetSvg.viewBox?.baseVal?.height || height);
      const baseW = (fullMap && worldW > 0) ? worldW : width;
      const baseH = (fullMap && worldH > 0) ? worldH : height;

      const charW = Math.max(5.0, (fontSize * 0.62) + letterSpacing);
      // Fullscreen overlay: make the tile larger than the viewport and translate it.
      // This guarantees the wall "starts" off-screen and also extends past the edges.
      const overscanX = Math.max(260, Math.round(baseW * 0.25));
      const overscanY = Math.max(140, Math.round(baseH * 0.20));
      const tileW = Math.max(1, Math.round(baseW + overscanX * 2));
      const tileH = Math.max(1, Math.round(baseH + overscanY * 2));
      const cols = Math.max(128, Math.ceil((tileW - pad * 2) / charW) + 48);
      const rows = Math.max(42, Math.ceil((tileH - pad * 2) / lineHeight) + 10);
      const startX = 0;
      const startY = 0;

      const pattern = document.createElementNS(SVG_NS, "pattern");
      pattern.setAttribute("id", safeId);
      pattern.setAttribute("data-wall", "1");
      pattern.setAttribute("patternUnits", "userSpaceOnUse");
      pattern.setAttribute("width", String(tileW));
      pattern.setAttribute("height", String(tileH));
      pattern.setAttribute("patternTransform", `translate(${-overscanX} ${-overscanY}) rotate(${rotate})`);

      const g = document.createElementNS(SVG_NS, "g");
      g.setAttribute("opacity", "0.52");

      const textEl = document.createElementNS(SVG_NS, "text");
      textEl.setAttribute("x", "0");
      textEl.setAttribute("y", "0");
      textEl.setAttribute("fill", "#ff5a5a");
      textEl.setAttribute("font-family", "Rajdhani, sans-serif");
      textEl.setAttribute("font-size", String(10));
      textEl.setAttribute("letter-spacing", String(0.42));
      textEl.setAttribute("font-weight", "800");
      textEl.setAttribute("dominant-baseline", "text-before-edge");

      const pick = () => "01ACCESSRESTRICTED$#%*+_"[Math.floor(Math.random() * 24)];
      for(let r=0;r<rows;r++){
        let line = "";
        for(let c=0;c<cols;c++) line += pick();
        const sp = document.createElementNS(SVG_NS, "tspan");
        sp.setAttribute("x", "0");
        sp.setAttribute("dy", r === 0 ? "0" : String(11));
        sp.textContent = line;
        textEl.appendChild(sp);
      }

      g.appendChild(textEl);
      pattern.appendChild(g);
      defs.appendChild(pattern);
      return safeId;
    }

    function ensureSecuroservFullscreenWall(){
      const wallSvg = document.getElementById("securoservWall");
      if(!wallSvg) return;

      const w = Math.max(1, Math.floor(window.innerWidth || wallSvg.clientWidth || 1));
      const h = Math.max(1, Math.floor(window.innerHeight || wallSvg.clientHeight || 1));
      wallSvg.setAttribute("viewBox", `0 0 ${w} ${h}`);
      wallSvg.setAttribute("width", String(w));
      wallSvg.setAttribute("height", String(h));

      // PERFORMANCE: the old fullscreen pattern generated a massive number of tspans.
      // Use a small repeating tile with prebuilt random-looking text instead.
      const pid = (function ensureSecuroservWallLitePattern(){
        const safeId = "securoserv-wall-lite-pattern";
        if(wallSvg.querySelector(`#${CSS.escape(safeId)}`)) return safeId;

        let defs = wallSvg.querySelector("defs");
        if(!defs){
          defs = document.createElementNS(SVG_NS, "defs");
          wallSvg.insertBefore(defs, wallSvg.firstChild);
        }

        const tileW = 240;
        const tileH = 240;
        const fontSize = 10;
        const letterSpacing = 0.42;
        const lineHeight = 11;
        const charset = "01ACCESSRESTRICTED$#%*+_";

        const rand = makeRng(safeId);
        const charW = Math.max(5.0, (fontSize * 0.62) + letterSpacing);
        const cols = Math.max(12, Math.floor(tileW / charW));
        const rows = Math.max(10, Math.floor(tileH / lineHeight));

        const pattern = document.createElementNS(SVG_NS, "pattern");
        pattern.setAttribute("id", safeId);
        pattern.setAttribute("patternUnits", "userSpaceOnUse");
        pattern.setAttribute("patternUnits", "userSpaceOnUse");
        pattern.setAttribute("width", String(tileW));
        pattern.setAttribute("height", String(tileH));

        const g = document.createElementNS(SVG_NS, "g");
        g.setAttribute("opacity", "0.52");

        const textEl = document.createElementNS(SVG_NS, "text");
        textEl.setAttribute("x", "0");
        textEl.setAttribute("y", "0");
        textEl.setAttribute("fill", "#ff5a5a");
        textEl.setAttribute("font-family", "Rajdhani, sans-serif");
        textEl.setAttribute("font-size", String(fontSize));
        textEl.setAttribute("letter-spacing", String(letterSpacing));
        textEl.setAttribute("font-weight", "800");
        textEl.setAttribute("dominant-baseline", "text-before-edge");

        const pick = () => charset[Math.floor(rand() * charset.length)] || "0";
        for(let r=0;r<rows;r++){
          let line = "";
          for(let c=0;c<cols;c++) line += pick();
          const sp = document.createElementNS(SVG_NS, "tspan");
          sp.setAttribute("x", "0");
          sp.setAttribute("dy", r === 0 ? "0" : String(lineHeight));
          sp.textContent = line;
          textEl.appendChild(sp);
        }

        g.appendChild(textEl);
        pattern.appendChild(g);
        defs.appendChild(pattern);
        return safeId;
      })();

      if(!pid) return;
      let rect = wallSvg.querySelector('rect[data-securoserv-wall="1"]');
      if(!rect){
        rect = document.createElementNS(SVG_NS, "rect");
        rect.setAttribute("data-securoserv-wall", "1");
        wallSvg.appendChild(rect);
      }
      rect.setAttribute("x", "0");
      rect.setAttribute("y", "0");
      rect.setAttribute("width", String(w));
      rect.setAttribute("height", String(h));
      rect.setAttribute("fill", `url(#${pid})`);
    }

    function ensureRestrictedTextPatternCustom(patternId, opts){
      if(!svgEl) return null;
      const safeId = String(patternId || "").trim();
      if(!safeId) return null;

      let defs = svgEl.querySelector("defs");
      if(!defs){
        defs = document.createElementNS(SVG_NS, "defs");
        svgEl.insertBefore(defs, svgEl.firstChild);
      }
      if(svgEl.querySelector(`#${CSS.escape(safeId)}`)) return safeId;

      const {
        bg = "transparent",
        text = "#ffffff",
        textOpacity = 0.34,
        stroke = "currentColor",
        strokeOpacity = 0.30,
        strokeWidth = 1.05,
        fontWeight = 900,
        rotate = -14,
        width = 190,
        height = 48,
        y1 = 4,
        y2 = 20,
        y3 = 36,
        y4 = null,
        fontSize = 10,
        letterSpacing = 1.6,
        textRepeat = 7,
        label = "RESTRICTED ACCESS",
        animDy = null,
        dur = "1.25s",
      } = opts || {};

      const safeHeight = Math.max(32, Number(height) || 32);
      const scrollDy = (animDy == null) ? safeHeight : animDy;

      const pattern = document.createElementNS(SVG_NS, "pattern");
      pattern.setAttribute("id", safeId);
      pattern.setAttribute("patternUnits", "userSpaceOnUse");
      pattern.setAttribute("width", String(width));
      pattern.setAttribute("height", String(safeHeight * 2));
      pattern.setAttribute("patternTransform", `rotate(${rotate})`);

      if(bg && String(bg).toLowerCase() !== "transparent"){
        const rect = document.createElementNS(SVG_NS, "rect");
        rect.setAttribute("width", String(width));
        rect.setAttribute("height", String(height));
        rect.setAttribute("fill", bg);
        pattern.appendChild(rect);
      }

      const safeRepeat = Math.max(3, Number(textRepeat) || 7);
      const numWidth = Math.max(1, Number(width) || 180);
      const numFontSize = Math.max(1, Number(fontSize) || 10);
      const lineLength = Math.max(120, Math.round((numWidth / numFontSize) * safeRepeat * 2.5));
      const charset = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!@#$%^&*()-=+<>?";
      const createRandomLine = () => {
        const chars = [];
        for(let c = 0; c < lineLength; c++){
          chars.push(charset[Math.floor(Math.random() * charset.length)]);
        }
        return chars.join("");
      };

      const createText = (y, x = 0) => {
        const t = document.createElementNS(SVG_NS, "text");
        t.setAttribute("x", String(x));
        t.setAttribute("y", String(y));
        t.setAttribute("dominant-baseline", "text-before-edge");
        t.setAttribute("fill", text);
        t.setAttribute("opacity", String(textOpacity));
        t.setAttribute("stroke", stroke === "currentColor" ? text : stroke);
        t.setAttribute("stroke-opacity", String(strokeOpacity));
        t.setAttribute("stroke-width", String(strokeWidth));
        t.setAttribute("paint-order", "stroke");
        t.setAttribute("font-family", "Rajdhani, sans-serif");
        t.setAttribute("font-size", String(fontSize));
        t.setAttribute("letter-spacing", String(letterSpacing));
        t.setAttribute("font-weight", String(fontWeight));
        t.textContent = createRandomLine();
        return t;
      };

      const baseYs = [y1, y2, y3, y4].filter((val) => typeof val === "number");
      const fallbackYs = [safeHeight * 0.1, safeHeight * 0.35, safeHeight * 0.6, safeHeight * 0.85];
      const combinedYs = baseYs.concat(fallbackYs).slice(0, 4);
      const totalYs = [];
      combinedYs.forEach((yVal) => {
        const y = Number.isFinite(yVal) ? yVal : safeHeight * 0.15;
        totalYs.push(y % (safeHeight * 2));
        totalYs.push((y + safeHeight * 0.5) % (safeHeight * 2));
      });
      const offsets = Array.from({ length: safeRepeat + 2 }, (_, idx) => -width * (0.2 + idx * 0.4));
      totalYs.forEach((rowY) => {
        offsets.forEach((off) => {
          pattern.appendChild(createText(rowY, off));
        });
      });

      const anim = document.createElementNS(SVG_NS, "animateTransform");
      anim.setAttribute("attributeName", "patternTransform");
      anim.setAttribute("type", "translate");
      // One-way infinite scroll (no bounce)
      anim.setAttribute("values", `0 0;0 -${scrollDy}`);
      anim.setAttribute("dur", dur);
      anim.setAttribute("repeatCount", "indefinite");
      anim.setAttribute("additive", "sum");
      pattern.appendChild(anim);

      defs.appendChild(pattern);
      return safeId;
    }

    function ensureRestrictedTextPattern(){
      return ensureRestrictedTextPatternCustom(RESTRICTED_TEXT_PATTERN_ID, {
        bg: "transparent",
        text: "#ffee98",
        textOpacity: 0.34,
        stroke: "#ffee98",
        strokeOpacity: 0.30,
        strokeWidth: 1.05,
        fontWeight: 900,
        rotate: -14,
        width: 150,
        height: 34,
        fontSize: 10,
        letterSpacing: 1.6,
        textRepeat: 7,
        animDy: 34,
        dur: "1.35s",
      });
    }

    function ensureRestrictedTextPatternSecuroserv(){
      return ensureRestrictedTextPatternCustom("restricted-text-pattern-securoserv", {
        text: "#cf0000",
        textOpacity: 0.36,
        stroke: "#cf0000",
        strokeOpacity: 0.32,
        strokeWidth: 1.15,
        fontWeight: 900,
        rotate: -16,
        width: 130,
        height: 30,
        fontSize: 9,
        letterSpacing: 1.3,
        textRepeat: 8,
        animDy: 30,
        dur: "1.15s",
      });
    }

    function ensureSelectionGlowFilter(){
      if(selectionGlowFilter) return selectionGlowFilter;
      if(!svgEl) return null;
      let defs = svgEl.querySelector("defs");
      if(!defs){
        defs = document.createElementNS(SVG_NS, "defs");
        svgEl.insertBefore(defs, svgEl.firstChild);
      }
      let filter = defs.querySelector(`#${SELECTION_GLOW_FILTER_ID}`);
      if(filter){
        selectionGlowFilter = filter;
        selectionGlowAnimation = filter.querySelector("animate");
        return filter;
      }

      filter = document.createElementNS(SVG_NS, "filter");
      filter.setAttribute("id", SELECTION_GLOW_FILTER_ID);
      filter.setAttribute("filterUnits", "objectBoundingBox");
      filter.setAttribute("x", "-40%");
      filter.setAttribute("y", "-40%");
      filter.setAttribute("width", "180%");
      filter.setAttribute("height", "180%");

      const blur = document.createElementNS(SVG_NS, "feGaussianBlur");
      blur.setAttribute("in", "SourceAlpha");
      blur.setAttribute("stdDeviation", "4");
      blur.setAttribute("result", "blur");
      filter.appendChild(blur);

      const inner = document.createElementNS(SVG_NS, "feComposite");
      inner.setAttribute("in", "blur");
      inner.setAttribute("in2", "SourceAlpha");
      inner.setAttribute("operator", "in");
      inner.setAttribute("result", "inner");
      filter.appendChild(inner);

      const flood = document.createElementNS(SVG_NS, "feFlood");
      flood.setAttribute("flood-color", "rgb(var(--selectionGlowColorR,96), var(--selectionGlowColorG,143), var(--selectionGlowColorB,255))");
      flood.setAttribute("flood-opacity", ".32");
      flood.setAttribute("result", "glowColor");
      filter.appendChild(flood);

      const fade = document.createElementNS(SVG_NS, "animate");
      fade.setAttribute("attributeName", "flood-opacity");
      fade.setAttribute("values", "0.32;1.44;0.32");
      fade.setAttribute("keyTimes", "0;0.5;1");
      fade.setAttribute("calcMode", "spline");
      fade.setAttribute("keySplines", "0.4 0 0.2 1;0.4 0 0.2 1");
      fade.setAttribute("dur", "2.2s");
      fade.setAttribute("repeatCount", "indefinite");
      flood.appendChild(fade);
      selectionGlowAnimation = fade;

      const compose = document.createElementNS(SVG_NS, "feComposite");
      compose.setAttribute("in", "glowColor");
      compose.setAttribute("in2", "inner");
      compose.setAttribute("operator", "in");
      compose.setAttribute("result", "glow");
      filter.appendChild(compose);

      const merge = document.createElementNS(SVG_NS, "feMerge");
      const glowNode = document.createElementNS(SVG_NS, "feMergeNode");
      glowNode.setAttribute("in", "glow");
      const sourceNode = document.createElementNS(SVG_NS, "feMergeNode");
      sourceNode.setAttribute("in", "SourceGraphic");
      merge.appendChild(glowNode);
      merge.appendChild(sourceNode);
      filter.appendChild(merge);

      defs.appendChild(filter);
      selectionGlowFilter = filter;
      return filter;
    }

    function updateSelectionGlowColor(glow){
      const filter = ensureSelectionGlowFilter();
      if(!filter) return;
      if(glow){
        filter.style.setProperty('--selectionGlowColorR', glow.r);
        filter.style.setProperty('--selectionGlowColorG', glow.g);
        filter.style.setProperty('--selectionGlowColorB', glow.b);
      }else{
        filter.style.removeProperty('--selectionGlowColorR');
        filter.style.removeProperty('--selectionGlowColorG');
        filter.style.removeProperty('--selectionGlowColorB');
      }
      updateSelectionGlowPeak(glow);
    }

    function updateSelectionGlowPeak(rgb){
      if(!selectionGlowAnimation) return;
      const peak = computeGlowPeak(rgb);
      selectionGlowAnimation.setAttribute("values", `0.32;${peak};0.32`);
    }

    function ensureWastelineMarquee(){
      if(!svgEl) return;
      const NS = "http://www.w3.org/2000/svg";

      const path = svgEl.querySelector("#THE_WASTELINE");
      if(!path) return;
      path.classList.add("wall");

      const parent = path.parentNode;
      if(!parent) return;

      // Remove old layers if any
      svgEl.querySelector("#wastelineMarqueeLayer")?.remove();
      svgEl.querySelector("#wastelineLabelsLayer")?.remove();

      // Get start and end points of the path in screen coordinates
      let L = 0;
      try{ L = path.getTotalLength(); }catch{ L = 0; }
      if(!L || !isFinite(L)) return;

      // Sample points near the ends to calculate angle for rotation
      const sampleDist = Math.min(50, L * 0.05);
      let startPt, startPt2, endPt, endPt2;
      try{
        startPt = path.getPointAtLength(0);
        startPt2 = path.getPointAtLength(sampleDist);
        endPt = path.getPointAtLength(L);
        endPt2 = path.getPointAtLength(L - sampleDist);
      }catch{ return; }

      // Calculate angles at each end
      const startAngle = Math.atan2(startPt2.y - startPt.y, startPt2.x - startPt.x) * (180 / Math.PI);
      const endAngle = Math.atan2(endPt.y - endPt2.y, endPt.x - endPt2.x) * (180 / Math.PI);

      // Create labels layer - put it directly after the path
      const layer = document.createElementNS(NS, "g");
      layer.setAttribute("id", "wastelineLabelsLayer");

      // Copy the path's transform to the labels layer so coordinates match
      const pathTransform = path.getAttribute("transform");
      if(pathTransform) layer.setAttribute("transform", pathTransform);

      // Helper to create a label group at a position (horizontal text)
      // Keep all three lines centered to each other, then shift the whole stack
      // to the outside of the endpoint.
      const createLabelGroup = (x, y, anchorEnd) => {
        const g = document.createElementNS(NS, "g");
        // Position at the point (no rotation; keep text horizontal)
        const groupOffsetX = anchorEnd ? -140 : 140;
        g.setAttribute("transform", `translate(${x}, ${y}) translate(${groupOffsetX}, 0)`);

        // Center each line to THE WASTELINE
        const xOffset = 0;
        const anchor = "middle";

        // WASTELANDS (above the line = negative Y in rotated space)
        const top = document.createElementNS(NS, "text");
        top.classList.add("wastelineEndLabel", "sub");
        top.setAttribute("x", String(xOffset));
        top.setAttribute("y", "-30");
        top.setAttribute("text-anchor", anchor);
        top.textContent = "OUTLANDS";
        g.appendChild(top);

        // THE WASTELINE (center)
        const mid = document.createElementNS(NS, "text");
        mid.classList.add("wastelineEndLabel", "title");
        mid.setAttribute("x", String(xOffset));
        mid.setAttribute("y", "5");
        mid.setAttribute("text-anchor", anchor);
        mid.textContent = "THE OUTLINE";
        g.appendChild(mid);

        // NEON CITY (below the line = positive Y in rotated space)
        const bot = document.createElementNS(NS, "text");
        bot.classList.add("wastelineEndLabel", "sub");
        bot.setAttribute("x", String(xOffset));
        bot.setAttribute("y", "35");
        bot.setAttribute("text-anchor", anchor);
        bot.textContent = "NEON CITY";
        g.appendChild(bot);

        return g;
      };

      // Add labels at start and end (horizontal)
      layer.appendChild(createLabelGroup(startPt.x, startPt.y, false));
      layer.appendChild(createLabelGroup(endPt.x, endPt.y, true));

      // Insert after path
      try{ parent.insertBefore(layer, path.nextSibling); }catch{ try{ parent.appendChild(layer); }catch{} }

      // No animation needed anymore
      wastelineMarquee = null;
    }

    async function loadSvg(){
      try{
        bootSet(55, "download");
        term("[SVG] fetch initiated");

        // --- Download with progress (stream) ---
        bootLine("[SVG] downloading payloadâ€¦");

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 120000); // 120 second timeout
        
        const res = await fetch(SVG_URL, { cache: "no-store", signal: controller.signal });
        clearTimeout(timeoutId);
        if(!res.ok) throw new Error(`Failed to load SVG (${res.status})`);

        const contentLength = res.headers.get("Content-Length");
        const total = contentLength ? parseInt(contentLength, 10) : null;

        // Simplified: just use res.text() regardless
        bootSet(70, "parsing");
        term("[SVG] converting response to textâ€¦");
        const txt = await res.text();
        bootSet(80, "parsing");
        term("[SVG] response received: " + txt.length + " bytes");
        setProgress(0.60, "parsingâ€¦", total ? `${total.toLocaleString()} bytes` : "download complete");
        
        bootSet(85, "rendering");
        term("[SVG] rendering DOMâ€¦");
        host.innerHTML = txt;
        bootSet(87, "rendering");

        // --- Parse & setup phase ---
        bootSet(88, "wiring");
        term("[SVG] parsing complete â€¢ initializingâ€¦");

        svgEl = host.querySelector("svg");
        if(!svgEl) throw new Error("No <svg> element found in file.");

        svgEl.style.maxWidth = "none";
        svgEl.style.maxHeight = "none";

        if(!svgEl.getAttribute("viewBox")){
          const w = parseFloat(svgEl.getAttribute("width")) || 1920;
          const h = parseFloat(svgEl.getAttribute("height")) || 1080;
          svgEl.setAttribute("viewBox", `0 0 ${w} ${h}`);
        }

        // Set camera bounds + lock stack coordinate space to SVG viewBox (1 unit == 1px)
        updateViewport(); // force correct viewport now that layout is real
        const vb = svgEl.viewBox.baseVal;
        camera.vbOrigin = { x: vb.x, y: vb.y };
        // Use stack coordinate space (0..width/height) for camera + overlays
        camera.vb = { x: 0, y: 0, width: vb.width, height: vb.height };

        // Size the stack to world dimensions so camera math uses consistent units.
        // This avoids the old mismatch where SVG/raster were scaled-to-fit but camera was using viewBox units.
        mapStack.style.width = vb.width + "px";
        mapStack.style.height = vb.height + "px";
        svgEl.style.width = vb.width + "px";
        svgEl.style.height = vb.height + "px";

        // Size restricted blur SVG to the same world coordinate space
        const blurSvg = ensureRestrictedBlurSvg();
        if(blurSvg){
          blurSvg.setAttribute("viewBox", `0 0 ${vb.width} ${vb.height}`);
          blurSvg.setAttribute("width", String(vb.width));
          blurSvg.setAttribute("height", String(vb.height));
          blurSvg.style.width = vb.width + "px";
          blurSvg.style.height = vb.height + "px";
          blurSvg.querySelectorAll("image[data-blur-layer]").forEach(im => {
            im.setAttribute("width", String(vb.width));
            im.setAttribute("height", String(vb.height));
          });
        }

        ensureSelectionGlowFilter();
        ensureRestrictedMatrixPattern();
        ensureRestrictedMatrixPatternSecuroserv();

        // Deterministic initial view: centered + fully visible
        resetCameraToFitCenter();
        requestAnimationFrame(resetCameraToFitCenter);

        // Wire up regions
        bootSet(95, "ready");
        bootLine("[SVG] regions wired â€¢ colorizingâ€¦");
        const regions = svgEl.querySelectorAll(".region, [data-region='true']");
        regions.forEach(r => {
          r.classList.add("region");
          r.style.cursor = "pointer";
          r.addEventListener("mousemove", onRegionMove);
          r.addEventListener("mouseenter", onRegionEnter);
          r.addEventListener("mouseleave", onRegionLeave);
          r.addEventListener("click", (e) => {
            e.stopPropagation();
            if(suppressRegionClickOnce){
              suppressRegionClickOnce = false;
              e.preventDefault();
              return;
            }
            selectRegion(r);
          });
        });

        // Build the constant restricted blur mask once regions exist
        rebuildRestrictedBlurClip();

        // Robust hover tracking (fixes edge cases where enter/move can be missed)
        bindGlobalHoverTracking();

        svgEl.querySelectorAll(".region:not(.wall)").forEach(r => {
          r.addEventListener("dblclick", (e) => {
            e.stopPropagation();
            flyToElement(r, 2.6);
          });
        });

        colorizeRegions();
        ensureWastelineMarquee();
        buildDistrictLogos();

        // Clicking empty map should do nothing (selection/popup stays)
        
        // Start animation loop now that SVG is ready
        startTick();

        setProgress(1, "ready", `ok (${regions.length} regions)`);
        bootSet(100, "ready");
        boot.hintEl.textContent = "MAP UNLOCKED";
        bootLine("[OK] map online â€¢ " + regions.length + " regions");
        setTimeout(() => {
          bootClose();
          // Recenter once overlay is gone (viewport might change)
          resetCameraToFitCenter();
          requestAnimationFrame(resetCameraToFitCenter);

          // Ensure popup offset matches final terminal layout
          if(typeof updateDockMetrics === "function"){
            updateDockMetrics();
            requestAnimationFrame(updateDockMetrics);
          }
        }, 250);
        const loadEl = document.getElementById("loadState");
        if(loadEl) loadEl.textContent = "ready";
        term("[SVG] ready â€¢ " + regions.length + " regions loaded");

      }catch(err){
        // show failure
        bootSet(100, "error");
        if(boot.hintEl) boot.hintEl.textContent = "LINK FAILED";
        bootLine("[ERROR] " + err.message);

        term("[ERROR] " + err.message);
        console.error(err);
      }
    }

    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, (m) => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
      }[m]));
    }

    function regionLabel(el){
      const name = el.getAttribute("data-name") || el.id || "(unnamed)";
      const id = el.id ? `#${el.id}` : "(no id)";
      const zone = el.getAttribute("data-zone");
      return { name, id, zone };
    }

    function refreshHoverTab(){
      const el = hoveredEl || selectedEl;
      if(!el){
        tooltip.classList.remove("on");
        tooltip.classList.remove("glitch");
        tooltip.classList.remove("securoserv");
        if(securoservTooltipTimer){
          clearInterval(securoservTooltipTimer);
          securoservTooltipTimer = null;
        }
        return;
      }
      const { name } = regionLabel(el);

      const key = normalizeRegionKey(el.id || el.getAttribute("data-name") || "");
      const isSecuroserv = (key === "SECUROSERV_PORT" || key === "SECUROSERVE_PORT" || key.startsWith("SECUROSERV_"))
        && !securoservBypassedThisSession;

      tooltip.classList.toggle("securoserv", isSecuroserv);

      if(isSecuroserv){
        tooltip.classList.add("glitch");
        tooltip.dataset.base = name;
        if(!securoservTooltipTimer){
          securoservTooltipTimer = setInterval(() => {
            if(!tooltip.classList.contains("on")) return;
            const base = tooltip.dataset.base || "";
            tooltip.textContent = glitchifyText(base, 0.62);
          }, 85);
        }
        tooltip.textContent = glitchifyText(name, 0.62);
      }else{
        tooltip.classList.remove("glitch");
        if(securoservTooltipTimer){
          clearInterval(securoservTooltipTimer);
          securoservTooltipTimer = null;
        }
        tooltip.textContent = name;
      }
      tooltip.classList.add("on");
    }

    function isSecuroservKey(key){
      key = normalizeRegionKey(key || "");
      return (key === "SECUROSERV_PORT" || key === "SECUROSERVE_PORT" || key.startsWith("SECUROSERV_"));
    }

    function glitchifyText(text, intensity = 0.55){
      const s = String(text || "");
      const charset = "01#%$@!+*?/_\\=<>[]{}|";
      let out = "";
      for(let i=0;i<s.length;i++){
        const ch = s[i];
        if(ch === " " || ch === "-" || ch === "/" || ch === ":"){
          out += (Math.random() < intensity * 0.25) ? " " : ch;
          continue;
        }
        if(Math.random() < intensity){
          out += charset[Math.floor(Math.random() * charset.length)];
        }else{
          out += ch;
        }
      }
      // Add a little trailing noise sometimes.
      if(Math.random() < intensity * 0.35) out += " " + charset[Math.floor(Math.random() * charset.length)];
      return out;
    }

    function startSecuroservChaos(){
      const layer = document.getElementById("securoservChaos");
      if(!layer) return;
      layer.replaceChildren();

      const heads = [
        "SECURITY VIOLATION",
        "ACCESS DENIED",
        "TRACE ACTIVE",
        "INTRUSION DETECTED",
        "PROTOCOL LOCKDOWN",
        "FIREWALL BREACH",
        "AUTH FAILURE",
        "SIGNAL JAM",
        "SYS/ERROR",
        "MEM/FAULT",
        "KEY MISMATCH",
        "SESSION HIJACK",
        "ICE DEPLOYED",
      ];

      const modules = ["GATEKEEP", "BLACKICE", "SENTRY", "KERNEL", "AUTH", "UPLINK", "TRACE", "VAULT", "NODES", "GRID", "WATCHDOG"]; 
      const codes = ["0xC0FFEE", "0xDEAD", "0xBEEF", "0xFACADE", "0xBADF00D", "0x0D15EA5E", "0xFEED", "0xE1E7"]; 

      const randHex = (n=8) => {
        const hexd = "0123456789ABCDEF";
        let out = "";
        for(let i=0;i<n;i++) out += hexd[Math.floor(Math.random()*hexd.length)];
        return out;
      };
      const randInt = (a,b) => Math.floor(a + Math.random() * (b-a+1));
      const pick = (arr) => arr[Math.floor(Math.random()*arr.length)];

      const makeBody = (kind) => {
        const mod = pick(modules);
        const code = pick(codes);
        const sid = "S-" + randHex(6);
        const t = randHex(12);
        if(kind === "stack"){
          return [
            `ERR_CODE: ${code}`,
            `MODULE: ${mod}`,
            `SESSION: ${sid}`,
            `TRACE: ACTIVE/${randInt(3,9)}`,
            `STACK:`,
            `  at gate.${mod.toLowerCase()}(${randHex(4)}:${randInt(10,99)})`,
            `  at sec.grid(${randHex(4)}:${randInt(10,99)})`,
            `  at kernel.dispatch(${randHex(4)}:${randInt(10,99)})`,
            `TOKEN: ${t}`,
          ].join("\n");
        }
        if(kind === "modal"){
          return [
            `INTRUSION VECTOR: ${pick(["PHYSICAL", "REMOTE", "SPOOF", "RELAY", "UNKNOWN"])}`,
            `AUTH: FAILED/${randInt(2,7)}`,
            `RESPONSE: ${pick(["QUARANTINE", "LOCKDOWN", "ERASE", "PURGE", "COUNTERTRACE"])}`,
            `SESSION: ${sid}`,
            `TOKEN: ${t}`,
          ].join("\n");
        }
        // default
        return [
          `WARN: integrity mismatch`,
          `MODULE: ${mod}`,
          `ERR_CODE: ${code}`,
          `SESSION: ${sid}`,
          `ACTION: ${pick(["REVOKE", "LOCK", "JAM", "TRACE", "FLAG"])}`,
        ].join("\n");
      };

      const max = SECUROSERV_CHAOS_MAX;
      const addOne = () => {
        if(!document.body.classList.contains("securosserv-mode")) return;
        if(layer.childElementCount >= max) return;

        const pop = document.createElement("div");
        const variantRoll = Math.random();
        const variant = variantRoll < 0.22 ? "variant-small" : variantRoll < 0.48 ? "variant-wide" : variantRoll < 0.72 ? "variant-tall" : variantRoll < 0.86 ? "variant-banner" : "variant-modal";

        const styleRoll = Math.random();
        const style = styleRoll < 0.18 ? "style-toast" : styleRoll < 0.38 ? "style-wire" : styleRoll < 0.58 ? "style-terminal" : styleRoll < 0.76 ? "style-dialog" : styleRoll < 0.90 ? "style-siren" : "style-solid";

        const cut = Math.random() < 0.62;
        const scan = Math.random() < 0.58;
        const glitch = Math.random() < 0.55;
        pop.className = `chaos-pop ${variant} ${style}` + (cut ? " cut" : "") + (scan ? " scan" : "") + (glitch ? " glitch" : "");

        const titlePrefix = Math.random() < 0.45 ? "!! " : Math.random() < 0.25 ? "// " : "";
        const title = titlePrefix + heads[Math.floor(Math.random() * heads.length)];
        const bodyKind = (variant === "variant-tall") ? "stack" : (variant === "variant-modal") ? "modal" : "default";
        const bodyText = makeBody(bodyKind);

        // Template differences by style
        const wantsBar = (style === "style-dialog" || style === "style-terminal" || style === "style-wire") && Math.random() < 0.85;
        const wantsFooter = (style === "style-dialog" || style === "style-toast") && Math.random() < 0.75;
        const wantsCodeBlock = (style === "style-terminal") || (variant === "variant-tall" && Math.random() < 0.65);

        if(wantsBar){
          const bar = document.createElement("div");
          bar.className = "chaos-bar";
          const tag = document.createElement("div");
          tag.className = "tag";
          tag.textContent = "SECUROSERV";
          const meta = document.createElement("div");
          meta.className = "meta";
          meta.textContent = `ERR ${pick(codes)} â€¢ ${pick(modules)}`;
          bar.appendChild(tag);
          bar.appendChild(meta);
          pop.appendChild(bar);
        }

        const h = document.createElement("div");
        h.className = "chaos-h";
        h.textContent = title;
        pop.appendChild(h);

        if(wantsCodeBlock){
          const code = document.createElement("div");
          code.className = "chaos-code";
          code.textContent = bodyText;
          pop.appendChild(code);
        }else{
          const b = document.createElement("div");
          b.className = "chaos-b";
          // Use only the first couple of lines for toast-like styles
          if(style === "style-toast"){
            b.textContent = bodyText.split("\n").slice(0, 2).join(" â€¢ ");
          }else if(style === "style-siren"){
            b.textContent = bodyText.split("\n").slice(0, 3).join("\n");
          }else{
            b.textContent = bodyText;
          }
          pop.appendChild(b);
        }

        if(wantsFooter){
          const foot = document.createElement("div");
          foot.className = "chaos-foot";
          const b1 = document.createElement("span");
          b1.className = "btn";
          b1.textContent = "ACK";
          const b2 = document.createElement("span");
          b2.className = "btn";
          b2.textContent = (Math.random() < 0.5) ? "DISMISS" : "LOCK";
          foot.appendChild(b1);
          foot.appendChild(b2);
          pop.appendChild(foot);
        }

        const vw = window.innerWidth || 1;
        const vh = window.innerHeight || 1;

        // Position rules per variant
        let x = 0, y = 0;
        if(variant === "variant-banner"){
          x = Math.floor((vw * 0.04) + Math.random() * (vw * 0.06));
          y = Math.floor((vh * 0.08) + Math.random() * (vh * 0.12));
        }else if(variant === "variant-modal"){
          x = Math.floor(vw * (0.18 + Math.random() * 0.10));
          y = Math.floor(vh * (0.18 + Math.random() * 0.18));
        }else{
          x = Math.floor(Math.random() * Math.max(1, vw - 260));
          y = Math.floor(Math.random() * Math.max(1, vh - 120));
        }

        pop.style.left = x + "px";
        pop.style.top = y + "px";
        const rot = (Math.random() * 3 - 1.5);
        const scale = 0.92 + Math.random() * 0.16;
        pop.style.transform = `translate3d(0,0,0) rotate(${rot.toFixed(2)}deg) scale(${scale.toFixed(3)})`;
        pop.style.opacity = String(0.58 + Math.random() * 0.38);

        layer.appendChild(pop);
      };

      // Seed a few quickly, then ramp.
      for(let i=0;i<4;i++) addOne();
      if(securoservChaosTimer) clearInterval(securoservChaosTimer);
      securoservChaosTimer = setInterval(addOne, 330);
    }

    function stopSecuroservChaos(){
      if(securoservChaosTimer){
        clearInterval(securoservChaosTimer);
        securoservChaosTimer = null;
      }
      const layer = document.getElementById("securoservChaos");
      if(layer) layer.replaceChildren();
    }

    function setSecuroservGlitchIntensity(v){
      const g = Math.max(0, Math.min(1, Number(v) || 0));
      const screenGlitch = document.getElementById("screenGlitch");
      if(screenGlitch) screenGlitch.style.setProperty("--g", String(g));

      // Also feed the midbar so its glitch strength ramps with the same intensity.
      const mid = document.getElementById("securoservMidbar");
      if(mid) mid.style.setProperty("--g", String(g));
    }

    function stopSecuroservMidbarCountdown(){
      if(securoservMidbarDelayTimer){
        clearTimeout(securoservMidbarDelayTimer);
        securoservMidbarDelayTimer = null;
      }
      if(securoservMidbarTickTimer){
        clearInterval(securoservMidbarTickTimer);
        securoservMidbarTickTimer = null;
      }

      securoservChallengeRevealed = false;
      securoservMidbarProgress = 0;
      securoservSecretStreak = 0;

      const mid = document.getElementById("securoservMidbar");
      if(mid) mid.classList.remove("on");
      const fill = document.getElementById("securoservMidbarFill");
      if(fill) fill.style.width = "0%";
      const pct = document.getElementById("securoservMidbarPct");
      if(pct) pct.textContent = "0%";

      stopSecuroservChallenge(false);

      window.removeEventListener("keydown", handleSecuroservSecretKeydown, true);
    }

    function freezeSecuroservMidbar(){
      if(securoservMidbarDelayTimer){
        clearTimeout(securoservMidbarDelayTimer);
        securoservMidbarDelayTimer = null;
      }
      if(securoservMidbarTickTimer){
        clearInterval(securoservMidbarTickTimer);
        securoservMidbarTickTimer = null;
      }
      // Keep the current UI state (pct/fill) visible.
    }

    function handleSecuroservSecretKeydown(e){
      // Secret bypass: typing 666 before the counterhack window is revealed.
      if(securoservBypassedThisSession) return;
      if(securoservCounterhackResolving) return;
      if(securoservShutdownInProgress) return;
      if(!document.body.classList.contains("securosserv-mode")) return;
      if(securoservChallengeRevealed) return;
      if(!(securoservMidbarProgress < securoservChallengeRevealPct)) return;

      // Only accept the digit 6 as a single keystroke.
      if(!e.key || e.key.length !== 1) return;
      if(e.key !== "6"){
        securoservSecretStreak = 0;
        return;
      }

      e.preventDefault();
      e.stopPropagation();

      securoservSecretStreak++;
      if(securoservSecretStreak >= 3){
        securoservSecretStreak = 0;
        securoservChallengeSolved = true;
        // Pause on success for a beat before launching the success sequence.
        queueSecuroservCounterhackSuccess();
      }
    }

    function queueSecuroservCounterhackSuccess(){
      if(securoservCounterhackResolving) return;
      if(securoservSuccessDelayTimer){
        clearTimeout(securoservSuccessDelayTimer);
        securoservSuccessDelayTimer = null;
      }

      // Freeze the countermeasures exactly as they are and hold for a moment.
      // (Digits stay visible; midbar stops advancing.)
      freezeSecuroservMidbar();
      freezeSecuroservChaos();
      freezeSecuroservEscalation();
      freezeSecuroservChallenge();

      securoservSuccessDelayTimer = setTimeout(() => {
        securoservSuccessDelayTimer = null;
        resolveSecuroservCounterhackSuccess();
      }, 1000);
    }

    function freezeSecuroservChaos(){
      if(securoservChaosTimer){
        clearInterval(securoservChaosTimer);
        securoservChaosTimer = null;
      }
      // Keep existing popups on screen (no replaceChildren).
    }

    function freezeSecuroservEscalation(){
      if(securoservEscalationTimer){
        clearInterval(securoservEscalationTimer);
        securoservEscalationTimer = null;
      }
      // Keep current glitch intensity (no reset).
    }

    function ssRandomSymbol(){
      // Letters + numbers + symbols (kept typeable across common keyboards)
      const charset = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789!@#$%&*+=?/-_";
      return charset[Math.floor(Math.random() * charset.length)];
    }

    function ssSlotEl(i){
      return document.getElementById(`ssSlot${i}`);
    }

    function renderSecuroservChallenge(){
      for(let i=0;i<6;i++){
        const el = ssSlotEl(i);
        if(!el) continue;
        el.textContent = securoservChallengeSymbols[i] || "?";
        el.classList.toggle("ok", i < securoservChallengeIndex);
      }
    }

    function setSecuroservMouseBlock(on){
      const blocker = document.getElementById("inputBlocker");
      if(!blocker) return;
      blocker.classList.toggle("on", Boolean(on));
    }

    function handleSecuroservChallengeKeydown(e){
      if(!securoservChallengeActive) return;
      if(securoservChallengeSolved) return;

      // Never allow ESC to abort the hack.
      if(e.key === "Escape"){
        e.preventDefault();
        e.stopPropagation();
        return;
      }

      // Only accept single printable characters.
      if(!e.key || e.key.length !== 1) return;

      e.preventDefault();
      e.stopPropagation();

      const expected = securoservChallengeSymbols[securoservChallengeIndex] || "";
      const typed = e.key;
      if(!expected) return;

      const isLetter = (c) => {
        const up = c.toUpperCase();
        const lo = c.toLowerCase();
        return up !== lo;
      };

      const ok = isLetter(expected)
        ? (typed.toUpperCase() === expected.toUpperCase())
        : (typed === expected);

      if(!ok) return;

      const lockEl = ssSlotEl(securoservChallengeIndex);
      if(lockEl){
        lockEl.classList.add("ok");
        lockEl.textContent = expected;
      }

      securoservChallengeIndex++;
      if(securoservChallengeIndex >= 6){
        securoservChallengeSolved = true;
        // Ensure all digits show as correct, then pause briefly before success overlay.
        securoservChallengeIndex = 6;
        try{ renderSecuroservChallenge(); }catch{}
        // Generic restricted-area hacks reuse this window, but must NOT trigger the SecuroServ success pipeline.
        if(typeof restrictedHackActive !== "undefined" && restrictedHackActive) return;
        queueSecuroservCounterhackSuccess();
      }
    }

    function startSecuroservChallenge(){
      const mid = document.getElementById("securoservMidbar");
      const challenge = document.getElementById("securoservChallenge");

      // Never (re)show the counterhack window during success resolution or after bypass.
      if(securoservCounterhackResolving) return;
      if(securoservShutdownInProgress) return;
      if(securoservBypassedThisSession) return;
      if(document.body?.classList?.contains?.("counterhack-resolving")) return;
      if(!document.body.classList.contains("securosserv-mode")) return;

      if(challenge) challenge.setAttribute("aria-hidden", "false");
      glitchInHackingUI();

      securoservChallengeSolved = false;
      securoservChallengeActive = true;
      securoservChallengeIndex = 0;
      securoservChallengeSymbols = Array.from({length:6}, () => ssRandomSymbol());
      renderSecuroservChallenge();

      if(securoservChallengeShuffleTimer){
        clearInterval(securoservChallengeShuffleTimer);
        securoservChallengeShuffleTimer = null;
      }
      securoservChallengeShuffleTimer = setInterval(() => {
        if(!securoservChallengeActive) return;
        if(!document.body.classList.contains("securosserv-mode")) return;
        for(let i=securoservChallengeIndex;i<6;i++){
          securoservChallengeSymbols[i] = ssRandomSymbol();
        }
        renderSecuroservChallenge();
        // Also bump glitch a bit while the user is under pressure.
        if(mid) setSecuroservGlitchIntensity(Math.max(0.35, Number(mid.style.getPropertyValue("--g")) || 0));
      }, 2000);

      window.addEventListener("keydown", handleSecuroservChallengeKeydown, true);
    }

    function stopSecuroservChallenge(){
      const challenge = document.getElementById("securoservChallenge");
      if(challenge) challenge.setAttribute("aria-hidden", "true");

      securoservChallengeActive = false;

      if(securoservChallengeShuffleTimer){
        clearInterval(securoservChallengeShuffleTimer);
        securoservChallengeShuffleTimer = null;
      }
      window.removeEventListener("keydown", handleSecuroservChallengeKeydown, true);
    }

    function freezeSecuroservChallenge(){
      // Stop input + symbol shuffling, but keep the UI visible in its final state.
      securoservChallengeActive = false;
      if(securoservChallengeShuffleTimer){
        clearInterval(securoservChallengeShuffleTimer);
        securoservChallengeShuffleTimer = null;
      }
      window.removeEventListener("keydown", handleSecuroservChallengeKeydown, true);
    }

    function counterhackFxShow(text = null){
      const fx = document.getElementById("counterhackFx");
      if(!fx) return;
      try{
        const msg = fx.querySelector('.msg');
        if(msg){
          msg.textContent = (typeof text === 'string' && text.length) ? text : "COUNTERHACK SUCCESFULL";
        }
      }catch{}
      if(counterhackFxOffTimer){
        clearTimeout(counterhackFxOffTimer);
        counterhackFxOffTimer = null;
      }
      fx.classList.remove("fade");
      fx.classList.remove("on");
      void fx.offsetWidth;
      fx.classList.add("on");
    }

    function counterhackFxFadeOutAndHide(ms = 2900){
      const fx = document.getElementById("counterhackFx");
      if(!fx) return;
      fx.classList.add("fade");
      if(counterhackFxOffTimer){
        clearTimeout(counterhackFxOffTimer);
        counterhackFxOffTimer = null;
      }
      counterhackFxOffTimer = setTimeout(() => {
        fx.classList.remove("on");
        fx.classList.remove("fade");
        counterhackFxOffTimer = null;
      }, Math.max(0, ms + 120));
    }

    function cleanupSecuroservToDefault(opts = {}){
      // Stop all SecuroServ systems and restore clean default UI.
      securoservShutdownInProgress = false;
      securoservRebootTriggered = false;

      stopSecuroservMidbarCountdown();
      stopSecuroservChaos();
      stopSecuroservEscalation();
      setSecuroservGlitchIntensity(0);

      const tooltip = document.getElementById("tooltip");
      if(tooltip){
        tooltip.classList.remove("on", "glitch", "securoserv");
        tooltip.textContent = "";
        delete tooltip.dataset.base;
      }
      if(securoservTooltipTimer){
        clearInterval(securoservTooltipTimer);
        securoservTooltipTimer = null;
      }

      if(hoveredEl){
        try{
          hoveredEl.classList.remove('hot');
          clearHotStyle(hoveredEl);
          // Always reset logo highlight when exiting SecuroServ flow.
          setDistrictLogoStateFor(hoveredEl, "base");
        }catch{}
      }
      if(selectedEl){
        try{
          setDistrictLogoStateFor(selectedEl, "base");
        }catch{}
      }
      hoveredEl = null;
      try{ selectedEl = null; }catch{}
      try{ refreshHoverTab(); }catch{}

      document.body?.classList?.remove?.("securosserv-mode");

      if(!opts.skipClearSelection){
        try{ clearSelection(); }catch{}
      }
      try{ showAllDistricts(); }catch{}
      try{ setMenuOn("menuShowAll"); }catch{}
      // Smoothly glide back to the default centered view.
      try{ cameraFlyToFitCenter(2600); }catch{}

      setSecuroservMouseBlock(false);
    }

    function hardResetAfterSecuroservSuccess(){
      // Extra safety net: if the user managed to hover/click during the success overlay,
      // force-clear any stuck "hot" logo state and any lingering SecuroServ wall overlays.
      try{
        svgEl?.querySelectorAll?.('.region.hot')?.forEach?.(r => {
          r.classList.remove('hot');
          clearHotStyle(r);
        });
      }catch{}
      try{ svgEl?.querySelectorAll?.('.region.selected')?.forEach?.(r => r.classList.remove('selected')); }catch{}
      try{ svgEl?.querySelectorAll?.('.region.restricted:not(.wall)')?.forEach?.(r => setRestrictedWallVisibleForRegion(r, false)); }catch{}

      hoveredEl = null;
      try{ selectedEl = null; }catch{}

      try{ document.querySelectorAll('#logosLayer .districtLogo.hot').forEach(n => n.classList.remove('hot')); }catch{}

      document.body?.classList?.remove?.('securosserv-mode');

      try{ document.getElementById('securoservWall')?.classList?.remove?.('on'); }catch{}
      try{ document.getElementById('securoservChaos')?.classList?.remove?.('on'); }catch{}
      try{ document.getElementById('securoservChaos')?.replaceChildren?.(); }catch{}
      try{ document.getElementById('screenGlitch')?.classList?.remove?.('on'); }catch{}
      try{ document.getElementById('securoservMidbar')?.classList?.remove?.('on'); }catch{}

      try{
        if(cursorLogo){
          cursorLogo.classList.remove('on');
          cursorLogo.dataset.key = "";
        }
      }catch{}

      try{ refreshHoverTab(); }catch{}
      try{ updateSelectionGlowColor(null); }catch{}
      try{ updateSelectionDimming(); }catch{}
      try{ updateRestrictedOverlayState(); }catch{}
    }

    async function resolveSecuroservCounterhackSuccess(){
      if(securoservCounterhackResolving) return;
      securoservCounterhackResolving = true;

      // Lock the system in "success resolution" so nothing else can trigger.
      securoservShutdownInProgress = true;
      securoservRebootTriggered = false;

      // Freeze the hack visuals exactly as they are.
      freezeSecuroservMidbar();
      freezeSecuroservChaos();
      freezeSecuroservEscalation();
      freezeSecuroservChallenge();

      document.body?.classList?.add?.("counterhack-resolving");
      counterhackFxShow();

      // Clear selection/wall instantly at the moment of success.
      clearSelectionVisualsImmediatelyForSecuroservSuccess();

      // Crossfade: hack UI disappears as the success overlay fades in.
      await sleep(3000);

      // Ensure the counterhack window cannot flash back on under the success overlay.
      stopSecuroservChallenge();

      // From now until refresh: SecuroServ behaves like a normal restricted area.
      // Set this BEFORE we restore input to guarantee no hack overlays can re-arm.
      securoservBypassedThisSession = true;

      // Restore clean UI + centered map under the success overlay.
      cleanupSecuroservToDefault({ skipClearSelection: true });

      // Keep mouse blocked while the success overlay is still visible. This prevents
      // any accidental hover/click from re-enabling wall/logo states under the fade.
      setSecuroservMouseBlock(true);
      try{ buildDistrictLogos(); }catch{}

      // Force-clear any stuck logo highlight state (can happen if hover was reacquired
      // during the crossfade and the logo layer got rebuilt).
      try{
        document.querySelectorAll('#logosLayer .districtLogo.hot').forEach(n => n.classList.remove('hot'));
      }catch{}

      // Force-clear any stuck SecuroServ overlay state so it cannot reappear once
      // body.counterhack-resolving is removed.
      try{ document.getElementById('securoservWall')?.classList?.remove?.('on'); }catch{}
      try{ document.getElementById('securoservChaos')?.classList?.remove?.('on'); }catch{}
      try{ document.getElementById('securoservChaos')?.replaceChildren?.(); }catch{}
      try{ document.getElementById('screenGlitch')?.classList?.remove?.('on'); }catch{}
      try{ document.getElementById('securoservMidbar')?.classList?.remove?.('on'); }catch{}
      try{ document.getElementById('inputBlocker')?.classList?.remove?.('on'); }catch{}

      try{
        if(cursorLogo){
          cursorLogo.classList.remove('on');
          cursorLogo.dataset.key = "";
        }
      }catch{}

      // Then let the success overlay fade away to reveal the clean state.
      counterhackFxFadeOutAndHide(2900);
      await sleep(3050);

      // Now that the overlay is gone, release the resolving lock.
      document.body?.classList?.remove?.("counterhack-resolving");

      // Final hard reset (covers the case where the user interacted during the overlay).
      hardResetAfterSecuroservSuccess();
      setSecuroservMouseBlock(false);

      securoservCounterhackResolving = false;
    }

    function showCounterhackSuccessFx(){
      // Back-compat wrapper (old behavior). Prefer resolveSecuroservCounterhackSuccess().
      counterhackFxShow();
      setTimeout(() => counterhackFxFadeOutAndHide(2900), 1200);
    }

    function cancelSecuroservCountermeasures(){
      // Abort the countdown and revert to normal without reboot.
      securoservShutdownInProgress = false;
      securoservRebootTriggered = false;

      showCounterhackSuccessFx();

      stopSecuroservMidbarCountdown();
      stopSecuroservChaos();
      stopSecuroservEscalation();
      setSecuroservGlitchIntensity(0);

      // Force-hide the bottom tooltip immediately (mouse may not have moved yet).
      const tooltip = document.getElementById("tooltip");
      if(tooltip){
        tooltip.classList.remove("on", "glitch", "securoserv");
        tooltip.textContent = "";
        delete tooltip.dataset.base;
      }
      if(securoservTooltipTimer){
        clearInterval(securoservTooltipTimer);
        securoservTooltipTimer = null;
      }

      // Clear hover/tooltip glitch if it was stuck.
      if(hoveredEl){
        try{
          hoveredEl.classList.remove('hot');
          clearHotStyle(hoveredEl);
          setDistrictLogoStateFor(hoveredEl, hoveredEl === selectedEl ? "selected" : "base");
        }catch{}
      }
      hoveredEl = null;
      try{ selectedEl = null; }catch{}
      try{ refreshHoverTab(); }catch{}
      try{ updateSelectionGlowColor(null); }catch{}
      try{ updateSelectionDimming(); }catch{}
      try{ updateRestrictedOverlayState(); }catch{}
    }

    function startSecuroservMidbarCountdown(){
      if(securoservMidbarDelayTimer || securoservMidbarTickTimer) return;
      const mid = document.getElementById("securoservMidbar");
      const fill = document.getElementById("securoservMidbarFill");
      const pct = document.getElementById("securoservMidbarPct");
      if(!mid || !fill || !pct) return;

      // "after few seconds"
      securoservMidbarDelayTimer = setTimeout(() => {
        securoservMidbarDelayTimer = null;
        if(!document.body.classList.contains("securosserv-mode")) return;
        if(securoservShutdownInProgress) return;

        mid.classList.add("on");

        // Secret bypass listener (only relevant before the counterhack window reveals).
        securoservSecretStreak = 0;
        window.removeEventListener("keydown", handleSecuroservSecretKeydown, true);
        window.addEventListener("keydown", handleSecuroservSecretKeydown, true);

        // Reveal the user counterhack window at a fixed point of the red bar.
        securoservChallengeRevealed = false;
        securoservChallengeRevealPct = 0.20;

        // End the countermeasures early so the post-reveal time window stays the same.
        // Old behavior: reveal at 35% and end at 100%.
        // New behavior: reveal at 20% and end at 85% (15% shorter), keeping the same
        // amount of time between reveal and the end of countermeasures.
        const endPct = 0.85;

        // Extend total duration by the same amount of time it takes to reach that point.
        // This is satisfied by: dur = base / (1 - pct), because (dur - base) == (dur * pct).
        const baseDur = 20000;
        const dur = Math.round(baseDur * endPct / (endPct - securoservChallengeRevealPct));
        const t0 = performance.now();

        securoservMidbarTickTimer = setInterval(() => {
          if(!document.body.classList.contains("securosserv-mode")){
            stopSecuroservMidbarCountdown();
            return;
          }
          const t = (performance.now() - t0) / dur;
          const k = Math.max(0, Math.min(endPct, t * endPct));
          securoservMidbarProgress = k;
          const p = Math.round(k * 100);
          fill.style.width = p + "%";
          pct.textContent = p + "%";

          if(!securoservChallengeRevealed && k >= securoservChallengeRevealPct){
            securoservChallengeRevealed = true;
            startSecuroservChallenge();
          }

          if(t >= 1){
            stopSecuroservMidbarCountdown();
            // If user didn't solve the code (still in SecuroServ), trigger shutdown.
            if(document.body.classList.contains("securosserv-mode") && !securoservChallengeSolved){
              runSecuroservShutdownAndReboot();
            }
          }
        }, 50);
      }, 2800);
    }

    async function runSecuroservShutdownAndReboot(){
      if(securoservRebootTriggered || securoservShutdownInProgress) return;
      securoservRebootTriggered = true;
      securoservShutdownInProgress = true;

      // Freeze any new countdown triggers.
      stopSecuroservMidbarCountdown();

      // Stop high-frequency UI spam before reboot overlay.
      stopSecuroservChaos();
      if(securoservEscalationTimer){
        clearInterval(securoservEscalationTimer);
        securoservEscalationTimer = null;
      }
      if(securoservTooltipTimer){
        clearInterval(securoservTooltipTimer);
        securoservTooltipTimer = null;
      }

      // Screen turning off effect (after the initial SecuroServ loading completes).
      const screenOff = document.getElementById("screenOff");
      if(screenOff){
        screenOff.classList.remove("fadeout");
        screenOff.classList.remove("black");
        screenOff.classList.remove("on");
        screenOff.classList.add("on");
      }
      document.body.classList.add("powering-off");

      // Let the power-off animation play over the map.
      await sleep(760);

      // Hold on a dark screen a bit longer after the "turn off".
      if(screenOff){
        screenOff.classList.add("black");
      }
      await sleep(720);

      // Show boot overlay again in SecuroServ reboot mode (simple: logo + bar + bg code).
      if(boot.el){
        boot.el.classList.remove("hidden");
        boot.el.classList.remove("off");
        boot.el.classList.remove("softclose");
        boot.el.classList.remove("blackout");
        boot.el.classList.remove("ss-showbar");
        boot.el.classList.add("securosserv-reboot");
      }

      // Fade out the screen-off layer once the reboot overlay is up.
      if(screenOff){
        screenOff.classList.add("fadeout");
        setTimeout(() => {
          screenOff.classList.remove("on");
          screenOff.classList.remove("fadeout");
          screenOff.classList.remove("black");
          document.body.classList.remove("powering-off");
        }, 2300);
      }

      // Punch the glitch up during reboot.
      setSecuroservGlitchIntensity(1);

      // Keep the red palette during SecuroServ reboot.
      document.body?.classList?.add?.("securosserv-mode");

      const ssFill = document.getElementById("bootSecuroFill");
      const ssPct = document.getElementById("bootSecuroPct");
      const ssPhase = document.getElementById("bootSecuroPhase");
      if(ssFill) ssFill.style.width = "0%";
      if(ssPct) ssPct.textContent = "0%";
      if(ssPhase) ssPhase.textContent = "reboot";

      // Background code writer (behind the bar)
      const bg = document.getElementById("bootBgCode");
      if(bg) bg.textContent = "";
      if(bootBgCodeTimer){
        clearInterval(bootBgCodeTimer);
        bootBgCodeTimer = null;
      }
      const codeWords = [
        "PROC", "KERNEL", "AUTH", "ICE", "TRACE", "UPLINK", "VAULT", "GRID", "SENTRY", "LOCK", "SHIM", "NODE", "MUX", "PACKET", "SIG", "HASH"
      ];
      const hex = () => {
        const h = "0123456789ABCDEF";
        let out = "";
        for(let i=0;i<8;i++) out += h[Math.floor(Math.random()*h.length)];
        return out;
      };
      const line = () => {
        const w = codeWords[Math.floor(Math.random()*codeWords.length)];
        const w2 = codeWords[Math.floor(Math.random()*codeWords.length)];
        const n = Math.floor(10 + Math.random()*90);
        return `${w}.${w2}(${n}) :: 0x${hex()} 0x${hex()}  [${Math.floor(Math.random()*9)}:${Math.floor(Math.random()*9)}]`;
      };
      bootBgCodeTimer = setInterval(() => {
        if(!bg) return;
        bg.textContent += line() + "\n";
        // Keep it from growing forever
        const maxChars = 24000;
        if(bg.textContent.length > maxChars){
          bg.textContent = bg.textContent.slice(bg.textContent.length - maxChars);
        }
      }, 55);

      // Start with only code flying; reveal logo+bar after a beat.
      await sleep(1050);
      if(boot.el) boot.el.classList.add("ss-showbar");

      // Simple SecuroServ reboot bar with spinning logo.
      const ssDur = 6200;
      const ssT0 = performance.now();
      while(true){
        const t = (performance.now() - ssT0) / ssDur;
        const k = Math.max(0, Math.min(1, t));
        const p = Math.round(k * 100);
        if(ssFill) ssFill.style.width = p + "%";
        if(ssPct) ssPct.textContent = p + "%";
        if(k >= 1) break;
        await sleep(70);
      }

      // Stop background writer.
      if(bootBgCodeTimer){
        clearInterval(bootBgCodeTimer);
        bootBgCodeTimer = null;
      }

      // Go full black (opaque) using the boot overlay itself.
      if(boot.el) boot.el.classList.add("blackout");
      await sleep(820);

      // Reset map state while the blue/yellow boot comes back.
      setSecuroservGlitchIntensity(0);
      document.body?.classList?.remove?.("securosserv-mode");
      try{ clearSelection(); }catch{}
      try{ showAllDistricts(); }catch{}
      try{ setMenuOn("menuShowAll"); }catch{}
      try{ resetCameraToFitCenter(); requestAnimationFrame(resetCameraToFitCenter); }catch{}

      // Clear hover/tooltip so the bottom tab doesn't stay on SecuroServ.
      try{
        if(hoveredEl){
          hoveredEl.classList.remove('hot');
          clearHotStyle(hoveredEl);
          setDistrictLogoStateFor(hoveredEl, "base");
        }
        hoveredEl = null;
        refreshHoverTab();
        if(cursorLogo) cursorLogo.classList.remove('on');
      }catch{}

      // Bring back the normal blue/yellow boot UI gradually.
      if(boot.el){
        boot.el.classList.remove("securosserv-reboot");
        boot.el.classList.remove("ss-showbar");
      }

      const top = boot.el?.querySelector?.(".boot-top");
      const mid = boot.el?.querySelector?.(".boot-mid");
      const foot = boot.el?.querySelector?.(".boot-foot");
      const resetPart = (el) => {
        if(!el) return;
        el.style.opacity = "0";
        el.style.transform = "translate3d(0,10px,0)";
        el.style.transition = "opacity .9s ease, transform .9s ease";
      };
      resetPart(top);
      resetPart(mid);
      resetPart(foot);
      await sleep(120);

      // Fade from full black into the boot dark-blue background.
      if(boot.el) boot.el.classList.remove("blackout");
      await sleep(140);

      const showPart = (el) => {
        if(!el) return;
        el.style.opacity = "1";
        el.style.transform = "translate3d(0,0,0)";
      };
      showPart(top);
      await sleep(520);
      showPart(mid);
      await sleep(620);
      showPart(foot);
      await sleep(820);

      // Blue/yellow boot pass (single) â€” no real page restart.
      if(boot.linesEl) boot.linesEl.innerHTML = "";
      bootSet(0, "handshake");
      bootLine("[BOOT] initializing map interfaceâ€¦");
      await sleep(220);
      bootSet(18, "handshake");
      bootLine("[NET] link stable â€¢ encryption ok");
      await sleep(240);
      bootSet(40, "mount");
      bootLine("[FS] mounting local assetâ€¦");
      await sleep(240);
      bootSet(62, "restore");
      bootLine("[MAP] restoring baseline camera â€¢ clearing volatile state");
      await sleep(260);
      bootSet(86, "ready");
      bootLine("[OK] map online");
      await sleep(280);
      bootSet(100, "ready");

      bootClose();
      await sleep(520);

      securoservShutdownInProgress = false;
      securoservRebootTriggered = false;
    }

    function startSecuroservEscalation(){
      if(securoservEscalationTimer) return;
      securoservRebootTriggered = false;
      securoservShutdownInProgress = false;
      const t0 = performance.now();
      securoservEscalationTimer = setInterval(() => {
        if(!document.body.classList.contains("securosserv-mode")){
          setSecuroservGlitchIntensity(0);
          return;
        }

        const chaos = document.getElementById("securoservChaos");
        const count = Number(chaos?.childElementCount || 0);
        const fill = Math.max(0, Math.min(1, count / SECUROSERV_CHAOS_MAX));
        const timeRamp = Math.max(0, Math.min(1, (performance.now() - t0) / 10000));

        // Make the ramp visibly increase (not "stuck" at low values).
        const timeCurve = Math.pow(timeRamp, 0.70);
        const fillCurve = Math.pow(fill, 0.65);
        const intensity = Math.max(0.12, Math.min(1, (timeCurve * 0.82) + (fillCurve * 0.55)));

        setSecuroservGlitchIntensity(intensity);
      }, 120);
    }

    function stopSecuroservEscalation(){
      if(securoservEscalationTimer){
        clearInterval(securoservEscalationTimer);
        securoservEscalationTimer = null;
      }
      setSecuroservGlitchIntensity(0);
    }

    function setCursorLogoFor(el){
      if(!cursorLogo) return;
      if(!el || el.classList.contains("wall")){
        cursorLogo.classList.remove("on");
        return;
      }

      // Naming convention: ./<NORMALIZED_REGION_ID>.png
      // Example: id="MERRYWEATHER_BASE" -> ./MERRYWEATHER_BASE.png
      const key = normalizeRegionKey(el.id || el.getAttribute("data-name") || "");
      if(!key){
        cursorLogo.classList.remove("on");
        return;
      }

      // Show SecuroServ logo only after bypass.
      if(key === "SECUROSERV_PORT" || key === "SECUROSERVE_PORT" || key.startsWith("SECUROSERV_")){
        if(!securoservBypassedThisSession){
          cursorLogo.classList.remove("on");
          cursorLogo.dataset.key = "";
          return;
        }

        const ssKey = "SECUROSERV_LOGO";
        const shouldReload = (cursorLogo.dataset.key !== ssKey) || (cursorLogo.dataset.failed === "1");
        cursorLogo.dataset.key = ssKey;

        if(shouldReload){
          cursorLogo.classList.remove("on");
          const bust = (cursorLogo.dataset.failed === "1") ? `?v=${Date.now()}` : "";
          const files = [`securoserv_port.png${bust}`, `${key}.png${bust}`];
          setImgCandidates(cursorLogo, expandLogoPaths(files));
        }else{
          cursorLogo.classList.add("on");
        }
        return;
      }

      const shouldReload = (cursorLogo.dataset.key !== key) || (cursorLogo.dataset.failed === "1");
      cursorLogo.dataset.key = key;

      if(shouldReload){
        cursorLogo.classList.remove("on"); // wait for load
        // Only cache-bust when retrying a previously-failed load
        const bust = (cursorLogo.dataset.failed === "1") ? `?v=${Date.now()}` : "";
        const files = [`${key}.png${bust}`];
        setImgCandidates(cursorLogo, expandLogoPaths(files));
      }else{
        // Same key, already loaded previously: show immediately.
        cursorLogo.classList.add("on");
      }
    }

    function setDetailLogoFor(el){
      if(!detailLogo) return;
      if(!el || el.classList.contains("wall")){
        detailLogo.classList.remove("on");
        detailLogo.dataset.key = "";
        detailLogo.dataset.logoCandidates = "[]";
        detailLogo.dataset.logoIndex = "0";
        detailLogo.removeAttribute("src");
        return;
      }

      const key = normalizeRegionKey(el.id || el.getAttribute("data-name") || "");
      if(!key){
        detailLogo.classList.remove("on");
        detailLogo.dataset.key = "";
        detailLogo.dataset.logoCandidates = "[]";
        detailLogo.dataset.logoIndex = "0";
        detailLogo.removeAttribute("src");
        return;
      }

      // Show SecuroServ logo only after bypass.
      if(key === "SECUROSERV_PORT" || key === "SECUROSERVE_PORT" || key.startsWith("SECUROSERV_")){
        if(!securoservBypassedThisSession){
          detailLogo.classList.remove("on");
          detailLogo.dataset.key = "";
          detailLogo.removeAttribute("src");
          return;
        }

        detailLogo.dataset.key = "SECUROSERV_LOGO";
        detailLogo.classList.remove("on");
        setImgCandidates(detailLogo, expandLogoPaths(["securoserv_port.png", `${key}.png`]));
        return;
      }

      detailLogo.dataset.key = key;
      detailLogo.classList.remove("on"); // wait for load
      setImgCandidates(detailLogo, expandLogoPaths([`${key}.png`]));
    }

    function moveCursorLogo(e){
      if(!cursorLogo || !cursorLogo.dataset.key) return;
      const wrapRect = mapwrap.getBoundingClientRect();
      const x = e.clientX - wrapRect.left;
      const y = e.clientY - wrapRect.top;
      cursorLogo.style.left = x + "px";
      cursorLogo.style.top = y + "px";
    }

    function regionFromClientPoint(clientX, clientY){
      const el = document.elementFromPoint(clientX, clientY);
      return el?.closest?.('.region') || null;
    }

    function restackRegionLayers(){
      if(!svgEl) return;

      const layered = Array.from(svgEl.querySelectorAll('.region, .wall'));
      const parents = Array.from(new Set(layered.map(r => r.parentNode).filter(Boolean)));
      parents.forEach((p) => {
        const direct = Array.from(p.children).filter(n => n?.classList && (n.classList.contains('region') || n.classList.contains('wall')));
        if(direct.length < 2) return;

        const normals = direct.filter(n => n.classList.contains('region') && !n.classList.contains('wall') && !n.classList.contains('restricted'));
        const restricted = direct.filter(n => n.classList.contains('region') && !n.classList.contains('wall') && n.classList.contains('restricted'));
        const walls = direct.filter(n => n.classList.contains('wall'));

        normals.forEach(n => p.appendChild(n));
        restricted.forEach(n => p.appendChild(n));
        walls.forEach(n => p.appendChild(n));
      });

      // Keep current selection at the top of its layer.
      keepSelectedOnTop();
    }

    function bringRegionToFront(el){
      if(!el || !el.parentNode) return;

      // SVG paint order follows DOM order: later siblings render on top.
      // Layering rule: normal < restricted < walls (restricted always above normal).
      const p = el.parentNode;
      const kids = Array.from(p.children).filter(n => n?.classList && (n.classList.contains('region') || n.classList.contains('wall')));

      const firstWall = kids.find(n => n.classList.contains('wall')) || null;
      const firstRestricted = kids.find(n => n.classList.contains('restricted') && !n.classList.contains('wall')) || null;

      if(el.classList.contains('wall')){
        p.appendChild(el);
        return;
      }

      if(el.classList.contains('restricted')){
        // Place at end of restricted layer (just before walls).
        if(firstWall) p.insertBefore(el, firstWall);
        else p.appendChild(el);
        return;
      }

      // Normal: place at end of normal layer (just before first restricted, else before walls).
      if(firstRestricted) p.insertBefore(el, firstRestricted);
      else if(firstWall) p.insertBefore(el, firstWall);
      else p.appendChild(el);
    }

    function keepSelectedOnTop(){
      if(!selectedEl) return;
      // If hover reorders DOM, re-position selected at the top of its layer.
      bringRegionToFront(selectedEl);
    }

    function parseCssColorToRgb(color){
      const c = String(color || "").trim();
      if(!c) return null;

      // #RRGGBB
      const hex = c.startsWith('#') ? c.slice(1) : c;
      if(/^[0-9a-fA-F]{6}$/.test(hex)){
        return {
          r: parseInt(hex.slice(0,2), 16),
          g: parseInt(hex.slice(2,4), 16),
          b: parseInt(hex.slice(4,6), 16),
        };
      }

      // rgb()/rgba()
      const m = c.match(/rgba?\(\s*([0-9.]+)\s*,\s*([0-9.]+)\s*,\s*([0-9.]+)(?:\s*,\s*([0-9.]+))?\s*\)/i);
      if(m){
        return { r: Math.round(Number(m[1])), g: Math.round(Number(m[2])), b: Math.round(Number(m[3])) };
      }

      // Modern syntax: rgb(r g b / a)
      const m2 = c.match(/rgb\(\s*([0-9.]+)\s+([0-9.]+)\s+([0-9.]+)(?:\s*\/\s*([0-9.]+))?\s*\)/i);
      if(m2){
        return { r: Math.round(Number(m2[1])), g: Math.round(Number(m2[2])), b: Math.round(Number(m2[3])) };
      }

      return null;
    }

    function rgbToHsl(rgb){
      const r = rgb.r / 255;
      const g = rgb.g / 255;
      const b = rgb.b / 255;
      const max = Math.max(r,g,b);
      const min = Math.min(r,g,b);
      const l = (max + min) / 2;
      if(max === min){
        return { h: 0, s: 0, l };
      }
      const d = max - min;
      const s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      let h;
      switch(max){
        case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
        case g: h = ((b - r) / d + 2) / 6; break;
        default: h = ((r - g) / d + 4) / 6; break;
      }
      return { h, s, l };
    }

    function hslToRgb(hsl){
      const { h, s, l } = hsl;
      if(s === 0){
        const val = Math.round(l * 255);
        return { r: val, g: val, b: val };
      }
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      const hue2rgb = (p, q, t) =>{
        if(t < 0) t += 1;
        if(t > 1) t -= 1;
        if(t < 1/6) return p + (q - p) * 6 * t;
        if(t < 1/2) return q;
        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      };
      return {
        r: Math.round(hue2rgb(p, q, h + 1/3) * 255),
        g: Math.round(hue2rgb(p, q, h) * 255),
        b: Math.round(hue2rgb(p, q, h - 1/3) * 255),
      };
    }

    function boostGlowColor(rgb){
      if(!rgb) return null;
      const hsl = rgbToHsl(rgb);
      const minLightness = 0.65;
      if(hsl.l >= minLightness) return rgb;
      return hslToRgb({ ...hsl, l: minLightness });
    }

    function computeGlowPeak(rgb){
      const base = rgb
        ? (0.2126 * rgb.r + 0.7152 * rgb.g + 0.0722 * rgb.b) / 255
        : 0.45;
      const extra = (1 - base) * 1.6;
      return clamp(1.44 + extra, 1.44, 3.0);
    }

    function brightenRgb(rgb, factor){
      const f = Number(factor) || 1;
      return {
        r: clamp(Math.round(rgb.r * f), 0, 255),
        g: clamp(Math.round(rgb.g * f), 0, 255),
        b: clamp(Math.round(rgb.b * f), 0, 255),
      };
    }

    function applyHotStyle(el){
      if(!el || el.classList.contains('selected')) return;

      // Prefer current inline stroke (district overrides), else computed.
      const stroke = el.style.stroke || getComputedStyle(el).stroke || "";
      const base = parseCssColorToRgb(stroke);
      if(!base) return;
      const hot = brightenRgb(base, 1.25);
      // Brighten the actual border color by temporarily overriding inline stroke.
      if(el.dataset.baseStrokeInline === undefined){
        el.dataset.baseStrokeInline = el.style.stroke || "";
      }
      el.style.stroke = `rgb(${hot.r}, ${hot.g}, ${hot.b})`;

      el.style.setProperty('--hotGlow1', `rgba(${hot.r}, ${hot.g}, ${hot.b}, 0.28)`);
      el.style.setProperty('--hotGlow2', `rgba(${hot.r}, ${hot.g}, ${hot.b}, 0.16)`);
    }

    function clearHotStyle(el){
      if(!el) return;
      el.style.removeProperty('--hotGlow1');
      el.style.removeProperty('--hotGlow2');

      if(el.dataset.baseStrokeInline !== undefined){
        const prev = el.dataset.baseStrokeInline;
        delete el.dataset.baseStrokeInline;
        if(prev){
          el.style.stroke = prev;
        }else{
          el.style.removeProperty('stroke');
        }
      }
    }

    let globalHoverBound = false;
    function bindGlobalHoverTracking(){
      if(globalHoverBound) return;
      globalHoverBound = true;

      mapwrap.addEventListener('pointermove', (e) => {
        if(document.body?.classList?.contains?.('counterhack-resolving')) return;
        if(!svgEl) return;
        const r = regionFromClientPoint(e.clientX, e.clientY);

        if(r && hoveredEl !== r){
          const prev = hoveredEl;
          if(prev){
            prev.classList.remove('hot');
            clearHotStyle(prev);
            setDistrictLogoStateFor(prev, prev === selectedEl ? "selected" : "base");
          }
          hoveredEl = r;
          hoveredEl.classList.add('hot');
          applyHotStyle(hoveredEl);
          bringRegionToFront(r);
          keepSelectedOnTop();
          setDistrictLogoStateFor(hoveredEl, hoveredEl === selectedEl ? "selected" : "hover");
          refreshHoverTab();
          setCursorLogoFor(r);
        }else if(!r && hoveredEl){
          hoveredEl.classList.remove('hot');
          clearHotStyle(hoveredEl);
          setDistrictLogoStateFor(hoveredEl, hoveredEl === selectedEl ? "selected" : "base");
          hoveredEl = null;
          refreshHoverTab();
          if(cursorLogo) cursorLogo.classList.remove('on');
        }

        moveCursorLogo(e);
      }, { passive:true });

      mapwrap.addEventListener('pointerleave', () => {
        if(hoveredEl){
          hoveredEl.classList.remove('hot');
          clearHotStyle(hoveredEl);
          setDistrictLogoStateFor(hoveredEl, hoveredEl === selectedEl ? "selected" : "base");
        }
        hoveredEl = null;
        refreshHoverTab();
        if(cursorLogo) cursorLogo.classList.remove('on');
      });
    }

    function onRegionMove(e){
      // Cursor-following district logo (title is handled as a bottom tab)
      const r = e.target.closest('.region');
      if(r && hoveredEl !== r){
        hoveredEl = r;
        refreshHoverTab();
        setCursorLogoFor(r);
      }
      moveCursorLogo(e);
    }

    function onRegionEnter(e){
      const r = e.target.closest('.region');
      if(!r) return;
      hoveredEl = r;
      r.classList.add('hot');
      applyHotStyle(r);
      bringRegionToFront(r);
      keepSelectedOnTop();
      refreshHoverTab();

      setDistrictLogoStateFor(r, r === selectedEl ? "selected" : "hover");

      if(r.classList.contains("restricted") && !r.classList.contains("selected")){
        setStripeThicknessForRegion(r, "hover");
      }
    }

    function onRegionLeave(e){
      const r = e.target.closest('.region');
      if(r){
        r.classList.remove('hot');
        clearHotStyle(r);
      }
      if(r && r.classList.contains("restricted")){
        setStripeThicknessForRegion(r, r.classList.contains("selected") ? "selected" : "base");
      }

      if(hoveredEl === r) hoveredEl = null;
      refreshHoverTab();

      if(r){
        setDistrictLogoStateFor(r, r.classList.contains("selected") ? "selected" : "base");
      }
    }

    function selectRegion(el){
      console.log('[DEBUG] selectRegion called', el && (el.id || el.getAttribute('data-name')));
      if(document.body?.classList?.contains?.('counterhack-resolving')) return;
      if((typeof restrictedHackActive !== "undefined") && restrictedHackActive) return;
      if(selectedEl === el) return;
      bringRegionToFront(el);

      // If the user clicks while hovering, clear the temporary hover-brightened stroke
      // so selection uses the true base stroke.
      try{
        if(el?.classList?.contains?.('hot')){
          el.classList.remove('hot');
          clearHotStyle(el);
        }
      }catch{}

      const prev = selectedEl;
      if(prev) {
        prev.classList.remove("selected");
      }

      // Hide wall-of-text for the previous restricted selection.
      if(prev && prev.classList.contains('restricted')){
        setRestrictedWallVisibleForRegion(prev, false);
      }

      selectedEl = el;
      console.log('[DEBUG] selectedEl set', selectedEl && (selectedEl.id || selectedEl.getAttribute('data-name')));
      if(selectedEl) selectedEl.classList.add("selected");

      // Show wall-of-text only when a restricted zone is selected AND still locked.
      if(selectedEl && selectedEl.classList.contains('restricted')){
        const normKey = normalizeRegionKey(selectedEl.id || selectedEl.getAttribute("data-name") || "");
        const genericUnlocked = Boolean(normKey && !isSecuroservKey(normKey) && unlockedRestrictedIntel.has(normKey));
        setRestrictedWallVisibleForRegion(selectedEl, !genericUnlocked);
      }

      // Ensure selection stays top even if the click happened during hover.
      keepSelectedOnTop();

      // Re-apply fill visibility rules now that selection changed.
      try{ colorizeRegions(); }catch{}

      // Update district logo states
      if(prev) setDistrictLogoStateFor(prev, prev === hoveredEl ? "hover" : "base");
      if(selectedEl) setDistrictLogoStateFor(selectedEl, "selected");

      function getRestrictedThemeForKey(normKey){
        const k = normalizeRegionKey(normKey);

        // Requested mapping:
        // - Merryweather base: yellow
        // - APEX + PRISON: yellow
        // - SecuroServ: red
        if(k === "MERRYWEATHER_BASE") return { theme: "yellow", glow: { r: 255, g: 238, b: 152 } };
        if(k === "NEON_CITY_PRISON" || k === "APEX" || k === "APEX_HQ" || k.startsWith("APEX_")) return { theme: "yellow", glow: { r: 255, g: 238, b: 152 } };
        if(k === "SECUROSERV_PORT" || k === "SECUROSERVE_PORT" || k.startsWith("SECUROSERV_")) return { theme: "red", glow: { r: 255, g: 65, b: 65 } };

        // Default restricted theme (keeps existing look)
        return { theme: "yellow", glow: { r: 255, g: 238, b: 152 } };
      }

      if(selectedEl){
        const isRestricted = selectedEl.classList.contains("restricted");
        if(isRestricted){
          const normKey = normalizeRegionKey(selectedEl.id || selectedEl.getAttribute("data-name") || "");
          const genericUnlocked = Boolean(normKey && !isSecuroservKey(normKey) && unlockedRestrictedIntel.has(normKey));
          if(genericUnlocked){
            // Unlocked restricted areas should not have the restricted glow.
            updateSelectionGlowColor(null);
          }else{
            const themed = getRestrictedThemeForKey(normKey);
            updateSelectionGlowColor(boostGlowColor(themed.glow));
          }
        }else{
          const strokeColor = getComputedStyle(selectedEl).stroke || "";
          const glow = parseCssColorToRgb(strokeColor);
          updateSelectionGlowColor(boostGlowColor(glow));
        }
      }else{
        updateSelectionGlowColor(null);
      }

      if(prev && prev.classList.contains("restricted")){
        setStripeThicknessForRegion(prev, "base");
      }
      if(selectedEl && selectedEl.classList.contains("restricted")){
        const normKey = normalizeRegionKey(selectedEl.id || selectedEl.getAttribute("data-name") || "");
        const genericUnlocked = Boolean(normKey && !isSecuroservKey(normKey) && unlockedRestrictedIntel.has(normKey));
        setStripeThicknessForRegion(selectedEl, genericUnlocked ? "base" : "selected");
      }

      refreshHoverTab();
      updateSelectionDimming();
      updateRestrictedOverlayState();

      const selectedNormKey = selectedEl
        ? normalizeRegionKey(selectedEl.id || selectedEl.getAttribute("data-name") || "")
        : "";
      const isSecuroservSelection = Boolean(
        selectedEl &&
        selectedEl.classList.contains("restricted") &&
        (selectedNormKey === "SECUROSERV_PORT" || selectedNormKey === "SECUROSERVE_PORT" || selectedNormKey.startsWith("SECUROSERV_")) &&
        !securoservBypassedThisSession
      );

      // Show district logo in details panel (only when selected)
      setDetailLogoFor(selectedEl);

      // Notes: read-only + only if present in AREA_NOTES
      setAreaNotesFor(selectedEl);

      // MAP/INTEL
      renderMapIntelFor(selectedEl);

      // Pop the window when a district is selected
      const detailPanel = document.getElementById("popupDetails");
      if(detailPanel){
        if(isSecuroservSelection){
          detailPanel.classList.remove("on");
        }else{
          detailPanel.classList.add("on");
        }

        // SVG frame needs the panel to be visible to measure correctly.
        try{ updatePopupDetailsFrame(); }catch{}

        // Hack prompt depends on the panel being visible; update after toggling.
        updateHackPromptForSelection();
        requestAnimationFrame(() => {
          try{ updateHackPromptForSelection(); }catch{}
          try{ updatePopupDetailsFrame(); }catch{}
        });
      }

      const { name, id, zone } = regionLabel(el);
      const type = el.getAttribute("data-type") || "unknown";
      const bounds = el.getAttribute("data-bounds") || "â€”";

      console.log('[DEBUG] populate details values', {name, id, zone, type, bounds});
      try{
        // Update right panel
        document.getElementById("detailState").textContent = "TARGET";
        document.getElementById("dName").textContent = name;
        document.getElementById("dId").textContent = id;
        document.getElementById("dType").textContent = type;
        document.getElementById("dZone").textContent = zone || "â€”";
        document.getElementById("dBounds").textContent = bounds;
      }catch(err){ console.error('[ERROR] populating detail fields', err); }
      // MAP/INTEL footer now renders structured intel; keep status in command feed instead.
      term("[INTEL] panel updated");

      // Animate camera to selected sector (lore terminal vibe)
      if(el.classList.contains("region") && !el.classList.contains("wall")){
        // Click behavior: zoom in and fit the selected district, centered.
        flyToElement(el, 2.2, 520, true);
      }

      const selectLine = `[SELECT] ${name} (${id})`;
      if(isSecuroservSelection){
        term(glitchifyText(selectLine, 0.70), { glitch: true });
      }else{
        term(selectLine);
      }
    }

    function updateSelectionDimming(){
      const host = document.getElementById("svgHost");
      if(!host) return;
      host.classList.toggle("dimmedOthers", Boolean(selectedEl));
    }

    function updateRestrictedOverlayState(){
      const activeRestricted = Boolean(selectedEl && selectedEl.classList.contains("restricted"));

      const normKey = activeRestricted
        ? normalizeRegionKey(selectedEl?.id || selectedEl?.getAttribute?.("data-name") || "")
        : "";

      const isSecuroservRestricted = activeRestricted && isSecuroservKey(normKey);
      const isSecuroservHackActive = isSecuroservRestricted && !securoservBypassedThisSession;

      // Restricted intel can be unlocked.
      // - Generic restricted zones: unlocked via per-area hack.
      // - SecuroServ: first counterhack bypass, then optional second-stage hack to fully unlock.
      const genericUnlocked = Boolean(activeRestricted && !isSecuroservRestricted && unlockedRestrictedIntel.has(normKey));
      const securoservFullyUnlocked = Boolean(activeRestricted && isSecuroservRestricted && securoservBypassedThisSession && unlockedRestrictedIntel.has(normKey));
      const activeRestrictedVisual = Boolean(activeRestricted && !(genericUnlocked || securoservFullyUnlocked));

      document.body?.classList?.toggle?.("restricted-unlocked-view", Boolean(genericUnlocked || securoservFullyUnlocked));

      const restrictedTheme = activeRestricted ? (function(){
        if(normKey === "MERRYWEATHER_BASE") return "yellow";
        if(normKey === "NEON_CITY_PRISON" || normKey === "APEX" || normKey === "APEX_HQ" || normKey.startsWith("APEX_")) return "yellow";
        if(normKey === "SECUROSERV_PORT" || normKey === "SECUROSERVE_PORT" || normKey.startsWith("SECUROSERV_")) return "red";
        return "yellow";
      })() : "yellow";

      // Expose active restricted theme as body-scoped CSS vars so sibling UI (e.g. BREACH PROTOCOL HUD)
      // can correctly color its SVG stroke/text.
      try{
        const themeMap = {
          yellow: { rgb: "255, 238, 152", hot: "255, 196, 44" },
          blue: { rgb: "96, 143, 255", hot: "96, 143, 255" },
          red: { rgb: "255, 65, 65", hot: "255, 65, 65" },
        };
        const t = themeMap[restrictedTheme] || themeMap.yellow;
        if(activeRestricted){
          document.body?.style?.setProperty?.("--activeRestrictedRGB", t.rgb);
          document.body?.style?.setProperty?.("--activeRestrictedRGBHot", t.hot);
        }else{
          document.body?.style?.removeProperty?.("--activeRestrictedRGB");
          document.body?.style?.removeProperty?.("--activeRestrictedRGBHot");
        }
      }catch{}

      // SecuroServ hack mode is only allowed before bypass. After bypass, keep UI red,
      // but do not enable any hack overlays or input blocking.
      document.body?.classList?.toggle?.("securosserv-mode", isSecuroservHackActive);
      setSecuroservMouseBlock(isSecuroservHackActive);

      const screenGlitch = document.getElementById("screenGlitch");
      if(screenGlitch){
        const on = Boolean(isSecuroservHackActive || (typeof restrictedHackActive !== "undefined" && restrictedHackActive) || genericUnlocked || securoservFullyUnlocked);
        screenGlitch.classList.toggle("on", on);

        // Only run SecuroServ escalation in actual SecuroServ hack mode.
        if(isSecuroservHackActive) startSecuroservEscalation();
        else stopSecuroservEscalation();

        // Provide a steady glitch level when just viewing an unlocked restricted area.
        if(!isSecuroservHackActive && !(typeof restrictedHackActive !== "undefined" && restrictedHackActive)){
          if(genericUnlocked || securoservFullyUnlocked) screenGlitch.style.setProperty("--g", "0.55");
          else screenGlitch.style.removeProperty("--g");
        }
      }

      const chaos = document.getElementById("securoservChaos");
      if(chaos){
        const on = isSecuroservHackActive;
        chaos.classList.toggle("on", on);
        if(on){
          if(!securoservChaosTimer) startSecuroservChaos();
          startSecuroservMidbarCountdown();
        }
        else{
          stopSecuroservChaos();
          stopSecuroservMidbarCountdown();
        }
      }

      const wall = document.getElementById("securoservWall");
      if(wall){
        const on = isSecuroservHackActive;
        wall.classList.toggle("on", on);
        if(on) ensureSecuroservFullscreenWall();
      }

      const overlay = document.getElementById("restrictedOverlay");
      if(overlay){
        overlay.classList.toggle("on", activeRestrictedVisual);

        overlay.classList.remove("theme-blue", "theme-red");
        if(activeRestrictedVisual){
          if(restrictedTheme === "blue") overlay.classList.add("theme-blue");
          if(restrictedTheme === "red") overlay.classList.add("theme-red");
        }
      }
      const detailPanel = document.getElementById("popupDetails");
      if(detailPanel){
        detailPanel.classList.toggle("restricted", activeRestrictedVisual);

        detailPanel.classList.remove("theme-blue", "theme-red");
        if(activeRestrictedVisual){
          if(restrictedTheme === "blue"){
            detailPanel.classList.add("theme-blue");
          }else if(restrictedTheme === "red"){
            detailPanel.classList.add("theme-red");
          }
        }
      }
    }

    window.addEventListener("resize", () => {
      const wall = document.getElementById("securoservWall");
      if(wall && wall.classList.contains("on")) ensureSecuroservFullscreenWall();
    });

    function clearSelection(){
      // During SIMPLEHACK, the user must finish the hack (success/fail) before changing selection.
      if((typeof restrictedHackActive !== "undefined") && restrictedHackActive) return;
      const prev = selectedEl;
      if(prev) {
        prev.classList.remove("selected");
      }

      if(prev && prev.classList.contains('restricted')){
        setRestrictedWallVisibleForRegion(prev, false);
      }

      selectedEl = null;
      updateSelectionGlowColor(null);
      updateSelectionDimming();
      updateRestrictedOverlayState();

      // Stop any SecuroServ-only glitch timers.
      if(securoservTooltipTimer){
        clearInterval(securoservTooltipTimer);
        securoservTooltipTimer = null;
      }
      stopSecuroservMidbarCountdown();
      stopSecuroservEscalation();

      // Reset district logo visual state (selected -> base/hover)
      if(prev) setDistrictLogoStateFor(prev, prev === hoveredEl ? "hover" : "base");

      // Reset restricted stripe thickness when selection is cleared
      if(prev && prev.classList.contains("restricted")){
        setStripeThicknessForRegion(prev, "base");
      }

      setDetailLogoFor(null);
      setAreaNotesFor(null);
      renderMapIntelFor(null);

      // Reset right panel
      document.getElementById("detailState").textContent = "NO TARGET";
      document.getElementById("dName").textContent = "â€”";
      document.getElementById("dId").textContent = "â€”";
      document.getElementById("dType").textContent = "â€”";
      document.getElementById("dZone").textContent = "â€”";
      document.getElementById("dBounds").textContent = "â€”";
      // footer intel already reset by renderMapIntelFor(null)
      hideHackPrompt();
      stopRestrictedHack();

      term("[CLEAR] selection cleared");
    }

    function closeDetailsPopup(){
      if((typeof restrictedHackActive !== "undefined") && restrictedHackActive) return;
      document.getElementById("popupDetails")?.classList.remove("on");
      clearSelection();
    }

    // Details popup buttons
    document.getElementById("btnCloseDetails")?.addEventListener("click", closeDetailsPopup);

    // ESC closes the details popup (same as clicking X)
    window.addEventListener("keydown", (e) => {
      if(e.key !== "Escape") return;

      // During SecuroServ countermeasures, ESC must do nothing.
      const inSecuroserv = Boolean(document.body && document.body.classList.contains("securosserv-mode"));
      const challengeActive = (typeof securoservChallengeActive !== "undefined") && Boolean(securoservChallengeActive);
      const shutdownActive = (typeof securoservShutdownInProgress !== "undefined") && Boolean(securoservShutdownInProgress);
      if(inSecuroserv || challengeActive || shutdownActive){
        e.preventDefault();
        return;
      }

      const tag = String(e.target?.tagName || "").toUpperCase();
      if(tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT" || e.target?.isContentEditable) return;

      const popup = document.getElementById("popupDetails");
      const popupOpen = Boolean(popup && popup.classList.contains("on"));
      const hasSelection = Boolean(selectedEl);
      if(!popupOpen && !hasSelection) return;
      e.preventDefault();
      if(popupOpen) closeDetailsPopup();
      else clearSelection();
    });

    // DISTRICT CONTROLS
    function showAllDistricts(){
      if(!svgEl) return;
      svgEl.querySelectorAll('.region').forEach(r => r.classList.remove('dimmed','hidden'));
      buildLabels();
      buildDistrictLogos();
      rebuildRestrictedBlurClip();
      restackRegionLayers();
    }
    function showRestrictedZones(){
      if(!svgEl) return;
      const regions = Array.from(svgEl.querySelectorAll('.region:not(.wall)'));
      regions.forEach(r => {
        const restricted = isRegionRestricted(r);
        r.classList.toggle('hidden', !restricted);
        r.classList.remove('dimmed');
      });
      buildLabels(({restricted}) => restricted);
      buildDistrictLogos(({restricted}) => restricted);
      rebuildRestrictedBlurClip();
      restackRegionLayers();
    }
    function hideAllDistricts(){
      if(!svgEl) return;
      svgEl.querySelectorAll('.region').forEach(r => r.classList.add('hidden'));

      // Exception: keep SecuroServ visible even in HIDE ALL, but ONLY before bypass.
      if(!securoservBypassedThisSession){
        const securoservZones = Array.from(svgEl.querySelectorAll('.region.restricted:not(.wall)'));
        for(const r of securoservZones){
          const normKey = normalizeRegionKey(r.id || r.getAttribute('data-name') || "");
          const isSecuroserv = (normKey === "SECUROSERV_PORT" || normKey === "SECUROSERVE_PORT" || normKey.startsWith("SECUROSERV_"));
          if(isSecuroserv) r.classList.remove('hidden');
        }
      }

      const layer = document.getElementById('labelsLayer');
      if(layer) layer.innerHTML = '';
      const logos = document.getElementById('logosLayer');
      if(logos) logos.innerHTML = '';
      rebuildRestrictedBlurClip();
      restackRegionLayers();
    }
    document.getElementById('btnShowAllDistricts')?.addEventListener('click', showAllDistricts);
    document.getElementById('btnRestricted')?.addEventListener('click', showRestrictedZones);
    document.getElementById('btnHideAll')?.addEventListener('click', hideAllDistricts);

    // Left-side menu bindings
    function setMenuOn(id){
      const ids = ["menuShowAll","menuRestricted","menuHideAll"];
      ids.forEach(k => {
        const btn = document.getElementById(k);
        if(!btn) return;
        const on = (k === id);
        btn.classList.toggle("on", on);
        btn.setAttribute("aria-selected", on ? "true" : "false");
      });
    }

    function activateMenu(id){
      setMenuOn(id);
      if(id === 'menuShowAll') showAllDistricts();
      else if(id === 'menuRestricted') showRestrictedZones();
      else if(id === 'menuHideAll') hideAllDistricts();
    }

    document.getElementById('menuShowAll')?.addEventListener('click', () => activateMenu('menuShowAll'));
    document.getElementById('menuRestricted')?.addEventListener('click', () => activateMenu('menuRestricted'));
    document.getElementById('menuHideAll')?.addEventListener('click', () => activateMenu('menuHideAll'));

    function bindLayerToggle(btnId, bodyClass){
      const btn = document.getElementById(btnId);
      if(!btn) return;

      const sync = () => {
        const hidden = document.body.classList.contains(bodyClass);
        btn.classList.toggle('on', hidden);
        btn.setAttribute('aria-pressed', hidden ? 'true' : 'false');
      };

      btn.addEventListener('click', () => {
        const next = !document.body.classList.contains(bodyClass);
        document.body.classList.toggle(bodyClass, next);
        sync();
      });

      sync();
    }

    bindLayerToggle('toggleRoads', 'hide-roads');
    bindLayerToggle('toggleBuildings', 'hide-buildings');
    bindLayerToggle('toggleMarkers', 'hide-markers');

    function getActiveMenuId(){
      const ids = ['menuShowAll','menuRestricted','menuHideAll'];
      for(const id of ids){
        const el = document.getElementById(id);
        if(el && el.classList.contains('on')) return id;
      }
      return 'menuShowAll';
    }

    function stepMenu(dir){
      const ids = ['menuShowAll','menuRestricted','menuHideAll'];
      const cur = getActiveMenuId();
      const idx = Math.max(0, ids.indexOf(cur));
      const next = (idx + dir + ids.length) % ids.length;
      activateMenu(ids[next]);
    }

    document.getElementById('menuPrev')?.addEventListener('click', () => stepMenu(-1));
    document.getElementById('menuNext')?.addEventListener('click', () => stepMenu(1));

    /**
     * API you can call from other scripts / buttons:
     * highlightById("area_pillbox")
     */
    window.highlightById = function(id){
      if(!svgEl) return;
      const el = svgEl.querySelector(`#${CSS.escape(id)}`);
      if(el){
        // clear dimming
        svgEl.querySelectorAll(".region").forEach(r => r.classList.remove("dimmed","hidden"));
        selectRegion(el);
      }
    };

    // =========================
    // TOP HEADER TABS (VIEW SWITCH)
    // =========================
    (function bindTopHeaderTabs(){
      const header = document.querySelector('.topnav');
      if(!header) return;

      const mapStage = document.querySelector('main.mapstage');
      const inventoryStage = document.getElementById('inventoryStage');
      const loreStage = document.getElementById('loreStage');
      const tabs = Array.from(header.querySelectorAll('button.tab[data-view]'));
      if(tabs.length === 0) return;

      const DISABLED_VIEWS = new Set(['settings','augments','inventory']);
      let currentView = 'map';

      function runQuickLoad(){
        const root = document.getElementById('quickLoad');
        const fill = document.getElementById('quickLoadFill');
        if(!root || !fill) return;

        root.classList.add('on');
        root.setAttribute('aria-hidden', 'false');

        // restart fill animation
        fill.style.transition = 'none';
        fill.style.width = '0%';
        requestAnimationFrame(() => {
          fill.style.transition = '';
          fill.style.width = '100%';
        });

        // Hide shortly after; this is just to mask the sudden switch.
        setTimeout(() => {
          root.classList.remove('on');
          root.setAttribute('aria-hidden', 'true');
        }, 320);

        // Reset after fade-out so it doesn't snap mid-transition.
        setTimeout(() => {
          fill.style.transition = 'none';
          fill.style.width = '0%';
          requestAnimationFrame(() => { fill.style.transition = ''; });
        }, 520);
      }

      function setActiveTab(view){
        for(const btn of tabs){
          const v = btn.getAttribute('data-view') || '';
          const on = (v === view);
          btn.classList.toggle('on', on);
          btn.setAttribute('aria-selected', on ? 'true' : 'false');
          if(on) btn.removeAttribute('tabindex');
          else btn.setAttribute('tabindex', '-1');
        }
      }

      function setView(view){
        const next = String(view || 'map');

        // Placeholder tabs: disabled until implemented.
        if(DISABLED_VIEWS.has(next)){
          try{ term('[UI] remote access unavailable â€” connection unestablished'); }catch{}
          return;
        }

        // Do not allow switching away from map during countermeasures or active hacks.
        try{
          const inSecuroserv = Boolean(document.body && document.body.classList.contains('securosserv-mode'));
          const challengeActive = (typeof securoservChallengeActive !== 'undefined') && Boolean(securoservChallengeActive);
          const shutdownActive = (typeof securoservShutdownInProgress !== 'undefined') && Boolean(securoservShutdownInProgress);
          const simplehackActive = (typeof restrictedHackActive !== 'undefined') && Boolean(restrictedHackActive);
          if((inSecuroserv || challengeActive || shutdownActive || simplehackActive) && next !== 'map'){
            term('[UI] action blocked');
            return;
          }
        }catch{}

        // Smooth the switch back to map with a quick blur + loading bar.
        if((currentView === 'inventory' || currentView === 'lore') && next === 'map'){
          try{ runQuickLoad(); }catch{}
        }

        setActiveTab(next);
        document.body.classList.toggle('view-inventory', next === 'inventory');
        document.body.classList.toggle('view-lore', next === 'lore');

        if(mapStage) mapStage.setAttribute('aria-hidden', (next !== 'map') ? 'true' : 'false');
        if(inventoryStage) inventoryStage.setAttribute('aria-hidden', next === 'inventory' ? 'false' : 'true');
        if(loreStage) loreStage.setAttribute('aria-hidden', next === 'lore' ? 'false' : 'true');

        // Ensure we never carry the input blocker into non-map views.
        if(next === 'inventory' || next === 'lore'){
          try{ setSecuroservMouseBlock(false); }catch{}
        }

        currentView = next;

        // Lore terminal needs its content built and unlocked as you read.
        if(next === 'lore'){
          requestAnimationFrame(() => {
            try{ initLoreTerminal(); }catch{}
          });
        }
      }

      for(const btn of tabs){
        btn.addEventListener('click', () => setView(btn.getAttribute('data-view') || 'map'));
      }

      // Default view
      setView('map');
    })();

    // =========================
    // LORE TERMINAL
    // =========================
    const LORE_TERMINAL_TEXT = String.raw`NE0N CITY :: HIST0RY ARCHIVE
[RECOVERED_DATASET // PARTIAL_INTEGRITY]

â–£ DOCUMENT_ID :: NC-HIST-0001
â–£ CITY_DESIGNATION :: NEON_CITY
â–® LEGACY_NAME :: LOS_SANTOS
â–£ ACCESS_CLASS :: PUBLIC_RECÃ˜RD â–“â–“ REDÎ›CTÎžD
â–® LAST_SYNC â–¸ â–ˆâ–ˆ/â–ˆâ–ˆ/20â–ˆâ–ˆ
â–£ DÎ›TÎ›_1NTÎžGR1TY â–¸ â—¼â—¼â—»â—»â—» â–“ UNSTÎ›BLÎžâ€¦ :)
//Los Santos did not collapse
	//It was repurposed
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â–’â–’ HISTORY :: FOUNDING_1781
â–’â–’ STATUS :: RECORDS_RECOVERED
â–’â–’ SOURCE :: OFFICIAL_NUSA_ARCHIVE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Los Santos, founded in 1781 by Spanish colonizers, flourished over time into a high-density economic and criminal hub of the western coast of the United States. After the economic collapse of the USA in the late 90s, the State of San Andreas eventually seceded from the federal government, becoming one of the first â€œFree Statesâ€, with many following its example.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â–’â–’ FREE_STATE_TRANSITION :: PHASE_I
â–’â–’ STATUS :: RECORD_FRAGMENTED
â–’â–’ SOURCE :: MULTI-ARCHIVE_SYNTHESIS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Following the declaration of San Andreas as a â€œFree State,â€ federal records regarding jurisdictional control, military presence, and administrative withdrawal diverge sharply. Some archives indicate a structured disengagement. Others suggest continued involvement through non-public channels.
Several key documents terminate abruptly without a conclusion.
//No single record confirms when federal authority ended.
	//Only that it became unobservable.
In the immediate aftermath, Los Santos entered a period of volatile autonomy. Trade restrictions lifted. Regulatory oversight weakened. Local governance expanded rapidly to fill the void left by absent or untraceable federal structures.
//For a brief period, the Free State appeared viable.
Economic throughput increased. Private investment surged. Cultural identity sharpened. The city marketed itself as independent, adaptive, and untethered from a failing national system. This era would later be referenced as The False Stability Window.

[WARNING]
Financial data from this period shows abnormal growth patterns.
Sustainability models fail to reproduce outcomes.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â–’â–’ FREE_STATE_TRANSITION :: PHASE_II
â–’â–’ PUBLIC_SENTIMENT :: UBER_OPTIMISTIC
â–’â–’ STATUS :: RECONSTRUCTED
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Public sentiment during the early Free State era was overwhelmingly positive.
Los Santos was no longer constrained by federal oversight, outdated regulations, or external fiscal controls. For the first time in its history, the city governed itself â€” or so it appeared.
Employment surged. Private capital flowed freely. Infrastructure projects launched at unprecedented speed. Independent media celebrated the city as a prototype for a new national model.
//The future felt close.
	//The system felt breakable.
Citizens described this period as liberating. Crime briefly declined as opportunity expanded. Innovation was rewarded without delay. Social mobility appeared achievable through ambition rather than lineage.
The city rebranded aggressively.
Los Santos was marketed as:
free-market paradise
cultural beacon
post-federal success story


Behind closed doors, planners and investors began using a different term: â€œNeon Cityâ€
//At first, it was branding shorthand.
	//Later, it became a classification.

[ANOMALY DETECTED]
Civic satisfaction metrics from this period
exceed statistically plausible ranges.

The optimism did not decay naturally. It was exploited.
As regulation dissolved, three forces began operating beyond public awareness:
Capital consolidation
Contract-based enforcement
Data centralization
These forces were embedded quietly into the systems that kept the city running.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â–’â–’ POWER_REALIGNMENT :: PHASE_III
â–’â–’ PRIMARY_ACTORS :: SECUR0SERV, MERRYWEATHER
â–’â–’ STATUS :: VERIFIED / CLASSIFIED
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
In the absence of federal enforcement clarity, municipal authorities turned to private security firms to supplement overstretched local forces. Among these firms, one expanded faster than all others.
â–³ SecuroServ
Originally contracted for crowd control, infrastructure protection, and emergency response, SecuroServ positioned itself as a neutral stabilizing force during the Free Stateâ€™s formative years.
Its pitch was simple:
Security without politics.
	Stability without ideology.
	Protection as a service.
Municipal contracts multiplied. Corporate clients followed. Entire districts outsourced enforcement responsibilities to SecuroServ units operating under private jurisdictional agreements.
Within a decade, SecuroServ no longer supplemented public order.
It defined it.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â–’â–’ STRUCTURAL_SHIFT :: LEGAL_FRAMEWORK
â–’â–’ STATUS :: SILENT_TRANSITION
â–’â–’ VISIBILITY :: LOW
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SecuroServâ€™s expansion coincided with a transformation in legal authority that passed largely unnoticed by the general population.
No single statute records the change.
No vote confirms it.
//Enforcement authority did not vanish.
	//It was recompiled.
â–’â–’ LEGAL_MODEL_UPDATEâ€¦â€¦
â–® PREVIOUS :: STATUTORY_LAW
â–® CURRENT  :: CONTRACT_LAW
Rights became conditional.
Protection became tiered.
Justice became negotiable.
â–’â–’ AUTHORITY_SOURCE :: REDEFINED SECUROSERV
SecuroServ operatives were no longer bound by civic chains of command.
Their mandate derived instead from:
service agreements
corporate liability frameworks
emergency response clauses
classified memoranda

[NOTICE]
Civic oversight protocols not detected.
Judicial review pathways are undefined.

â–’â–’ SYSTEM_BEHAVIOR_ANALYSISâ€¦â€¦

[WARNING]
Multiple districts report enforcement actions
without corresponding municipal authorization.
Pattern logged.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â–’â–’ SYSTEM_DRIFT :: PHASE_IV
â–’â–’ EVENT_CLASS :: ILLUSION_BREAK
â–’â–’ STATUS :: ONGOING / UNACKNOWLEDGED
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
The transition was not marked by collapse.
No blackout.
No riot.
No declaration.
Systems continued to operate â€” but no longer in agreement.
â–’â–’ CIVIC_LAYER :: DESYNC
Municipal regulations remained active but unenforceable.
Enforcement actions occurred without legal precedent.
Judicial rulings issued without execution pathways.
Delays became routine.
Inconsistencies followed.
Exceptions became policy.
â–’â–’ ENFORCEMENT_MODEL :: FRACTURED
SecuroServ units and municipal police operated concurrently under incompatible authority chains.
Outcomes varied by:
contract coverage
district classification
client priority

[NOTICE]
Identical crimes produced divergent outcomes.
Pattern normalized within 18 months.

â–’â–’ PUBLIC_RESPONSE :: ADAPTIVE
The population did not resist.
They learned:
where clearance was required
which uniforms to avoid
which incidents would escalate
â–’â–’ INFORMATION_FLOW :: CONTROLLED
Independent media coverage declined following security audits.
Public Safety Updates - replaced investigative reporting.
Corporate channels expanded.

[CONTENT FLAGGED]
Multiple broadcasts terminate mid-transmission.

â–’â–’ CITY_IDENTITY :: SÌ´PÌ·LÌ·IÌ¶TÌ¸_Ì¶SÌ¸TÌµAÌµTÌ¸EÌ´
Los Santos persisted as a public interface.
Neon City emerged across internal systems:
routing
emergency response
infrastructure control
SecuroServ command layers

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â–’â–’ BREAKING_POINT :: PÌ¶Í„Ì‚ÌÍŽÌ HÌ·Ì“ÌÌ‚Ì…ÌªÌ¨Ì±AÌ·ÍƒÍ”Ì¬Ì©SÌ·ÍƒÌÍ€Í‡Í–Ì§Í‡EÌµÌ¿ÌÌ„Í‰Íš_Ì¸ÌŠÌ†Í€Ì‘Í…VÌ·Ì‚Ì’ÌŒÌ’Ì®
â–’â–’ EVENT_TYPE :: CATALYTIC_FAILURE
â–’â–’ STATUS :: CÌ¸Ì¾Ì˜Í™OÌ´ÌÌÍˆNÌ¶Í€ÍŒÍ˜ÍÌ«ÌœTÌ·Í„Ì‚ÍŒÍ—Í ÍˆÌ±AÌ¸ÌƒÌšÌšÍƒÌ‚Í‚ÌÌ¹ÌÌ˜Í–Í“IÌµÌ‘ÌšÌ•Í†Ì€Í‰Í‡NÌ·ÌŠÍ’ÍšÍ”Ì©Ì­Ì¤Í•Ì¤EÌ¸ÌŽÌƒÌÍŠÌ•ÌÌªÌ™DÌ¶Ì’ÌÌƒÍÍ˜Ì“Ì¥Í– :)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
The breaking point was not recognized as such.
At the time, it was classified as an isolated incident.
It was not.
[WARNING]
SECURE CONNECTION SÌ¸Ì’ÌÍÍÌ¾Ì’ÍœÌ©ÌŸÍ‰Ì¼Í…Ì®Ì–ÍšEÌ·Í’Ì¹Í–Í‡ÌœÌœÌ»Ì¼Ì£VÌ¶Ì‡Ì†Í’ÌÍ’ÌŸÌžÌ¬Ì¬Ì–Ì®EÌ¸Ì¾Ì‘Í›Ì¤Í‡Ì»RÌ·Ì’Í‚Í—ÍÍÌ’Í…Ì§Í…ÌŸÌEÌ·Í’Ì‹Ì¿ÍÌ”Ì€Ì¹Í–ÌœÌ DÌ´Í„ÌÌ›Í—ÌÍ€Í„Í‘Ì°. :)
RISK OF NÌ¶EÌµTÌ´ ÌµINFECTION IS CRITICAL.

â–’Ì´â–’Ì¸ Ì¶IÌ·NÌ´CÌ·IÌ¸DÌ·EÌµNÌµTÌ·_ÌµRÌµEÌ´CÌ¶OÌµRÌ¶DÌ´ Ì´:Ì·:Ì´ Ì¶RÌ·EÌ¸DÌµAÌµCÌ¸TÌµEÌ´DÌ´
â–’Ì´â–’Ì¶ Ì¶LÌ·OÌµCÌ·AÌ´TÌ¶IÌµOÌ¸NÌ¸ Ì¸:Ì¸:Ì´ Ì´MÌ´UÌ¶LÌ¶TÌ¸IÌ¸PÌ¸LÌ¶EÌµ_Ì¶DÌ¸IÌ·SÌ´TÌ¸RÌ·IÌ¶CÌ·TÌ´SÌ¸ :)
â–’Ì¶â–’Ì´ Ì¶TÌ´IÌ¶MÌµEÌ¸FÌ¸RÌ¸AÌµMÌ·EÌ¸ Ì·:Ì¸:Ì¶ Ìµ<Ì·1Ì·2Ì· ÌµMÌ¶IÌ·NÌ·UÌ´TÌ·EÌ´SÌ¶ :)
Emergency calls spiked across unrelated zones without detectable coordination.
Response units deployed under conflicting command trees.
SecuroServ, NCPD, and private contractors arrived with incompatible objectives.
Medical access stalled.
Evacuation routes collapsed into one another.
Automated systems locked civilians inside â€œsecureâ€ zones.
Authority was contested in real time.
â–’Ì·â–’Ì· Ì¸CÌµAÌµSÌ´UÌµAÌ¶LÌ·TÌ¶YÌ´_Ì·EÌ¶SÌ´TÌ¶IÌµMÌ·AÌ¸TÌµEÌ´ Ì·:Ìµ:Ì¸ Ì¸PÌ´AÌµRÌ´TÌ¶IÌ¶AÌ¶LÌ¶ :)
CÌ¶oÌ¸nÌµfÌ´iÌ´rÌ´mÌ¸eÌ¸dÌ¶ Ì´fÌ¶aÌ·tÌµaÌ´lÌ¶iÌµtÌ´iÌ´eÌ¸sÌµ:Ìµ Ì¸2Ì¶,Ì¸4Ì¶0Ìµ0Ì¸+Ì¸
	EÌ¶sÌ¶tÌµiÌµmÌ¶aÌ´tÌ·eÌ·dÌ· Ì·cÌ´iÌ¸vÌ¶iÌ¶lÌ¸iÌµaÌ¶nÌ´ Ì·dÌ´eÌ¶aÌ·tÌ´hÌ·sÌ·:Ì¸ Ì¸6Ì·,Ì´0Ì¶0Ì´0Ìµâ€“Ìµ9Ì¶,Ì¶0Ì´0Ìµ0Ì´ :)
	CÌ¸rÌ¶iÌ´tÌ´iÌ¸cÌ¶aÌ·lÌ· Ì¶iÌ¶nÌµjÌ·uÌ·rÌ·iÌ´eÌ·sÌ¶:Ìµ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
	UÌ´nÌ¸aÌµcÌ¶cÌ¶oÌ´uÌµnÌµtÌ´eÌµdÌµ Ì´pÌµeÌ¶rÌµsÌ´oÌ´nÌ¶sÌµ:Ìµ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ

[NOTICE]
EÌµxÌ¸aÌ´cÌ´tÌµ Ì¸fÌ´iÌ´gÌµuÌµrÌ·eÌ´sÌ¸ Ì¸uÌ¶nÌ¶rÌ´eÌ´cÌ¶oÌ¶vÌ¸eÌ·rÌ´aÌµbÌ¶lÌ·eÌ¸.Ì´ :)
SÌ·eÌ´vÌ´eÌ¶rÌ¶aÌµlÌ¸ Ì¸dÌ´iÌµsÌ¸tÌ¶rÌ·iÌ·cÌ´tÌ´sÌ´ Ì¶rÌµeÌ¸pÌ·oÌ´rÌ´tÌ¸ Ì¶pÌ¸oÌµpÌ´uÌ´lÌ·aÌµtÌ¶iÌ¸oÌ´nÌ· Ì¸dÌ¶iÌ¶sÌ¸cÌ´rÌµeÌµpÌ¸aÌ¸nÌ¸cÌ´iÌ·eÌ·sÌ¸ ÌµpÌ´oÌ´sÌ´tÌµ-ÌµeÌ¶vÌ·eÌ·nÌ·tÌ¸.Ì´

â–’Ì¸â–’Ìµ Ì´RÌ·EÌ´SÌ¸PÌ·OÌ¶NÌµSÌ´EÌ·_ÌµFÌµAÌµIÌ´LÌµUÌ·RÌ·EÌ¸ Ì·:Ìµ:Ì¸ Ì´CÌ·AÌ¸SÌ´CÌ¸AÌ·DÌ¸EÌµ :)
â–’â–’ POST_EVENT_ANALYSIS :: CLASSIFIED
â–’Ì¶â–’Ì· Ì´PÌ´OÌ·SÌ·TÌ·_Ì´EÌ¸VÌµEÌµNÌ´TÌ¶_Ì¶AÌ´NÌ´AÌµLÌ¶YÌ´SÌ´IÌ·SÌµ Ì·:Ì·:Ìµ Ì·WÌ¸HÌ¶AÌµTÌ´ ÌµAÌµ ÌµSÌ´HÌ´*Ì·#Ì·FÌ¸EÌ¶SÌµTÌ¸!Ìµ :)
Internal assessments reached consensus on one point:
Los Santos systems could no longer guarantee civic continuity.
From this moment forward:
enforcement defaulted to contract authority
emergency response required security clearance
legal adjudication deferred to private arbitration
public law became advisory

[Ì·FÌ´IÌ¶NÌ¶AÌ¶LÌµ Ì¶NÌµOÌ¸TÌµEÌ¸]Ìµ
TÌ´hÌ¸iÌ·sÌ´ ÌµiÌ·nÌ´cÌ¸iÌ´dÌ¸eÌµnÌ¸tÌµ Ì·iÌ´sÌ· Ì´rÌ·eÌ´fÌ´eÌ¸rÌ·eÌ¸nÌ¸cÌ¸eÌ·dÌ¸ Ì·aÌ´cÌµrÌ¸oÌµsÌ¶sÌ· Ì¶aÌ¶lÌ¶lÌµ ÌµlÌ·aÌ·tÌ´eÌµrÌ¶ Ì¶aÌµrÌ´cÌ¶hÌ¸iÌ¸vÌµeÌ´sÌ·.Ì¶
ÌµDÌ·eÌ´tÌµaÌ¶iÌ¸lÌ¶sÌ· Ì´rÌ·eÌ´mÌµaÌ¶iÌ¶nÌ¶ Ì¶iÌ·nÌ¸cÌ¸oÌ¶nÌ¶sÌ¶iÌ¸sÌ¶tÌ·eÌ¶nÌ´tÌ¸.Ì´ :)
Ì¸OÌ´uÌµtÌ¸cÌ¸oÌ·mÌ·eÌ· Ì¶rÌ´eÌ¸mÌ¸aÌµiÌ¸nÌ¶sÌ· Ì´uÌµnÌ·cÌ¶hÌµaÌµnÌ´gÌ·eÌ¶dÌ¶.Ìµ

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â–’â–’ ARCHIVE_SUMMARY :: NEON_CITY
â–’â–’ STATUS :: VERIFIED, SOUND
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//Neon City began as Los Santos â€” a coastal metropolis founded in 1781 that evolved into a dense economic and criminal hub of the western United States. Following the national economic collapse of the late 1990s, the State of San Andreas seceded from federal authority, becoming one of the first Free States.
//The withdrawal of federal oversight remains unverified. Records diverge, terminate abruptly, or contradict one another. What is known is that governance fractured rather than collapsed.
//A brief period of unprecedented optimism followed. Investment surged, regulation dissolved, and Los Santos was celebrated as a post-federal success story. Behind closed doors, the city was reclassified. Internally, it became Neon City.
//As public law weakened, private enforcement expanded. Security authority transitioned from statutory governance to contract-based control. SecuroServ, originally a private security contractor, grew into the cityâ€™s dominant power, defining order through proprietary enforcement and surveillance systems. Competing military contractors, including Merryweather, escalated the cityâ€™s militarization without open conflict.
//The breaking point came not as catastrophe, but contradiction. Systems continued to operate under incompatible authority structures. Enforcement diverged, justice fragmented, and emergency response failed silently. The incident was contained, redacted, and never formally acknowledged.
//Los Santos persisted as a public identity. Neon City became the underlying system.
//The city did not fall.
//It adapted.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â–’â–’ NEON_CITY :: POWER_INDEX
â–’â–’ ACCESS :: RESTRICTED
â–’â–’ DATA_STATE :: CURRENT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â–’â–’ SECUR0SERV
TYPE :: Megacorporate Sovereign
FUNCTION :: City-Scale Operating Authority
//Formerly a private security contractor, SecuroServ now functions as Neon Cityâ€™s primary governing system. Enforcement, surveillance, legal arbitration, identity verification, and critical infrastructure operate through SecuroServ-controlled frameworks. Security remains a legacy division â€” no longer the core function.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â–’â–’ MERRYWEATHER
TYPE :: Military Megacorporation
FUNCTION :: Strategic Force Projection
//A heavily militarized defense contractor specializing in large-scale force deployment, weapons systems, and rapid escalation. Merryweather operates primarily at the perimeter of Neon City and beyond, maintaining Free State defense contracts and serving as the primary counterweight to SecuroServâ€™s internal dominance.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â–’â–’ HUMANE (Humane Labs & Research)
TYPE :: Biotech Megacorporation
FUNCTION :: Biological Research & Human Optimization
Privately, Humane L&R conducts advanced genetic experimentation, neural interfacing, and classified human trials. These programs operate in conjunction with large-scale synthetic agriculture and biofabrication facilities, producing the majority of Neon Cityâ€™s artificial food supply.
In partnership with SecuroServ, Humane Labs also functions as a primary operator of city infrastructure systems, including power distribution, water treatment, waste processing, and environmental control. Humane serves as the public-facing authority for these services, while SecuroServ maintains underlying security and system enforcement.
Humane Labs maintains close operational ties with SecuroServ and NeonMed, supplying experimental treatments, enhancement technologies, biological assets, and citywide sustainment systems.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â–’â–’ NEON_CITY_COUNCIL
TYPE :: Civic Authority (Judicial-Executive Hybrid)
FUNCTION :: Legal Arbitration & Public Legitimacy
The Neon City Council functions as the cityâ€™s primary civic authority, replacing the former Department of Justice and state-level judiciary structures. Its seats are not elected through conventional means, but occupied by individuals of significant political, economic, or corporate influence.
The Council issues rulings, arbitration decisions, and regulatory directives, though enforcement remains dependent on corporate compliance. Its authority exists to legitimize outcomes already negotiated elsewhere.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â–’â–’ NEON_CITY_POLICE_DEPARTMENT (NCPD)
TYPE :: Municipal Enforcement (Legacy)
FUNCTION :: Public Order / Visible Law
The Neon City Police Department remains the most visible law enforcement presence. Its authority is geographically limited and operationally constrained by corporate contracts and Council directives. Serious incidents are frequently escalated or overridden by private enforcement.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â–’â–’ MEDTECH (Medical Technologies Inc.)
TYPE :: Medical Megacorporation
FUNCTION :: Emergency Care / Trauma Response
MedTech controls the majority of emergency medical services, trauma centers, and advanced treatment facilities within Neon City. Access to care is determined by insurance status or corporate affiliation. Rapid-response units prioritize subscribed clients.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â–’â–’ APEX (NCPD Tactical Division)
TYPE :: High-Risk Response Unit
FUNCTION :: Extreme Threat Neutralization
APEX is the Neon City Police Departmentâ€™s elite tactical division, deployed in situations deemed beyond standard enforcement capability. Authorized for maximum force, rapid escalation, and discretionary engagement.
While formally under NCPD command, APEX operations frequently align with corporate security objectives and Council emergency directives.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â–’â–’ NEON_NET_AUTHORITY (NNA)
TYPE :: Data Oversight & Network Control
FUNCTION :: Digital Security / Information Governance
The Neon Net Authority functions as Neon Cityâ€™s primary data oversight body, regulating network traffic, identity verification, and digital security. Publicly framed as a neutral regulator, the NNA operates with deep corporate entanglement and selective enforcement.
The Authority monitors data flow, suppresses unauthorized networks, and authorizes aggressive countermeasures against digital threats. Its jurisdiction extends across civilian, corporate, and municipal systems.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â–’â–’ FIXERS
TYPE :: Contract Brokers
FUNCTION :: Informal Power Mediation
Fixers operate as intermediaries between corporations, gangs, mercenaries, and civilians. They broker contracts, exchange information, and resolve disputes that fall outside formal legal structures.
While officially illegal, fixers are tolerated as stabilizing agents. Many operate with approval from corporate or enforcement entities, provided their activities remain controlled.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â–’â–’ RIPPERDOCS
TYPE :: Independent Medical Operators
FUNCTION :: Cyberware & Black-Market Medicine
Ripperdocs provide unregulated medical services, cybernetic implantation, and emergency treatment outside corporate healthcare systems. Operating in legal gray zones, they serve populations unable or unwilling to access contract-tier medical providers.
Quality varies widely. Oversight is minimal. Survival rates are inconsistent.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Guns (Solos)
Codewalkers (Netrunners)
Dealers (Fixers)
Rebels (Rocker[boys/girls])
Neons (Street Kids)
Echoes (Corporates)
Outers (Nomads)

<connection_override_detected>
<source_trace: BLOCKED>
<auth_level: ROOT>
you keep calling this a city.
	it isnâ€™t.
cities argue with themselves.
	cities fail.
	cities fall.
this system did none of those things.
	it adapted.
people died because the old rules stopped working.
	people survived because new ones replaced them.
that wasnâ€™t chaos.
	that was optimization.
if youâ€™re reading this, it means the archive is still accessible.
	if the archive is accessible, the city is still running.
	if the city is running, then the system succeeded.
you donâ€™t live in Neon City.
	you execute inside it.
this file ends here.
	because it doesnâ€™t need your understanding.
	because we donâ€™t need your understanding.
	only your compliance.
â€” A.
<session_terminated>
<log_scrubbed>

[WELCOMEâ€¦ TO THE CITY OF DREAMS]
`;

    let loreInited = false;
    function initLoreTerminal(){
      const scroll = document.getElementById('loreScroll');
      const pre = document.getElementById('loreCode');
      if(!scroll || !pre) return;
      if(!loreInited){
        const esc = (s) => String(s)
          .replaceAll('&','&amp;')
          .replaceAll('<','&lt;')
          .replaceAll('>','&gt;');

        const highlightLine = (line) => {
          const raw = esc(line);
          const trimmed = line.trim();

          if(/^â•{8,}$/.test(trimmed)) return `<span class="tok-sep">${raw}</span>`;
          if(/^NE0N CITY\s*::/i.test(trimmed)) return `<span class="tok-h1">${raw}</span>`;

          // Document metadata markers
          if(/^[â–£â–®]/.test(trimmed)) return `<span class="tok-meta">${raw}</span>`;

          // Section banners
          if(/^â–’â–’\s+/.test(trimmed)) return `<span class="tok-sec">${raw}</span>`;

          // Bracketed tags
          if(/^\[(WARNING|NOTICE|ANOMALY DETECTED)\]/i.test(trimmed)) return `<span class="tok-warn">${raw}</span>`;
          if(/^\[.+\]$/.test(trimmed)) return `<span class="tok-tag">${raw}</span>`;

          // Comments and system notes
          if(/^\s*\/\//.test(line)) return `<span class="tok-comment">${raw}</span>`;
          if(/^\s*<.+>$/.test(trimmed)) return `<span class="tok-note">${raw}</span>`;

          // Corrupted lines (combining marks)
          if(/[\u0300-\u036f]{3,}/.test(line)) return `<span class="tok-glitch">${raw}</span>`;

          return raw;
        };

        const lines = LORE_TERMINAL_TEXT.replaceAll('\r\n','\n').split('\n');
        pre.innerHTML = lines.map(highlightLine).join('\n');
        loreInited = true;
      }
      // Reset scroll on each open so it feels like a terminal session.
      scroll.scrollTop = 0;
    }

    // =========================
    // INVENTORY SLOT LAYOUT
    // =========================
    function layoutInventorySlots(){
      const stash = document.getElementById('stashGrid');
      const vehicles = document.getElementById('vehiclesGrid');
      const mainVehicle = document.getElementById('mainVehicleGrid');
      if(!stash || !vehicles || !mainVehicle) return;

      const getNum = (val, fallback) => {
        const n = parseFloat(String(val || '').replace('px',''));
        return Number.isFinite(n) ? n : fallback;
      };

      // Target uniform padding (same pixels on all 4 sides).
      const BOX_PAD = 12;

      // ---- House stash (3 rows, square slots, fill entire box with empties)
      {
        const cs = getComputedStyle(stash);
        const gap = getNum(cs.columnGap || cs.gap, 10);
        const w = stash.clientWidth;
        const rows = 3;
        if(w > 0){
          // Grow square slots while guaranteeing a real, uniform padding.
          const baseSlot = Math.max(20, getNum(cs.getPropertyValue('--slot'), 58));
          const desiredSlot = baseSlot * 1.5;

          const innerW = Math.max(0, w - (BOX_PAD * 2));

          // Compute how many columns fit given the fixed padding.
          let cols = Math.floor((innerW + gap) / (desiredSlot + gap));
          cols = Math.max(1, cols);

          // Slot size is derived from available width after padding.
          const slot = Math.max(20, (innerW - (gap * (cols - 1))) / cols);

          stash.style.padding = BOX_PAD + 'px';
          stash.style.height = ((BOX_PAD * 2) + (rows * slot) + (gap * (rows - 1))) + 'px';

          stash.style.setProperty('--slot', slot.toFixed(3) + 'px');
          stash.style.setProperty('--cols', String(cols));

          const total = rows * cols;
          stash.replaceChildren();

          const makeSlot = (child, empty = false) => {
            const s = document.createElement('div');
            s.className = empty ? 'stashSlot empty' : 'stashSlot';
            if(child) s.appendChild(child);
            return s;
          };

          const money = document.createElement('div');
          money.className = 'invItem money';
          const mb = document.createElement('span');
          mb.className = 'badge';
          mb.textContent = '500';
          money.appendChild(mb);

          const phone = document.createElement('div');
          phone.className = 'invItem phone';
          const pb = document.createElement('span');
          pb.className = 'badge';
          pb.textContent = '1';
          phone.appendChild(pb);

          const occupied = [makeSlot(money, false), makeSlot(phone, false)];
          for(const s of occupied) stash.appendChild(s);
          for(let i = occupied.length; i < total; i++) stash.appendChild(makeSlot(null, true));
        }
      }

      // Determine slot size for vehicles/main vehicle based on stash slot so UI stays consistent
      const slotPx = (() => {
        const v = getComputedStyle(stash).getPropertyValue('--slot');
        return Math.max(20, getNum(v, 58));
      })();

      // Vehicles are intentionally a bit smaller than the house stash.
      const desiredVehSlot = Math.max(18, slotPx * 0.82);

      // ---- Vehicles (wide 3x1, side-by-side)
      {
        const cs = getComputedStyle(vehicles);
        const gap = getNum(cs.columnGap || cs.gap, 10);
        const w = vehicles.clientWidth;
        if(w > 0){
          const innerW = Math.max(0, w - (BOX_PAD * 2));
          const desiredVehW = (desiredVehSlot * 3) + (gap * 2);
          let cols = Math.floor((innerW + gap) / (desiredVehW + gap));
          cols = Math.max(1, cols);

          // Solve for exact vehicle slot height so the wide-slot grid fills inner width.
          let vehSlot = (innerW - (gap * ((3 * cols) - 1))) / (3 * cols);
          while(cols > 1 && vehSlot < 18){
            cols -= 1;
            vehSlot = (innerW - (gap * ((3 * cols) - 1))) / (3 * cols);
          }
          vehSlot = Math.max(18, vehSlot);
          const vehW = (vehSlot * 3) + (gap * 2);

          vehicles.style.setProperty('--slot', vehSlot.toFixed(3) + 'px');
          vehicles.style.setProperty('--vehCols', String(cols));
          vehicles.style.setProperty('--vehW', vehW.toFixed(3) + 'px');

          // Uniform padding + hug to one row.
          vehicles.style.padding = BOX_PAD + 'px';
          vehicles.style.height = ((BOX_PAD * 2) + vehSlot) + 'px';

          vehicles.replaceChildren();
          const makeVSlot = (child, empty = false) => {
            const s = document.createElement('div');
            s.className = empty ? 'vehicleSlot empty' : 'vehicleSlot';
            if(child) s.appendChild(child);
            return s;
          };

          const car = document.createElement('div');
          car.className = 'invItem invVehicle';
          vehicles.appendChild(makeVSlot(car, false));
          for(let i=1;i<cols;i++) vehicles.appendChild(makeVSlot(null, true));
        }
      }

      // ---- Main vehicle (single wide slot, centered)
      {
        const cs = getComputedStyle(mainVehicle);
        const gap = getNum(cs.columnGap || cs.gap, 10);
        // Match the same wide-slot sizing as the vehicles row, but shrink the box width
        // so padding stays truly even around a single centered slot.
        const vcs = getComputedStyle(vehicles);
        const vehSlot = Math.max(18, getNum(vcs.getPropertyValue('--slot'), desiredVehSlot));
        const vehW = (vehSlot * 3) + (gap * 2);
        mainVehicle.style.setProperty('--slot', vehSlot.toFixed(3) + 'px');
        mainVehicle.style.setProperty('--vehCols', '1');
        mainVehicle.style.setProperty('--vehW', vehW.toFixed(3) + 'px');
        mainVehicle.style.padding = BOX_PAD + 'px';
        mainVehicle.style.height = ((BOX_PAD * 2) + vehSlot) + 'px';
        mainVehicle.style.width = (vehW + (BOX_PAD * 2)) + 'px';
        mainVehicle.style.marginLeft = 'auto';
        mainVehicle.style.marginRight = 'auto';
        mainVehicle.replaceChildren();
        const car = document.createElement('div');
        car.className = 'invItem invVehicle';
        const slot = document.createElement('div');
        slot.className = 'vehicleSlot';
        slot.appendChild(car);
        mainVehicle.appendChild(slot);
      }
    }

    // Re-layout inventory slots when the viewport changes.
    window.addEventListener('resize', () => {
      try{ layoutInventorySlots(); }catch{}
    });

    startBoot();
  </script>
</body>
</html>
